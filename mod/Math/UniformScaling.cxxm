module;

#include "LoopMacros.hxx"
#include "Macros.hxx"
export module UniformScaling;

import ArrayConcepts;
import AxisTypes;
import CorePrint;
import ExprTemplates;
import SIMD;
import std;
import BaseUtils;
export namespace math {

template <class T> struct UniformScaling {
  using value_type = T;
  T value_;
  TRIVIAL constexpr UniformScaling(T x) : value_(x) {}
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r, std::ptrdiff_t c) const
    -> T {
    return r == c ? value_ : T{};
  }
  template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t W, typename M>
  TRIVIAL constexpr auto operator[](simd::index::Unroll<R> r,
                                    simd::index::Unroll<C, W, M> c) const
    -> simd::Unroll<R, C, W, T> {
    using I = utils::signed_integer_t<sizeof(T)>;
    using VI = simd::Vec<W, I>;
    simd::Vec<W, T> vz{}, vv = simd::vbroadcast<W, T>(value_);
    if constexpr (R * C == 1) {
      return {
        (simd::vbroadcast<W, I>(r.index_ - c.index_) == simd::range<W, I>())
          ? vv
          : vz};
    } else {
      simd::Unroll<R, C, W, T> ret;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 0; i < R; ++i) {
        VI vr = simd::vbroadcast<W, I>(i + r.index_),
           vc = simd::range<W, I>() + c.index_;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t j = 0; j < C; ++j, vc += W)
          ret[i, j] = (vr == vc) ? vv : vz;
      }
      return ret;
    }
  }
  template <std::ptrdiff_t C, std::ptrdiff_t W, typename M>
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r,
                                    simd::index::Unroll<C, W, M> c) const
    -> simd::Unroll<1, C, W, T> {
    return (*this)[simd::index::Unroll<1>{.index_ = r}, c];
  }
  // template <std::ptrdiff_t C, std::ptrdiff_t W, typename M>
  // TRIVIAL constexpr auto
  // operator[](simd::index::Unroll<C, W, M> r, std::ptrdiff_t c) const
  //   -> simd::Unroll<1, C, W, T> {
  //   return (*this)[r, simd::index::Unroll<1>{c}];
  // }

  TRIVIAL static constexpr auto numRow() -> Row<0> { return {}; }
  TRIVIAL static constexpr auto numCol() -> Col<0> { return {}; }
  TRIVIAL static constexpr auto size()
    -> std::integral_constant<std::ptrdiff_t, 0> {
    return {};
  }
  TRIVIAL static constexpr auto shape()
    -> CartesianIndex<std::ptrdiff_t, std::ptrdiff_t> {
    return {.row_idx_ = 0, .col_idx_ = 0};
  }
  TRIVIAL static constexpr auto dim() -> DenseDims<0, 0> { return {{}, {}}; }
  [[nodiscard]] TRIVIAL constexpr auto view() const -> auto { return *this; };
  template <class U> TRIVIAL constexpr auto operator*(const U &x) const {
    if constexpr (std::is_same_v<std::remove_cvref_t<T>, std::true_type>)
      return UniformScaling<U>{x};
    else return UniformScaling<U>{value_ * x};
  }
  TRIVIAL constexpr auto isEqual(const AbstractMatrix auto &A) const -> bool {
    auto R = std::ptrdiff_t(A.numRow());
    if (R != A.numCol()) return false;
    for (std::ptrdiff_t r = 0; r < R; ++r)
      for (std::ptrdiff_t c = 0; c < R; ++c)
        if (A[r, c] != ((r == c) * value_)) return false;
    return true;
  }
  TRIVIAL constexpr auto operator==(const AbstractMatrix auto &A) const
    -> bool {
    return isEqual(A);
  }

  TRIVIAL constexpr auto operator-() const -> UniformScaling { return -value_; }

  TRIVIAL constexpr auto operator+(const auto &b) const {
    return elementwise(*this, view(b), std::plus<>{});
  }
  TRIVIAL constexpr auto operator-(const auto &b) const {
    return elementwise(*this, view(b), std::minus<>{});
  }
  template <typename B>
  TRIVIAL constexpr auto operator*(const B &b) const
    requires(std::common_with<std::remove_cvref_t<B>, T> || AbstractTensor<B>) {
    if constexpr (!std::common_with<std::remove_cvref_t<B>, T>) {
      auto BB{b.view()};
      return elementwise(value_, BB, std::multiplies<>{});
    } else
      return UniformScaling<std::common_type_t<T, std::remove_reference_t<B>>>(
        value_ * b);
  }

  template <std::common_with<T> S>
  TRIVIAL constexpr auto operator+(UniformScaling<S> b) const {
    return UniformScaling<std::common_type_t<S, T>>(value_ + b.value_);
  }
  template <std::common_with<T> S>
  TRIVIAL constexpr auto operator-(UniformScaling<S> b) const {
    return UniformScaling<std::common_type_t<S, T>>(value_ - b.value_);
  }
  template <std::common_with<T> S>
  TRIVIAL constexpr auto operator*(UniformScaling<S> b) const {
    return UniformScaling<std::common_type_t<S, T>>(value_ * b.value_);
  }

private:
  TRIVIAL friend constexpr auto operator+(std::common_with<T> auto b,
                                          UniformScaling a) {
    return elementwise(b, a, std::plus<>{});
  }
  TRIVIAL friend constexpr auto operator-(std::common_with<T> auto b,
                                          UniformScaling a) {
    return elementwise(b, a, std::minus<>{});
  }
  TRIVIAL friend constexpr auto operator/(std::common_with<T> auto b,
                                          UniformScaling a) {
    return elementwise(b, a.value_, std::divides<>{});
  }
  TRIVIAL friend constexpr auto operator%(std::common_with<T> auto b,
                                          UniformScaling a) {
    return elementwise(b, a.value_, std::modulus<>{});
  }
  // TRIVIAL friend constexpr auto operator&(std::common_with<T> auto b,
  // UniformScaling a) {
  //   return elementwise(b, a.view(), std::bit_and<>{});
  // }
  // TRIVIAL friend constexpr auto operator|(std::common_with<T> auto b,
  // UniformScaling
  // a) {
  //   return elementwise(b, a.vie(), std::bit_or<>{});
  // }
  // TRIVIAL friend constexpr auto operator^(std::common_with<T> auto b,
  // UniformScaling a) {
  //   return elementwise(b, a.view(), std::bit_xor<>{});
  // }
  template <typename B>
  TRIVIAL friend constexpr auto operator*(const B &b, UniformScaling a)
    requires(std::common_with<std::remove_cvref_t<B>, T> || AbstractTensor<B>) {
    if constexpr (!std::common_with<std::remove_cvref_t<B>, T>) {
      auto BB{b.view()};
      return elementwise(BB, a.value_, std::multiplies<>{});
    } else
      return UniformScaling<std::common_type_t<T, std::remove_reference_t<B>>>(
        b * a.value_);
  }

  void print() const { utils::print(value_, "*I"); }
  TRIVIAL [[nodiscard]] constexpr auto t() const -> UniformScaling {
    return *this;
  }
  TRIVIAL friend constexpr auto operator==(const AbstractMatrix auto &A,
                                           const UniformScaling &B) -> bool {
    return B.isEqual(A);
  }
  template <class U>
  TRIVIAL friend constexpr auto operator*(const U &x, UniformScaling d) {
    if constexpr (std::is_same_v<std::remove_cvref_t<T>, std::true_type>)
      return UniformScaling<U>{x};
    else return UniformScaling<U>{d.value_ * x};
  }
};

[[maybe_unused]] constexpr inline UniformScaling<std::true_type> I{
  std::true_type{}}; // identity

template <class T> UniformScaling(T) -> UniformScaling<T>;
static_assert(AbstractMatrix<UniformScaling<std::int64_t>>);

} // namespace math
