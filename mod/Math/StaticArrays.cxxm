module;

#include "LoopMacros.hxx"
#include "Macros.hxx"
#include "Owner.hxx"

export module StaticArray;
import Array;
import ArrayConcepts;
import ArrayPrint;
import CorePrint;
import AxisTypes;
import CompressReference;
import ExprTemplates;
import MatDim;
import Range;
import SIMD;
import std;
import BaseUtils;

template <typename T, std::ptrdiff_t L>
consteval auto paddedSize() -> std::array<std::ptrdiff_t, 2> {
  constexpr std::ptrdiff_t WF = simd::Width<T>;
  constexpr std::ptrdiff_t W =
    L < WF ? std::ptrdiff_t(std::bit_ceil(std::uint64_t(L))) : WF;
  constexpr std::ptrdiff_t N = ((L + W - 1) / W);
  return {N, W};
}
template <typename T, std::ptrdiff_t L, std::ptrdiff_t Align>
consteval auto calcPaddedCols() -> std::ptrdiff_t {
  constexpr std::ptrdiff_t a = Align / sizeof(T);
  if constexpr (a <= 1) return L;
  else return ((L + a - 1) / a) * a;
}
template <typename T, std::ptrdiff_t L>
consteval auto alignSIMD() -> std::size_t {
  if constexpr (!simd::SIMDSupported<T>) return alignof(T);
  else return alignof(simd::Vec<simd::VecLen<L, T>, T>);
}

export namespace math {

template <class T, std::ptrdiff_t M, std::ptrdiff_t N, bool Compress>
using StaticDims = std::conditional_t<
  M == 1, math::Length<N>,
  std::conditional_t<
    Compress || ((N % simd::VecLen<N, T>) == 0), math::DenseDims<M, N>,
    math::StridedDims<M, N, calcPaddedCols<T, N, alignSIMD<T, N>()>()>>>;

static_assert(std::ptrdiff_t(StridedDims<1, 1, 1>{
                math::StaticDims<std::int64_t, 1, 1, true>{}}) == 1);
static_assert(std::ptrdiff_t(StridedDims<>{
                math::StaticDims<std::int64_t, 1, 1, true>{}}) == 1);

static_assert(AbstractSimilar<PtrVector<std::int64_t>, Length<4>>);

template <class T, std::ptrdiff_t M, std::ptrdiff_t N, bool Compress = false>
struct MATH_GSL_OWNER StaticArray
  : public ArrayOps<T, StaticDims<T, M, N, Compress>,
                    StaticArray<T, M, N, Compress>>,
    Expr<T, StaticArray<T, M, N, Compress>> {
  using storage_type = std::conditional_t<Compress, utils::compressed_t<T>, T>;
  static constexpr std::ptrdiff_t Align =
    Compress ? alignof(storage_type) : alignSIMD<T, N>();
  static constexpr std::ptrdiff_t PaddedCols = calcPaddedCols<T, N, Align>();
  static constexpr std::ptrdiff_t capacity = M * PaddedCols;

  static_assert(alignof(storage_type) <= Align);

  alignas(Align) storage_type memory_[capacity]{};

  using value_type = utils::decompressed_t<T>;
  using reference = decltype(utils::ref((storage_type *)nullptr, 0));
  using const_reference =
    decltype(utils::ref((const storage_type *)nullptr, 0));
  using size_type = std::ptrdiff_t;
  using difference_type = std::ptrdiff_t;
  using iterator = storage_type *;
  using const_iterator = const storage_type *;
  using pointer = storage_type *;
  using const_pointer = const storage_type *;
  using concrete = std::true_type;

  // if Compress=false, we have a compressed_t
  // if Compress=true, we should already be compressed
  using compressed_type = StaticArray<T, M, N, true>;
  using decompressed_type = StaticArray<value_type, M, N, false>;
  using S = StaticDims<T, M, N, Compress>;
  static constexpr bool can_flatten = std::is_convertible_v<S, DenseDims<>>;
  using Expr<T, StaticArray<T, M, N, Compress>>::operator==;
  using Expr<T, StaticArray<T, M, N, Compress>>::operator!=;
  using Expr<T, StaticArray<T, M, N, Compress>>::operator<;
  using Expr<T, StaticArray<T, M, N, Compress>>::operator>;
  using Expr<T, StaticArray<T, M, N, Compress>>::operator<=;
  using Expr<T, StaticArray<T, M, N, Compress>>::operator>=;
  TRIVIAL constexpr StaticArray() = default;
  TRIVIAL constexpr explicit StaticArray(const T &x) noexcept {
    if consteval {
      for (std::ptrdiff_t i = 0; i < M * N; ++i) memory_[i] = x;
    } else {
      (*this) << x;
    }
  }
  TRIVIAL constexpr explicit StaticArray(
    const std::convertible_to<T> auto &x) noexcept {
    (*this) << x;
  }
  TRIVIAL constexpr StaticArray(const StaticArray &) = default;
  TRIVIAL constexpr explicit StaticArray(StaticArray &&) noexcept = default;
  TRIVIAL constexpr explicit StaticArray(const std::initializer_list<T> &list) {
    if (list.size() == 1) {

      (*this) << *list.begin();
      return;
    }
    invariant(list.size() <= std::size_t(capacity));
    std::copy_n(list.begin(), list.size(), data());
  }
  TRIVIAL static constexpr auto fill(T val) -> StaticArray {
    StaticArray ret;
    std::fill_n(ret.memory_, capacity, val);
    return ret;
  }
  template <AbstractSimilar<S> V>
  TRIVIAL constexpr StaticArray(const V &b) noexcept {
    vcopyTo(mview(), b, detail::CopyAssign{});
  }

  TRIVIAL constexpr void compress(compressed_type *p) const
    requires(std::same_as<StaticArray, decompressed_type>) {
    *p << *this;
  }
  TRIVIAL static constexpr auto decompress(const compressed_type *p)
    -> StaticArray requires(std::same_as<StaticArray, decompressed_type>) {
    return StaticArray{*p};
  }
  TRIVIAL [[nodiscard]] constexpr auto data() const noexcept
    -> const storage_type * {
    return static_cast<const storage_type *>(memory_);
  }
  TRIVIAL constexpr auto data() noexcept -> storage_type * {
    return static_cast<storage_type *>(memory_);
  }

  TRIVIAL constexpr auto operator=(StaticArray const &)
    -> StaticArray & = default;
  TRIVIAL constexpr auto operator=(StaticArray &&) noexcept
    -> StaticArray & = default;

  TRIVIAL [[nodiscard]] constexpr auto begin() const noexcept { return data(); }
  TRIVIAL [[nodiscard]] constexpr auto end() const noexcept {
    return begin() + capacity;
  }
  TRIVIAL [[nodiscard]] constexpr auto rbegin() const noexcept {
    return std::reverse_iterator(end());
  }
  TRIVIAL [[nodiscard]] constexpr auto rend() const noexcept {
    return std::reverse_iterator(begin());
  }
  TRIVIAL [[nodiscard]] constexpr auto front() const noexcept -> const T & {
    return *begin();
  }
  TRIVIAL [[nodiscard]] constexpr auto back() const noexcept -> const T & {
    return *(end() - 1);
  }
  // indexing has two components:
  // 1. offsetting the pointer
  // 2. calculating new dim
  // static constexpr auto slice(Valid<T>, Index<S> auto i){
  //   auto
  // }
  TRIVIAL constexpr auto operator[](Index<S> auto i) const noexcept
    -> decltype(auto) {
    return index<T>(data(), S{}, i);
  }
  // for vectors, we just drop the column, essentially broadcasting
  template <class R, class C>
  TRIVIAL constexpr auto operator[](R r, C c) const noexcept -> decltype(auto) {
    return index<T>(data(), S{}, r, c);
  }
  TRIVIAL [[nodiscard]] static constexpr auto minRowCol() -> std::ptrdiff_t {
    return std::min(std::ptrdiff_t(numRow()), std::ptrdiff_t(numCol()));
  }

  TRIVIAL [[nodiscard]] constexpr auto diag() const noexcept {
    StridedRange<> r{length(minRowCol()), RowStride(S{}) + 1};
    auto ptr = data();
    invariant(ptr != nullptr);
    return Array<T, StridedRange<>>{ptr, r};
  }
  TRIVIAL [[nodiscard]] constexpr auto antiDiag() const noexcept {
    StridedRange<> r{length(minRowCol()), RowStride(S{}) - 1};
    auto ptr = data();
    invariant(ptr != nullptr);
    return Array<T, StridedRange<>>{ptr + std::ptrdiff_t(Col(S{})) - 1, r};
  }
  TRIVIAL [[nodiscard]] static constexpr auto isSquare() noexcept -> bool {
    return Row(S{}) == Col(S{});
  }

  TRIVIAL [[nodiscard]] static constexpr auto checkSquare()
    -> Optional<std::ptrdiff_t> {
    if constexpr (M == N) return M;
    else return {};
  }
  TRIVIAL [[nodiscard]] static constexpr auto numRow() noexcept -> Row<M> {
    return {};
  }
  TRIVIAL [[nodiscard]] static constexpr auto numCol() noexcept -> Col<N> {
    return {};
  }
  TRIVIAL static constexpr auto safeRow() -> Row<M> { return {}; }
  TRIVIAL static constexpr auto safeCol() -> Col<PaddedCols> { return {}; }
  TRIVIAL [[nodiscard]] static constexpr auto rowStride() noexcept
    -> RowStride<PaddedCols> {
    return {};
  }
  TRIVIAL [[nodiscard]] static constexpr auto empty() -> bool {
    return capacity == 0;
  }
  TRIVIAL [[nodiscard]] static constexpr auto size() noexcept
    -> std::integral_constant<std::ptrdiff_t, M * N> {
    return {};
  }
  TRIVIAL [[nodiscard]] static constexpr auto dim() noexcept -> S {
    return S{};
  }
  TRIVIAL [[nodiscard]] constexpr auto t() const
    -> Transpose<T, Array<T, S, Compress>> {
    return {*this};
  }
  TRIVIAL [[nodiscard]] constexpr auto isExchangeMatrix() const -> bool {
    if constexpr (M == N) {
      for (std::ptrdiff_t i = 0; i < M; ++i) {
        for (std::ptrdiff_t j = 0; j < M; ++j)
          if ((*this)(i, j) != (i + j == M - 1)) return false;
      }
    } else return false;
  }
  TRIVIAL [[nodiscard]] constexpr auto isDiagonal() const -> bool {
    for (std::ptrdiff_t r = 0; r < numRow(); ++r)
      for (std::ptrdiff_t c = 0; c < numCol(); ++c)
        if (r != c && (*this)(r, c) != 0) return false;
    return true;
  }
  TRIVIAL [[nodiscard]] constexpr auto view() const noexcept
    -> Array<T, S, Compress && utils::Compressible<T>> {
    return {data(), S{}};
  }
  TRIVIAL [[nodiscard]] constexpr auto untransposed_view() const noexcept
    -> Array<T, S, Compress && utils::Compressible<T>> {
    return {data(), S{}};
  }
  TRIVIAL [[nodiscard]] constexpr auto mview() noexcept
    -> MutArray<T, S, Compress && utils::Compressible<T>> {
    return {data(), S{}};
  }
  TRIVIAL [[nodiscard]] constexpr auto flatview() const noexcept
    requires(can_flatten) {
    return Array<T, Length<M * N>, Compress>{data(), {}};
  }
  TRIVIAL [[nodiscard]] constexpr auto mflatview() const noexcept
    requires(can_flatten) {
    return MutArray<T, Length<M * N>, Compress>{data(), {}};
  }

  TRIVIAL [[nodiscard]] constexpr auto begin() noexcept {
    if constexpr (std::is_same_v<S, StridedRange<>>)
      return StridedIterator{data(), S{}.stride};
    else return data();
  }
  [[nodiscard]] constexpr auto end() noexcept { return begin() + capacity; }
  [[nodiscard]] constexpr auto rbegin() noexcept {
    return std::reverse_iterator(end());
  }
  [[nodiscard]] constexpr auto rend() noexcept {
    return std::reverse_iterator(begin());
  }
  TRIVIAL constexpr auto front() noexcept -> T & { return *begin(); }
  TRIVIAL constexpr auto back() noexcept -> T & { return *(end() - 1); }
  TRIVIAL [[gnu::flatten]] constexpr auto operator[](Index<S> auto i) noexcept
    -> decltype(auto) {
    return index<T>(data(), S{}, i);
  }
  template <class R, class C>
  TRIVIAL [[gnu::flatten]] constexpr auto operator[](R r, C c) noexcept
    -> decltype(auto) {
    return index<T>(data(), S{}, r, c);
  }
  TRIVIAL [[nodiscard]] constexpr auto diag() noexcept {
    if constexpr (N <= M)
      return MutArray<T, StridedRange<N, PaddedCols + 1>>{data(), {}};
    else return MutArray<T, StridedRange<M, PaddedCols + 1>>{data(), {}};
  }
  TRIVIAL [[nodiscard]] constexpr auto antiDiag() noexcept {
    if constexpr (N <= M)
      return MutArray<T, StridedRange<N, PaddedCols - 1>>{data() + M - 1, {}};
    else
      return MutArray<T, StridedRange<M, PaddedCols - 1>>{data() + M - 1, {}};
  }
  template <typename SHAPE>
  TRIVIAL constexpr
  operator Array<T, SHAPE, Compress &&utils::Compressible<T>>() const
    requires(std::convertible_to<S, SHAPE>) {
    return {const_cast<T *>(data()), SHAPE(dim())};
  }
  // template<containers::ConvertibleFrom<S> SHAPE>
  // constexpr auto operator==(Array<T,SHAPE> rhs) const noexcept -> bool {
  //   return std::equal(begin(), end(), rhs.begin());
  // }
  // template <MatrixDimension S>
  // constexpr auto operator==(Array<T,S> rhs) const ->bool
  // (requires((M==1)||(N==1))){
  //   if ((rhs.numRow() != M)||(rhs.numCol() != N)) return false;
  // }
  template <std::size_t I> TRIVIAL constexpr auto get() -> T & {
    return memory_[I];
  }
  template <std::size_t I>
  TRIVIAL [[nodiscard]] constexpr auto get() const -> const T & {
    return memory_[I];
  }
  TRIVIAL constexpr void set(T x, std::ptrdiff_t r, std::ptrdiff_t c) {
    memory_[(r * N) + c] = x;
  }

  DEBUGUSED void print() const requires(utils::ColumnPrintable<T>) {
    if constexpr (utils::Printable<T>) {
      if constexpr (MatrixDimension<S>) utils::printMatrix(data(), M, N, N);
      else utils::printVector(begin(), end());
      utils::flush();
    }
  }
  TRIVIAL constexpr auto maximum() const -> T requires(M *N == 1) {
    return memory_[0];
  }
  TRIVIAL constexpr auto minimum() const -> T requires(M *N == 1) {
    return memory_[0];
  }
  TRIVIAL constexpr auto sum() const -> T requires(M *N == 1) {
    return memory_[0];
  }
  TRIVIAL constexpr auto prod() const -> T requires(M *N == 1) {
    return memory_[0];
  }
};

template <simd::SIMDSupported T, std::ptrdiff_t M, std::ptrdiff_t N>
requires((M * (N + simd::VecLen<N, T> - 1) / simd::VecLen<N, T>) > 1)
struct MATH_GSL_OWNER StaticArray<T, M, N, false>
  : ArrayOps<T, StaticDims<T, M, N, false>, StaticArray<T, M, N, false>>,
    Expr<T, StaticArray<T, M, N, false>> {
  using Expr<T, StaticArray<T, M, N, false>>::operator==;
  using Expr<T, StaticArray<T, M, N, false>>::operator!=;
  using Expr<T, StaticArray<T, M, N, false>>::operator<;
  using Expr<T, StaticArray<T, M, N, false>>::operator>;
  using Expr<T, StaticArray<T, M, N, false>>::operator<=;
  using Expr<T, StaticArray<T, M, N, false>>::operator>=;
  // struct StaticArray<T, M, N, alignof(simd::Vec<simd::VecLen<N, T>, T>)>
  //   : ArrayOps<T, StaticDims<T, M, N, alignof(simd::Vec<simd::VecLen<N, T>,
  //   T>)>,
  //              StaticArray<T, M, N, alignof(simd::Vec<simd::VecLen<N, T>,
  //              T>)>> {

  using value_type = T;
  using reference = T &;
  using const_reference = const T &;
  using size_type = std::ptrdiff_t;
  using difference_type = std::ptrdiff_t;
  using iterator = T *;
  using const_iterator = const T *;
  using pointer = T *;
  using const_pointer = const T *;
  using concrete = std::true_type;

  static constexpr std::ptrdiff_t W = simd::VecLen<N, T>;
  static constexpr std::ptrdiff_t Align = alignof(simd::Vec<W, T>);
  using S = StaticDims<T, M, N, false>;

  TRIVIAL [[nodiscard]] static constexpr auto dim() noexcept -> S {
    return S{};
  }

  static constexpr std::ptrdiff_t L = (N + W - 1) / W;
  static constexpr bool can_flatten = L * W == N;
  static_assert(L * W == calcPaddedCols<T, N, Align>());
  using V = simd::El<W, T>;
  // simd::Vec<W, T> data[M][L];
  V memory_[M * L]{};

  using compressed_type = StaticArray<T, M, N, L * W != N>;
  using actually_compressed_type = StaticArray<T, M, N, true>;

  constexpr void compress(compressed_type *p) const { *p << *this; }
  constexpr void compress(actually_compressed_type *p) const requires(L *W == N)
  {
    *p << *this;
  }
  static constexpr auto decompress(const compressed_type *p) -> StaticArray {
    return StaticArray{*p};
  }
  static constexpr auto decompress(const actually_compressed_type *p)
    -> StaticArray requires(L *W == N) {
    return StaticArray{*p};
  }
  TRIVIAL static constexpr auto fill(T val) -> StaticArray {
    V v{simd::vbroadcast<W>(val)};
    StaticArray ret;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < M * L; ++i) ret.memory_[i] = v;
    return ret;
  }
  TRIVIAL constexpr auto findFirstEqIdx(T x) -> std::ptrdiff_t {
    V v = simd::vbroadcast<W>(x);
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < M * L; ++i) {
      auto mask = simd::cmp::eq(memory_[i], v);
      if (mask.any()) return mask.onBegin() + (i * W);
    }
    return -1;
  }

  // std::array<std::array<simd::Vec<W, T>, L>, M> data;
  // constexpr operator compressed_type() { return compressed_type{*this}; }
  TRIVIAL [[nodiscard]] constexpr auto view() const -> StaticArray
    requires(M *L <= 4) {
    return *this;
  }
  TRIVIAL [[nodiscard]] constexpr auto view() const noexcept
    -> Array<T, S, false> requires(M *L > 4) {
    return {data(), S{}};
  }
  TRIVIAL [[nodiscard]] constexpr auto simd() const
    -> simd::Unroll<M, L, W, T> {
    simd::Unroll<M, L, W, T> ret;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < M * L; ++i) ret.data_[i] = memory_[i];
    return ret;
  }
  [[nodiscard]] TRIVIAL constexpr auto split() const
    requires((M == 1) || (N == 1)) {
    static_assert(M > 1 || N > 1);
    if constexpr (M == 1) {
      // Row vector case: split columns
      static_assert(L > 1);
      auto s = simd().split();
      using Half = StaticArray<T, 1, N / 2, false>;
      return std::array<Half, 2>{Half{s[0]}, Half{s[1]}};
    } else {
      // Column vector case: split rows
      static_assert(M > 1);
      auto s = simd().split();
      using Half = StaticArray<T, M / 2, 1, false>;
      return std::array<Half, 2>{Half{s[0]}, Half{s[1]}};
    }
  }
  [[nodiscard]] TRIVIAL constexpr auto cat(StaticArray b) const
    -> StaticArray<T, M == 1 ? 1 : M << 1, M == 1 ? N << 1 : 1, false>
    requires((M == 1) || (N == 1)) {
    if constexpr (M == 1) {
      // Row vector case: concatenate columns
      StaticArray<T, 1, N << 1, false> ret;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 0; i < L; ++i) {
        ret.memory_[i] = memory_[i];
        ret.memory_[i + L] = b.memory_[i];
      }
      return ret;
    } else {
      // Column vector case: concatenate rows
      StaticArray<T, M << 1, 1, false> ret;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 0; i < M * L; ++i) {
        ret.memory_[i] = memory_[i];
        ret.memory_[i + M * L] = b.memory_[i];
      }
      return ret;
    }
  }
  [[nodiscard]] TRIVIAL constexpr auto repElements4() const
    -> StaticArray<T, M, 4 * N> {
    StaticArray<T, M, 4 * N> ret;
    if constexpr (W == 2) {
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 0; i < M * L; ++i) {
        V v{memory_[i]}, a = simd::vbroadcast<2>(v[0]),
                         b = simd::vbroadcast<2>(v[1]);
        ret.memory_[4 * i] = a, ret.memory_[(4 * i) + 1] = a;
        ret.memory_[(4 * i) + 2] = b, ret.memory_[(4 * i) + 3] = b;
      }
    } else if constexpr (W == 4) {
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 0; i < M * L; ++i) {
        V v{memory_[i]};
        ret.memory_[4 * i] = simd::vbroadcast<4>(v[0]);
        ret.memory_[(4 * i) + 1] = simd::vbroadcast<4>(v[1]);
        ret.memory_[(4 * i) + 2] = simd::vbroadcast<4>(v[2]);
        ret.memory_[(4 * i) + 3] = simd::vbroadcast<4>(v[3]);
      }
    } else {
      static_assert(W == 8);
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 0; i < M * L; ++i) {
        V v{memory_[i]};
        ret.memory_[4 * i] =
          __builtin_shufflevector(v, v, 0, 0, 0, 0, 1, 1, 1, 1);
        ret.memory_[(4 * i) + 1] =
          __builtin_shufflevector(v, v, 2, 2, 2, 2, 3, 3, 3, 3);
        ret.memory_[(4 * i) + 2] =
          __builtin_shufflevector(v, v, 4, 4, 4, 4, 5, 5, 5, 5);
        ret.memory_[(4 * i) + 3] =
          __builtin_shufflevector(v, v, 6, 6, 6, 6, 7, 7, 7, 7);
      }
    }
    return ret;
  }
  TRIVIAL [[nodiscard]] constexpr auto untransposed_view() const -> StaticArray
    requires(M *L <= 4) {
    return *this;
  }
  TRIVIAL [[nodiscard]] constexpr auto untransposed_view() const noexcept
    -> Array<T, S, false> requires(M *L > 4) {
    return {data(), S{}};
  }
  TRIVIAL [[nodiscard]] constexpr auto mview() noexcept
    -> MutArray<T, S, false> {
    return {data(), S{}};
  }
  TRIVIAL [[nodiscard]] constexpr auto flatview() const noexcept
    requires(can_flatten) {
    return Array<T, Length<M * N>, false>{data(), {}};
  }
  TRIVIAL [[nodiscard]] constexpr auto mflatview() const noexcept
    requires(can_flatten) {
    return MutArray<T, Length<M * N>, false>{data(), {}};
  }

  TRIVIAL constexpr StaticArray() = default;
  TRIVIAL constexpr StaticArray(StaticArray const &) = default;
  TRIVIAL constexpr StaticArray(StaticArray &&) noexcept = default;
  TRIVIAL constexpr explicit StaticArray(const std::initializer_list<T> &list) {
    std::ptrdiff_t sz = list.size();
    if (sz == 1) {
      (*this) << *list.begin();
      return;
    }
    invariant(sz == M * N);
    char *c = reinterpret_cast<char *>(memory_);
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t m = 0; m < M; ++m) {
      std::memcpy(c, list.begin() + m * N, N * sizeof(T));
      if constexpr (N < W * L)
        std::memset(c + N * sizeof(T), 0, (L * W - N) * sizeof(T));
      c += L * W * sizeof(T);
    }
  }
  TRIVIAL [[nodiscard]] constexpr StaticArray(simd::Unroll<M, L, W, T> u) {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < M * L; ++i) memory_[i] = u.data_[i];
  }
  TRIVIAL constexpr auto data() -> T * {
    return reinterpret_cast<T *>(memory_);
  }
  TRIVIAL [[nodiscard]] constexpr auto data() const -> const T * {
    return reinterpret_cast<const T *>(memory_);
  }
  TRIVIAL [[nodiscard]] constexpr auto begin()
    -> T * requires(((M == 1) || (N == 1))) {
    return data();
  }

  TRIVIAL [[nodiscard]] constexpr auto end()
    -> T * requires(((M == 1) || (N == 1))) {
    return data() + (M * N);
  }

  TRIVIAL [[nodiscard]] constexpr auto begin() const
    -> const T * requires(((M == 1) || (N == 1))) {
    return data();
  }

  TRIVIAL [[nodiscard]] constexpr auto end() const
    -> const T * requires(((M == 1) || (N == 1))) {
    return data() + (M * N);
  }

  TRIVIAL [[nodiscard]] constexpr auto t() const
    -> Transpose<T, Array<T, S, false>> {
    return {*this};
  }
  template <AbstractSimilar<S> V>
  TRIVIAL constexpr StaticArray(const V &b) noexcept {
    ::math::promote_shape(*this, b);
    vcopyTo(mview(), b, detail::CopyAssign{});
  }
  TRIVIAL constexpr explicit StaticArray(T x) {
    simd::Vec<W, T> v = simd::vbroadcast<W, T>(x);
    for (std::ptrdiff_t i = 0; i < M * L; ++i) memory_[i] = v;
  }
  TRIVIAL constexpr auto operator=(StaticArray const &)
    -> StaticArray & = default;
  TRIVIAL constexpr auto operator=(StaticArray &&) noexcept
    -> StaticArray & = default;
  TRIVIAL static constexpr auto numRow() -> Row<M> { return {}; }
  TRIVIAL static constexpr auto numCol() -> Col<N> { return {}; }
  TRIVIAL static constexpr auto safeRow() -> Row<M> { return {}; }
  TRIVIAL static constexpr auto safeCol() -> Col<L * W> { return {}; }
  TRIVIAL [[nodiscard]] static constexpr auto rowStride() noexcept
    -> RowStride<L * W> {
    return {};
  }
  TRIVIAL [[nodiscard]] static constexpr auto size() noexcept
    -> std::integral_constant<std::ptrdiff_t, M * N> {
    return {};
  }
  template <typename SHAPE>
  TRIVIAL constexpr operator Array<T, SHAPE, false>() const
    requires(std::convertible_to<S, SHAPE>) {
    return {const_cast<T *>(data()), SHAPE(dim())};
  }
  template <typename SHAPE>
  TRIVIAL constexpr operator MutArray<T, SHAPE, false>()
    requires(std::convertible_to<S, SHAPE>) {
    return {data(), SHAPE(dim())};
  }
  template <std::ptrdiff_t U, typename Mask>
  TRIVIAL auto operator[](std::ptrdiff_t i,
                          simd::index::Unroll<U, W, Mask> j) const
    -> simd::Unroll<1, U, W, T> {
    return (*this)[simd::index::Unroll<1>{.index_ = i}, j];
  }
  template <std::ptrdiff_t R = 1>
  TRIVIAL static constexpr void checkinds(std::ptrdiff_t i, std::ptrdiff_t j) {
    invariant(i >= 0);
    invariant(i + (R - 1) < M);
    invariant(j >= 0);
    invariant(j < N);
    invariant((j % W) == 0);
  }
  template <std::ptrdiff_t R, std::ptrdiff_t C, typename Mask>
  TRIVIAL [[gnu::flatten]] auto
  operator[](simd::index::Unroll<R> i, simd::index::Unroll<C, W, Mask> j) const
    -> simd::Unroll<R, C, W, T> {
    checkinds<R>(i.index_, j.index_);
    simd::Unroll<R, C, W, T> ret;
    std::ptrdiff_t k = j.index_ / W;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r) {
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < C; ++u)
        ret[r, u] = memory_[(i.index_ + r) * L + k + u];
    }
    return ret;
  }
  template <class R, class C>
  TRIVIAL [[gnu::flatten]] constexpr auto operator[](R r, C c) noexcept
    -> decltype(auto) {
    if constexpr (std::integral<R> && std::integral<C>)
      return reinterpret_cast<T *>(memory_ + std::ptrdiff_t(r) * L)[c];
    else return index<T>(data(), S{}, r, c);
  }
  template <class R, class C>
  TRIVIAL [[gnu::flatten]] constexpr auto operator[](R r, C c) const noexcept
    -> decltype(auto) {
    if constexpr (std::integral<R> && std::integral<C>)
      return reinterpret_cast<const T *>(memory_ + std::ptrdiff_t(r) * L)[c];
    else return index<T>(data(), S{}, r, c);
  }
  TRIVIAL constexpr void set(T x, std::ptrdiff_t r, std::ptrdiff_t c) {
    if constexpr (W == 1) {
      memory_[L * r + c] = x;
    } else {
      V v = memory_[L * r + c / W];
      using IT = std::conditional_t<sizeof(T) == 8, std::int64_t, std::int32_t>;
      v = simd::range<W, IT>() == simd::vbroadcast<W, IT>(c % W)
            ? simd::vbroadcast<W, T>(x)
            : v;
      // v[c % W] = x;
      memory_[L * r + c / W] = v;
    }
  }
  template <std::ptrdiff_t R, std::ptrdiff_t C> struct Ref {
    StaticArray *parent_;
    std::ptrdiff_t i_, j_;
    TRIVIAL constexpr auto operator=(simd::Unroll<R, C, W, T> x) -> Ref & {
      checkinds<R>(i_, j_);
      std::ptrdiff_t k = j_ / W;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t r = 0; r < R; ++r) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < C; ++u)
          parent_->memory_[(i_ + r) * L + k + u] = x[r, u];
      }
      return *this;
    }
    TRIVIAL constexpr auto operator=(simd::Vec<W, T> x) -> Ref & {
      checkinds<R>(i_, j_);
      std::ptrdiff_t k = j_ / W;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t r = 0; r < R; ++r) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < C; ++u)
          parent_->memory_[(i_ + r) * L + k + u] = x;
      }
      return *this;
    }
    TRIVIAL constexpr auto operator=(std::convertible_to<T> auto x) -> Ref & {
      *this = simd::Vec<W, T>{} + T(x);
      return *this;
    }
    TRIVIAL constexpr operator simd::Unroll<R, C, W, T>() {
      return (*const_cast<const StaticArray *>(
        parent_))[simd::index::Unroll<R>{i_}, simd::index::Unroll<C, W>{j_}];
    }
    TRIVIAL constexpr auto operator+=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<R, C, W, T>(*this) + x;
    }
    TRIVIAL constexpr auto operator-=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<R, C, W, T>(*this) - x;
    }
    TRIVIAL constexpr auto operator*=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<R, C, W, T>(*this) * x;
    }
    TRIVIAL constexpr auto operator/=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<R, C, W, T>(*this) / x;
    }
    TRIVIAL constexpr auto operator+(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) + x;
    }
    TRIVIAL constexpr auto operator-(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) - x;
    }
    TRIVIAL constexpr auto operator*(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) * x;
    }
    TRIVIAL constexpr auto operator/(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) / x;
    }
    TRIVIAL constexpr auto operator>(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) > x;
    }
    TRIVIAL constexpr auto operator<(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) < x;
    }
    TRIVIAL constexpr auto operator>=(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) >= x;
    }
    TRIVIAL constexpr auto operator<=(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) <= x;
    }
    TRIVIAL constexpr auto operator==(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) == x;
    }
    TRIVIAL constexpr auto operator!=(const auto &x) {
      return simd::Unroll<R, C, W, T>(*this) != x;
    }
  };
  template <std::ptrdiff_t U, typename Mask>
  TRIVIAL auto operator[](std::ptrdiff_t i, simd::index::Unroll<U, W, Mask> j)
    -> Ref<1, U> {
    return Ref<1, U>{this, i, j.index_};
  }
  template <std::ptrdiff_t R, std::ptrdiff_t C, typename Mask>
  TRIVIAL auto operator[](simd::index::Unroll<R> i,
                          simd::index::Unroll<C, W, Mask> j) -> Ref<R, C> {
    return Ref<R, C>{this, i.index_, j.index_};
  }
  TRIVIAL constexpr auto operator[](auto i) noexcept -> decltype(auto)
    requires((N == 1) || (M == 1)) {
    if constexpr (M == 1) return (*this)[0z, i];
    else return (*this)[i, 0z];
  }
  TRIVIAL constexpr auto operator[](auto i) const noexcept -> decltype(auto)
    requires((N == 1) || (M == 1)) {
    if constexpr (M == 1) return (*this)[0z, i];
    else return (*this)[i, 0z];
  }
  TRIVIAL constexpr auto operator==(const StaticArray &other) const -> bool {
    // masks return `true` if `any` are on
    for (std::ptrdiff_t i = 0z; i < M * L; ++i)
      if (simd::cmp::ne<W, T>(memory_[i], other.memory_[i]).any()) return false;
    return true;
  }
  template <std::size_t I>
  TRIVIAL [[nodiscard]] constexpr auto get() const -> T {
    return memory_[I / W][I % W];
  }
  DEBUGUSED void print() const requires(utils::ColumnPrintable<T>) {
    if constexpr (utils::Printable<T>) {
      if constexpr (MatrixDimension<S>) utils::printMatrix(data(), M, N, N);
      else utils::printVector(begin(), end());
      utils::flush();
    }
  }
  TRIVIAL [[nodiscard]] constexpr auto scale(std::int64_t x) const
    -> StaticArray requires(std::same_as<T, double>) {
    StaticArray ret;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < M * L; ++i)
      ret.memory_[i] = ::simd::scale(memory_[i], x);
    return ret;
  }
  TRIVIAL constexpr auto maximum() const -> T requires(can_flatten) {
    return simd().maximum();
  }
  TRIVIAL constexpr auto minimum() const -> T requires(can_flatten) {
    return simd().minimum();
  }
  TRIVIAL constexpr auto sum() const -> T requires(can_flatten) {
    return simd().sum();
  }
  TRIVIAL constexpr auto prod() const -> T requires(can_flatten) {
    return simd().prod();
  }
};

template <simd::SIMDSupported T, std::ptrdiff_t N>
requires((N > 1) && ((N + simd::VecLen<N, T> - 1) / simd::VecLen<N, T>) == 1)
struct MATH_GSL_OWNER StaticArray<T, 1, N, false>
  : ArrayOps<T, StaticDims<T, 1, N, false>, StaticArray<T, 1, N, false>>,
    Expr<T, StaticArray<T, 1, N, false>> {
  using Expr<T, StaticArray<T, 1, N, false>>::operator==;
  using Expr<T, StaticArray<T, 1, N, false>>::operator!=;
  using Expr<T, StaticArray<T, 1, N, false>>::operator<;
  using Expr<T, StaticArray<T, 1, N, false>>::operator>;
  using Expr<T, StaticArray<T, 1, N, false>>::operator<=;
  using Expr<T, StaticArray<T, 1, N, false>>::operator>=;
  // struct StaticArray<T, M, N, alignof(simd::Vec<simd::VecLen<N, T>, T>)>
  //   : ArrayOps<T, StaticDims<T, M, N, alignof(simd::Vec<simd::VecLen<N, T>,
  //   T>)>,
  //              StaticArray<T, M, N, alignof(simd::Vec<simd::VecLen<N, T>,
  //              T>)>> {

  using value_type = T;
  using reference = T &;
  using const_reference = const T &;
  using size_type = std::ptrdiff_t;
  using difference_type = std::ptrdiff_t;
  using iterator = T *;
  using const_iterator = const T *;
  using pointer = T *;
  using const_pointer = const T *;
  using concrete = std::true_type;

  static constexpr std::ptrdiff_t W = simd::VecLen<N, T>;

  using compressed_type = StaticArray<T, 1, N, W != N>;
  /// sometimes desirable because of alignment
  /// TODO: allow using unaligned SIMD elements
  using actually_compressed_type = StaticArray<T, 1, N, true>;
  static constexpr std::ptrdiff_t L = 1;
  static constexpr bool can_flatten = false; // already flat

  constexpr void compress(compressed_type *p) const { *p = *this; }
  constexpr void compress(actually_compressed_type *p) const requires(W == N) {
    *p = *this;
  }
  static constexpr auto decompress(const compressed_type *p) -> StaticArray {
    return StaticArray{*p};
  }
  static constexpr auto decompress(const actually_compressed_type *p)
    -> StaticArray requires(W == N) {
    return StaticArray{*p};
  }
  static constexpr std::ptrdiff_t Align = alignof(simd::Vec<W, T>);
  using S = Length<N>;
  TRIVIAL [[nodiscard]] static constexpr auto dim() noexcept -> S {
    return S{};
  }

  TRIVIAL [[nodiscard]] constexpr auto view() const -> StaticArray {
    return *this;
  }
  TRIVIAL [[nodiscard]] constexpr auto untransposed_view() const
    -> StaticArray {
    return *this;
  }
  // Maybe this should return `StaticArray&`?
  TRIVIAL [[nodiscard]] constexpr auto mview() noexcept
    -> MutArray<T, S, false> {
    return {data(), S{}};
  }

  using V = simd::Vec<W, T>;
  // simd::Vec<W, T> data[M][L];
  V data_{};
  // std::array<std::array<simd::Vec<W, T>, L>, M> data;
  // constexpr operator compressed_type() { return compressed_type{*this}; }
  TRIVIAL constexpr StaticArray() = default;
  TRIVIAL constexpr StaticArray(V v) : data_(v){};
  TRIVIAL constexpr StaticArray(StaticArray const &) = default;
  TRIVIAL constexpr StaticArray(StaticArray &&) noexcept = default;
  TRIVIAL constexpr explicit StaticArray(const std::initializer_list<T> &list) {
    if (list.size() == 1) {
      data_ = *list.begin();
      return;
    }
    invariant(list.size() <= W);
    for (std::size_t i = 0; i < list.size(); ++i)
      data_[i] = *(list.begin() + i);
  }
  TRIVIAL static constexpr auto fill(T val) -> StaticArray {
    return {simd::vbroadcast<W>(val)};
  }
  TRIVIAL [[nodiscard]] constexpr auto scale(std::int64_t x) const
    -> StaticArray requires(std::same_as<T, double>) {
    return {::simd::scale(data_, x)};
  }
  TRIVIAL constexpr auto data() -> T * { return reinterpret_cast<T *>(&data_); }
  TRIVIAL [[nodiscard]] constexpr auto data() const -> const T * {
    return reinterpret_cast<const T *>(&data_);
  }
  TRIVIAL constexpr auto begin() -> T * { return data(); }
  TRIVIAL constexpr auto end() -> T * { return data() + N; }
  TRIVIAL [[nodiscard]] constexpr auto begin() const -> const T * {
    return data();
  }
  TRIVIAL [[nodiscard]] constexpr auto end() const -> const T * {
    return data() + N;
  }
  TRIVIAL [[nodiscard]] constexpr auto simd() const
    -> simd::Unroll<1, 1, W, T> {
    return {data_};
  }
  [[nodiscard]] TRIVIAL constexpr auto split() const
    -> std::array<StaticArray<T, 1, N / 2, false>, 2>
    requires(W == 2 || W == 4 || W == 8 || W == 16) {
    auto s = ::simd::split(data_);
    return {StaticArray<T, 1, N / 2, false>{s[0]},
            StaticArray<T, 1, N / 2, false>{s[1]}};
  }
  [[nodiscard]] TRIVIAL constexpr auto cat(StaticArray b) const
    -> StaticArray<T, 1, N << 1, false> {
    static constexpr std::ptrdiff_t N2 = N << 1;
    static constexpr std::ptrdiff_t W2 = simd::VecLen<N2, T>;
    if constexpr (N2 <= W2) {
      // Result fits in single SIMD vector - use shufflevector
      if constexpr (W2 == 2) {
        return StaticArray<T, 1, N2, false>{
          simd::Vec<W2, T>{data_[0], b.data_[0]}};
      } else if constexpr (W2 == 4) {
        return StaticArray<T, 1, N2, false>{
          __builtin_shufflevector(data_, b.data_, 0, 1, 2, 3)};
      } else if constexpr (W2 == 8) {
        return StaticArray<T, 1, N2, false>{
          __builtin_shufflevector(data_, b.data_, 0, 1, 2, 3, 4, 5, 6, 7)};
      } else if constexpr (W2 == 16) {
        return StaticArray<T, 1, N2, false>{
          __builtin_shufflevector(data_, b.data_, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
                                  10, 11, 12, 13, 14, 15)};
      }
    } else {
      // Result needs multiple SIMD vectors
      StaticArray<T, 1, N2, false> ret;
      ret.memory_[0] = data_;
      ret.memory_[1] = b.data_;
      return ret;
    }
  }
  [[nodiscard]] TRIVIAL constexpr auto repElements4() const
    -> StaticArray<T, 1, 4 * N> {
    static constexpr std::ptrdiff_t native = simd::Width<T>;
    StaticArray<T, 1, 4 * N> ret;
    if constexpr (W == 2) {
      if constexpr (native == 2) {
        V a = simd::vbroadcast<2>(data_[0]), b = simd::vbroadcast<2>(data_[1]);
        ret.memory_[0] = a, ret.memory_[1] = a;
        ret.memory_[2] = b, ret.memory_[3] = b;
      } else if constexpr (native == 4) {
        V a = simd::vbroadcast<4>(data_[0]), b = simd::vbroadcast<4>(data_[1]);
        ret.memory_[0] = a, ret.memory_[1] = b;
      } else {
        return {__builtin_shufflevector(data_, data_, 0, 0, 0, 0, 1, 1, 1, 1)};
      }
    } else if constexpr (W == 4) {
      if constexpr (native == 4) {
        ret.memory_[0] = simd::vbroadcast<4>(data_[0]);
        ret.memory_[1] = simd::vbroadcast<4>(data_[1]);
        ret.memory_[2] = simd::vbroadcast<4>(data_[2]);
        ret.memory_[3] = simd::vbroadcast<4>(data_[3]);
      } else if constexpr (native == 8) {
        ret.memory_[0] =
          __builtin_shufflevector(data_, data_, 0, 0, 0, 0, 1, 1, 1, 1);
        ret.memory_[1] =
          __builtin_shufflevector(data_, data_, 2, 2, 2, 2, 3, 3, 3, 3);
      } else {
        return {__builtin_shufflevector(data_, data_, 0, 0, 0, 0, 1, 1, 1, 1, 2,
                                        2, 2, 2, 3, 3, 3, 3)};
      }
    } else {
      static_assert(W == 8);
      if constexpr (native == 8) {
        ret.memory_[0] =
          __builtin_shufflevector(data_, data_, 0, 0, 0, 0, 1, 1, 1, 1);
        ret.memory_[1] =
          __builtin_shufflevector(data_, data_, 2, 2, 2, 2, 3, 3, 3, 3);
        ret.memory_[2] =
          __builtin_shufflevector(data_, data_, 4, 4, 4, 4, 5, 5, 5, 5);
        ret.memory_[3] =
          __builtin_shufflevector(data_, data_, 6, 6, 6, 6, 7, 7, 7, 7);
      } else {
        static_assert(native == 16, "not supporting smaller types for now");
        ret.memory_[0] = __builtin_shufflevector(data_, data_, 0, 0, 0, 0, 1, 1,
                                                 1, 1, 2, 2, 2, 2, 3, 3, 3, 3);
        ret.memory_[1] = __builtin_shufflevector(data_, data_, 4, 4, 4, 4, 5, 5,
                                                 5, 5, 6, 6, 6, 6, 7, 7, 7, 7);
      }
    }
    return ret;
  }
  TRIVIAL constexpr auto maximum() const -> T requires(N == W) {
    return simd::reduce::max(data_);
  }
  TRIVIAL constexpr auto minimum() const -> T requires(N == W) {
    return simd::reduce::min(data_);
  }
  TRIVIAL constexpr auto sum() const -> T requires(N == W) {
    return simd::reduce::sum(data_);
  }
  TRIVIAL constexpr auto prod() const -> T requires(N == W) {
    return simd::reduce::prod(data_);
  }
  TRIVIAL constexpr auto findFirstEqIdx(T x) -> std::ptrdiff_t {
    auto mask = simd::cmp::eq(data_, simd::vbroadcast<W>(x));
    return mask.any() ? mask.onBegin() : -1;
  }
  TRIVIAL constexpr auto operator[](Range<std::ptrdiff_t, std::ptrdiff_t> r)
    -> MutPtrVector<T> {
    return {data() + r.b_, length(r.size())};
  }
  TRIVIAL constexpr auto
  operator[](Range<std::ptrdiff_t, std::ptrdiff_t> r) const -> PtrVector<T> {
    return {data() + r.b_, length(r.size())};
  }
  template <AbstractSimilar<S> V>
  TRIVIAL constexpr StaticArray(const V &b) noexcept {
    (*this) << b;
  }
  TRIVIAL constexpr StaticArray(simd::Unroll<1, 1, W, T> u) noexcept
    : data_{u.vec_} {}
  TRIVIAL constexpr explicit StaticArray(T x)
    : data_{simd::vbroadcast<W, T>(x)} {}
  TRIVIAL constexpr auto operator=(StaticArray const &)
    -> StaticArray & = default;
  TRIVIAL constexpr auto operator=(StaticArray &&) noexcept
    -> StaticArray & = default;
  TRIVIAL static constexpr auto numRow() -> Row<1> { return {}; }
  TRIVIAL static constexpr auto numCol() -> Col<N> { return {}; }
  TRIVIAL static constexpr auto safeRow() -> Row<1> { return {}; }
  TRIVIAL static constexpr auto safeCol() -> Col<W> { return {}; }
  TRIVIAL [[nodiscard]] constexpr auto t() const
    -> Transpose<T, Array<T, S, false>> {
    return {*this};
  }
  TRIVIAL [[nodiscard]] static constexpr auto rowStride() noexcept
    -> RowStride<W> {
    return {};
  }
  TRIVIAL [[nodiscard]] static constexpr auto size() noexcept
    -> std::integral_constant<std::ptrdiff_t, N> {
    return {};
  }
  TRIVIAL auto operator[](std::ptrdiff_t, std::ptrdiff_t j) -> T & {
    return data()[j];
  }
  TRIVIAL auto operator[](std::ptrdiff_t, std::ptrdiff_t j) const -> T {
    return data_[j];
  }
  TRIVIAL auto operator[](std::ptrdiff_t j) -> T & { return data()[j]; }
  TRIVIAL auto operator[](std::ptrdiff_t j) const -> T { return data_[j]; }
  template <typename Mask>
  TRIVIAL auto operator[](std::ptrdiff_t, simd::index::Unroll<1, W, Mask>) const
    -> simd::Unroll<1, 1, W, T> {
    return {data_};
  }
  template <std::ptrdiff_t R = 1>
  TRIVIAL static constexpr void checkinds(std::ptrdiff_t j) {
    invariant(j >= 0);
    invariant(j < N);
    invariant((j % W) == 0);
  }
  template <std::ptrdiff_t R, typename Mask>
  TRIVIAL auto operator[](simd::index::Unroll<R>,
                          simd::index::Unroll<1, W, Mask> j) const
    -> simd::Unroll<R, 1, W, T> {
    checkinds<R>(j.index_);
    simd::Unroll<R, 1, W, T> ret;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r) ret[r, 0] = data_;
    return ret;
  }
  struct Ref {
    StaticArray *parent_;
    TRIVIAL constexpr auto operator=(simd::Unroll<1, 1, W, T> x) -> Ref & {
      parent_->data_ = x.vec_;
      return *this;
    }
    TRIVIAL constexpr auto operator=(simd::Vec<W, T> x) -> Ref & {
      parent_->data_ = x;
      return *this;
    }
    TRIVIAL constexpr auto operator=(std::convertible_to<T> auto x) -> Ref & {
      *this = simd::vbroadcast<W, T>(x);
      return *this;
    }
    TRIVIAL constexpr operator simd::Unroll<1, 1, W, T>() {
      return {parent_->data_};
    }
    TRIVIAL constexpr auto operator+=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<1, 1, W, T>(*this) + x;
    }
    TRIVIAL constexpr auto operator-=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<1, 1, W, T>(*this) - x;
    }
    TRIVIAL constexpr auto operator*=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<1, 1, W, T>(*this) * x;
    }
    TRIVIAL constexpr auto operator/=(const auto &x) -> Ref & {
      return (*this) = simd::Unroll<1, 1, W, T>(*this) / x;
    }
    TRIVIAL constexpr auto operator+(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) + x;
    }
    TRIVIAL constexpr auto operator-(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) - x;
    }
    TRIVIAL constexpr auto operator*(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) * x;
    }
    TRIVIAL constexpr auto operator/(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) / x;
    }
    TRIVIAL constexpr auto operator>(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) > x;
    }
    TRIVIAL constexpr auto operator<(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) < x;
    }
    TRIVIAL constexpr auto operator>=(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) >= x;
    }
    TRIVIAL constexpr auto operator<=(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) <= x;
    }
    TRIVIAL constexpr auto operator==(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) == x;
    }
    TRIVIAL constexpr auto operator!=(const auto &x) {
      return simd::Unroll<1, 1, W, T>(*this) != x;
    }
  };
  template <std::ptrdiff_t U, typename Mask>
  TRIVIAL auto operator[](std::ptrdiff_t, simd::index::Unroll<1, W, Mask>)
    -> Ref {
    return Ref{this};
  }
  template <std::ptrdiff_t R, typename Mask>
  TRIVIAL auto operator[](simd::index::Unroll<R>,
                          simd::index::Unroll<1, W, Mask>) -> Ref {
    return Ref{this};
  }
  template <typename Mask>
  TRIVIAL constexpr auto operator[](simd::index::Unroll<1, W, Mask>)
    -> decltype(auto) {
    return Ref{this};
  }
  template <typename Mask>
  TRIVIAL constexpr auto operator[](simd::index::Unroll<1, W, Mask>) const
    -> simd::Unroll<1, 1, W, T> {
    return {data_};
  }
  TRIVIAL constexpr auto operator==(const StaticArray &other) const -> bool {
    return !simd::cmp::ne<W, T>(data_, other.data_).any();
  }
  template <std::size_t I>
  TRIVIAL [[nodiscard]] constexpr auto get() const -> T {
    return data_[I];
  }
  TRIVIAL constexpr void set(T x, std::ptrdiff_t r, std::ptrdiff_t c) {
    invariant(r == 0);
    invariant(c < N);
    if constexpr (W == 1) {
      data_ = x;
    } else {
      using IT = std::conditional_t<sizeof(T) == 8, std::int64_t, std::int32_t>;
      data_ = simd::range<W, IT>() == simd::vbroadcast<W, IT>(c % W)
                ? simd::vbroadcast<W, T>(x)
                : data_;
    }
  }
  template <typename SHAPE>
  TRIVIAL constexpr operator Array<T, SHAPE, false>() const
    requires(std::convertible_to<S, SHAPE>) {
    return {const_cast<T *>(data()), SHAPE(dim())};
  }
  template <typename SHAPE>
  TRIVIAL constexpr operator MutArray<T, SHAPE, false>()
    requires(std::convertible_to<S, SHAPE>) {
    return {data(), SHAPE(dim())};
  }

  DEBUGUSED void print() const requires(utils::ColumnPrintable<T>) {
    if constexpr (utils::Printable<T>) {
      utils::printVector(begin(), end());
      utils::flush();
    }
  }
};

template <class T, std::ptrdiff_t N, std::ptrdiff_t Compress = false>
using SVector = StaticArray<T, 1Z, N, Compress>;
template <class T, std::ptrdiff_t M, std::ptrdiff_t N,
          std::ptrdiff_t Compress = false>
using SMatrix = StaticArray<T, M, N, Compress>;
static_assert(
  std::same_as<Row<1>, decltype(SVector<std::int64_t, 3, true>::numRow())>);
static_assert(
  std::same_as<Row<1>, decltype(SVector<std::int64_t, 3>::numRow())>);
static_assert(
  std::same_as<Row<1>,
               decltype(numRows(std::declval<SVector<std::int64_t, 3>>()))>);

static_assert(RowVector<SVector<std::int64_t, 3>>);
static_assert(!ColVector<SVector<std::int64_t, 3>>);
static_assert(!RowVector<Transpose<std::int64_t, SVector<std::int64_t, 3>>>);
static_assert(ColVector<Transpose<std::int64_t, SVector<std::int64_t, 3>>>);
static_assert(RowVector<StaticArray<std::int64_t, 1, 4, false>>);
static_assert(RowVector<StaticArray<std::int64_t, 1, 4, true>>);
static_assert(RowVector<StaticArray<std::int64_t, 1, 3, false>>);
static_assert(RowVector<StaticArray<std::int64_t, 1, 3, true>>);

template <class T, std::ptrdiff_t M, std::ptrdiff_t N>
TRIVIAL constexpr auto view(const StaticArray<T, M, N> &x) {
  return x.view();
}

template <class T, class... U>
StaticArray(T, U...) -> StaticArray<T, 1, 1 + sizeof...(U)>;

static_assert(utils::Compressible<SVector<std::int64_t, 3>>);
static_assert(utils::Compressible<SVector<std::int64_t, 7>>);

} // namespace math

template <class T, std::ptrdiff_t N> // NOLINTNEXTLINE(cert-dcl58-cpp)
struct std::tuple_size<::math::SVector<T, N>>
  : std::integral_constant<std::ptrdiff_t, N> {};

template <std::size_t I, class T,
          std::ptrdiff_t N> // NOLINTNEXTLINE(cert-dcl58-cpp)
struct std::tuple_element<I, math::SVector<T, N>> {
  using type = T;
};
