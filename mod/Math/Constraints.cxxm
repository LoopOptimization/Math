module;
#include "Macros.hxx"
export module Constraints;
import ArrayConcepts;
import AxisTypes;
import BitSet;
import Comparisons;
import CorePrint;
import EmptyMatrix;
import GCD;
import GenericArrayConstructors;
import ManagedArray;
import NormalForm;
import std;

export namespace math {
void printConstraint(PtrVector<std::int64_t> a, std::ptrdiff_t numSyms,
                     bool inequality);
/// prints in current permutation order.
/// TODO: decide if we want to make AffineLoopNest a `SymbolicPolyhedra`
/// in which case, we have to remove `currentToOriginalPerm`,
/// which means either change printing, or move prints `<<` into
/// the derived classes.
void printConstraints(DensePtrMatrix<std::int64_t> A, bool inequality = true);

constexpr void eraseConstraintImpl(MutDensePtrMatrix<std::int64_t> A, Row<> i) {
  std::ptrdiff_t last_row = std::ptrdiff_t(A.numRow()) - 1;
  invariant(i <= last_row);
  if (last_row != i) A[i, _] << A[last_row, _];
}
constexpr void eraseConstraint(MutDensePtrMatrix<std::int64_t> &A, Row<> i) {
  eraseConstraintImpl(A, i);
  A.truncate(--auto{A.numRow()});
}
void eraseConstraintImpl(MutDensePtrMatrix<std::int64_t> A, std::ptrdiff_t _i,
                         std::ptrdiff_t _j);
constexpr void eraseConstraint(MutDensePtrMatrix<std::int64_t> &A,
                               std::ptrdiff_t i, std::ptrdiff_t j) {
  eraseConstraintImpl(A, i, j);
  A.truncate(row(std::ptrdiff_t(A.numRow()) - 2));
}

// C = [ I A
//       0 B ]
void slackEqualityConstraints(MutPtrMatrix<std::int64_t> C,
                              PtrMatrix<std::int64_t> A,
                              PtrMatrix<std::int64_t> B);
void slackEqualityConstraints(MutPtrMatrix<std::int64_t> C,
                              PtrMatrix<std::int64_t> A);
// counts how many negative and positive elements there are in row `i`.
// A row corresponds to a particular variable in `A'x <= b`.
TRIVIAL constexpr auto countNonZeroSign(DensePtrMatrix<std::int64_t> A,
                                        std::ptrdiff_t i)
  -> std::array<std::ptrdiff_t, 2> {
  std::ptrdiff_t num_neg = 0, num_pos = 0;
  Row num_row = A.numRow();
  for (std::ptrdiff_t j = 0; j < num_row; ++j) {
    std::int64_t Aij = A[j, i];
    num_neg += (Aij < 0);
    num_pos += (Aij > 0);
  }
  return {num_neg, num_pos};
}

/// x == 0 -> 0, x < 0 -> 1, x > 0 -> 2
TRIVIAL constexpr auto orderedCmp(auto x) -> std::ptrdiff_t {
  return (x < 0) | (2 * (x > 0));
}
/// returns three bitsets, indicating indices that are 0, negative, and positive
template <class T, VectorDimension S>
constexpr auto indsZeroNegPos(Array<T, S> a)
  -> std::array<containers::FixedSizeBitSet<1>, 3> {
  std::array<containers::FixedSizeBitSet<1>, 3> ret;
  for (std::ptrdiff_t j = 0; j < a.size(); ++j) ret[orderedCmp(a[j])].insert(j);
  return ret;
}
// 4*4 + 8*3 = 40
static_assert(sizeof(std::array<Vector<unsigned, 4>, 2>) == 80);

template <bool NonNegative>
auto fourierMotzkinCore(MutDensePtrMatrix<std::int64_t> B,
                        DensePtrMatrix<std::int64_t> A, std::ptrdiff_t v,
                        std::array<containers::BitSet64, 3> znp) -> Row<>;

// template <bool nonnegative>
// auto fouriermotzkin(alloc<std::int64_t> auto &alloc,
//                     denseptrmatrix<std::int64_t> a, std::ptrdiff_t v)
//   -> mutdenseptrmatrix<std::int64_t>;

// Explicit instantiation declarations
extern template auto
fourierMotzkinCore<true>(MutDensePtrMatrix<std::int64_t> B,
                         DensePtrMatrix<std::int64_t> A, std::ptrdiff_t v,
                         std::array<containers::BitSet64, 3> znp) -> Row<>;

extern template auto
fourierMotzkinCore<false>(MutDensePtrMatrix<std::int64_t> B,
                          DensePtrMatrix<std::int64_t> A, std::ptrdiff_t v,
                          std::array<containers::BitSet64, 3> znp) -> Row<>;

// extern template auto fourierMotzkin<true>(Alloc<std::int64_t> auto &alloc,
//                                    DensePtrMatrix<std::int64_t> A,
//                                    std::ptrdiff_t v)  ->
//                                    MutDensePtrMatrix<std::int64_t>;

// extern template auto fourierMotzkin<false>(Alloc<std::int64_t> auto &alloc,
//                                     DensePtrMatrix<std::int64_t> A,
//                                     std::ptrdiff_t v)  ->
//                                     MutDensePtrMatrix<std::int64_t>;

auto fourierMotzkinCore(MutDensePtrMatrix<std::int64_t> A, std::ptrdiff_t v,
                        std::array<std::ptrdiff_t, 2> negPos,
                        std::ptrdiff_t num_rows) -> Row<>;
void fourierMotzkinCore(DenseMatrix<std::int64_t> &A, std::ptrdiff_t v,
                        std::array<std::ptrdiff_t, 2> negPos);
void fourierMotzkin(DenseMatrix<std::int64_t> &A,
                    std::ptrdiff_t v); // non-negative Fourier-Motzki

/// Checks all rows, dropping those that are 0.
void removeZeroRows(MutDensePtrMatrix<std::int64_t> &A);

/// checks whether `r` is a copy of any preceding rows
/// NOTE: does not compare to any following rows
constexpr auto uniqueConstraint(DensePtrMatrix<std::int64_t> A, Row<> r)
  -> bool {
  for (Row i = r; i != 0;)
    if (A[--i, _] == A[r, _]) return false;
  return !allZero(A[r, _]);
}

/// A is an inequality matrix, A*x >= 0
/// B is an equality matrix, E*x == 0
/// Use the equality matrix B to remove redundant constraints
[[nodiscard]] auto removeRedundantRows(MutDensePtrMatrix<std::int64_t> A,
                                       MutDensePtrMatrix<std::int64_t> B)
  -> std::array<Row<>, 2>;

TRIVIAL constexpr void
dropEmptyConstraints(MutDensePtrMatrix<std::int64_t> &A) {
  for (Row c = A.numRow(); c != 0;)
    if (allZero(A[--c, _])) eraseConstraint(A, c);
}

TRIVIAL constexpr void deleteBounds(MutDensePtrMatrix<std::int64_t> &A,
                                    std::ptrdiff_t i) {
  for (Row j = A.numRow(); j != 0;)
    if (A[--j, i]) eraseConstraint(A, j);
}
} // namespace math
