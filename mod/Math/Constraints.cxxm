module;
#include "Macros.hxx"
export module Constraints;
import ArrayConcepts;
import AxisTypes;
import BitSet;
import Comparisons;
import CorePrint;
import EmptyMatrix;
import GCD;
import GenericArrayConstructors;
import ManagedArray;
import NormalForm;
import std;

export namespace math {
inline void printConstraint(PtrVector<std::int64_t> a, std::ptrdiff_t numSyms,
                            bool inequality) {
  std::ptrdiff_t num_var = a.size();
  bool has_printed = false, all_non_neg = allGEZero(a[_(numSyms, num_var)]);
  std::int64_t sign = all_non_neg ? 1 : -1;
  for (std::ptrdiff_t v = numSyms; v < num_var; ++v) {
    if (std::int64_t Acv = sign * a[v]) {
      if (has_printed) {
        if (Acv > 0) {
          utils::print(" + ");
        } else {
          utils::print(" - ");
          Acv *= -1;
        }
      }
      if (Acv != 1) {
        if (Acv == -1) utils::print("-");
        else utils::print(Acv);
      }
      utils::print("v_", v - numSyms);
      has_printed = true;
    }
  }
  if (!has_printed) utils::print('0');
  if (inequality) utils::print(all_non_neg ? " >= " : " <= ");
  else utils::print(" == ");
  utils::print(-sign * a[0]);
}
/// prints in current permutation order.
/// TODO: decide if we want to make AffineLoopNest a `SymbolicPolyhedra`
/// in which case, we have to remove `currentToOriginalPerm`,
/// which means either change printing, or move prints `<<` into
/// the derived classes.
void printConstraints(DensePtrMatrix<std::int64_t> A, bool inequality = true);

constexpr void eraseConstraintImpl(MutDensePtrMatrix<std::int64_t> A, Row<> i) {
  std::ptrdiff_t last_row = std::ptrdiff_t(A.numRow()) - 1;
  invariant(i <= last_row);
  if (last_row != i) A[i, _] << A[last_row, _];
}
constexpr void eraseConstraint(MutDensePtrMatrix<std::int64_t> &A, Row<> i) {
  eraseConstraintImpl(A, i);
  A.truncate(--auto{A.numRow()});
}
void eraseConstraintImpl(MutDensePtrMatrix<std::int64_t> A, std::ptrdiff_t _i,
                         std::ptrdiff_t _j);
constexpr void eraseConstraint(MutDensePtrMatrix<std::int64_t> &A,
                               std::ptrdiff_t i, std::ptrdiff_t j) {
  eraseConstraintImpl(A, i, j);
  A.truncate(row(std::ptrdiff_t(A.numRow()) - 2));
}

auto substituteEquality(DenseMatrix<std::int64_t> &E, std::ptrdiff_t i) -> bool;

constexpr auto substituteEquality(MutDensePtrMatrix<std::int64_t> &,
                                  EmptyMatrix<std::int64_t>, std::ptrdiff_t)
  -> bool {
  return false;
}

auto substituteEquality(MutDensePtrMatrix<std::int64_t> &A,
                        MutDensePtrMatrix<std::int64_t> &E, std::ptrdiff_t i)
  -> bool;

// C = [ I A
//       0 B ]
void slackEqualityConstraints(MutPtrMatrix<std::int64_t> C,
                              PtrMatrix<std::int64_t> A,
                              PtrMatrix<std::int64_t> B);
void slackEqualityConstraints(MutPtrMatrix<std::int64_t> C,
                              PtrMatrix<std::int64_t> A);
// counts how many negative and positive elements there are in row `i`.
// A row corresponds to a particular variable in `A'x <= b`.
constexpr auto countNonZeroSign(DensePtrMatrix<std::int64_t> A,
                                std::ptrdiff_t i)
  -> std::array<std::ptrdiff_t, 2> {
  std::ptrdiff_t num_neg = 0;
  std::ptrdiff_t num_pos = 0;
  Row num_row = A.numRow();
  for (std::ptrdiff_t j = 0; j < num_row; ++j) {
    std::int64_t Aij = A[j, i];
    num_neg += (Aij < 0);
    num_pos += (Aij > 0);
  }
  return {num_neg, num_pos};
}

/// x == 0 -> 0, x < 0 -> 1, x > 0 -> 2
constexpr auto orderedCmp(auto x) -> std::ptrdiff_t {
  return (x < 0) | (2 * (x > 0));
}
/// returns three bitsets, indicating indices that are 0, negative, and positive
template <class T, VectorDimension S>
constexpr auto indsZeroNegPos(Array<T, S> a)
  -> std::array<containers::FixedSizeBitSet<1>, 3> {
  std::array<containers::FixedSizeBitSet<1>, 3> ret;
  for (std::ptrdiff_t j = 0; j < a.size(); ++j) ret[orderedCmp(a[j])].insert(j);
  return ret;
}
// 4*4 + 8*3 = 40
static_assert(sizeof(std::array<Vector<unsigned, 4>, 2>) == 80);

template <bool NonNegative>
auto fourierMotzkinCore(MutDensePtrMatrix<std::int64_t> B,
                        DensePtrMatrix<std::int64_t> A, std::ptrdiff_t v,
                        std::array<containers::BitSet64, 3> znp) -> Row<>;

// template <bool nonnegative>
// auto fouriermotzkin(alloc<std::int64_t> auto &alloc,
//                     denseptrmatrix<std::int64_t> a, std::ptrdiff_t v)
//   -> mutdenseptrmatrix<std::int64_t>;

// Explicit instantiation declarations
extern template auto
fourierMotzkinCore<true>(MutDensePtrMatrix<std::int64_t> B,
                         DensePtrMatrix<std::int64_t> A, std::ptrdiff_t v,
                         std::array<containers::BitSet64, 3> znp) -> Row<>;

extern template auto
fourierMotzkinCore<false>(MutDensePtrMatrix<std::int64_t> B,
                          DensePtrMatrix<std::int64_t> A, std::ptrdiff_t v,
                          std::array<containers::BitSet64, 3> znp) -> Row<>;

// extern template auto fourierMotzkin<true>(Alloc<std::int64_t> auto &alloc,
//                                    DensePtrMatrix<std::int64_t> A,
//                                    std::ptrdiff_t v)  ->
//                                    MutDensePtrMatrix<std::int64_t>;

// extern template auto fourierMotzkin<false>(Alloc<std::int64_t> auto &alloc,
//                                     DensePtrMatrix<std::int64_t> A,
//                                     std::ptrdiff_t v)  ->
//                                     MutDensePtrMatrix<std::int64_t>;

void fourierMotzkinCore(DenseMatrix<std::int64_t> &A, std::ptrdiff_t v,
                        std::array<std::ptrdiff_t, 2> negPos);
void fourierMotzkin(DenseMatrix<std::int64_t> &A,
                    std::ptrdiff_t v); // non-negative Fourier-Motzki

/// Checks all rows, dropping those that are 0.
void removeZeroRows(MutDensePtrMatrix<std::int64_t> &A);

/// checks whether `r` is a copy of any preceding rows
/// NOTE: does not compare to any following rows
constexpr auto uniqueConstraint(DensePtrMatrix<std::int64_t> A, Row<> r)
  -> bool {
  for (Row i = r; i != 0;)
    if (A[--i, _] == A[r, _]) return false;
  return !allZero(A[r, _]);
}

/// A is an inequality matrix, A*x >= 0
/// B is an equality matrix, E*x == 0
/// Use the equality matrix B to remove redundant constraints
[[nodiscard]] auto removeRedundantRows(MutDensePtrMatrix<std::int64_t> A,
                                       MutDensePtrMatrix<std::int64_t> B)
  -> std::array<Row<>, 2>;

TRIVIAL constexpr void
dropEmptyConstraints(MutDensePtrMatrix<std::int64_t> &A) {
  for (Row c = A.numRow(); c != 0;)
    if (allZero(A[--c, _])) eraseConstraint(A, c);
}

TRIVIAL constexpr auto countSigns(DensePtrMatrix<std::int64_t> A,
                                  std::ptrdiff_t i)
  -> std::array<std::ptrdiff_t, 2> {
  std::ptrdiff_t num_neg = 0;
  std::ptrdiff_t num_pos = 0;
  for (std::ptrdiff_t j = 0; j < A.numRow(); ++j) {
    std::int64_t Aij = A[j, i];
    num_neg += (Aij < 0);
    num_pos += (Aij > 0);
  }
  return {num_neg, num_pos};
}

TRIVIAL constexpr void deleteBounds(MutDensePtrMatrix<std::int64_t> &A,
                                    std::ptrdiff_t i) {
  for (Row j = A.numRow(); j != 0;)
    if (A[--j, i]) eraseConstraint(A, j);
}
} // namespace math
