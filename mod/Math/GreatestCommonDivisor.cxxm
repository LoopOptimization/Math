module;
#include "LoopMacros.hxx"
#include "Macros.hxx"
export module GCD;

import BaseUtils;
import SIMD;
import std;
export namespace math {
using utils::invariant;
TRIVIAL constexpr auto constexpr_abs(std::signed_integral auto x) noexcept {
  return x < 0 ? -x : x;
}
TRIVIAL constexpr auto constexpr_abs(std::unsigned_integral auto x) noexcept {
  return x;
}
template <std::ptrdiff_t W, std::integral T>
TRIVIAL constexpr auto constexpr_abs(simd::Vec<W, T> x) noexcept {
  if constexpr (std::signed_integral<T>) return x < 0 ? -x : x;
  else return x;
}
template <std::ptrdiff_t W, std::floating_point T>
TRIVIAL constexpr auto constexpr_abs(simd::Vec<W, T> x) noexcept {
  return x < 0 ? -x : x;
}
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, typename T>
requires((R * C) != 1)
TRIVIAL constexpr auto constexpr_abs(simd::Unroll<R, C, N, T> x) noexcept {
  simd::Unroll<R, C, N, T> result;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t i = 0; i < R * C; ++i)
    result.data_[i] = constexpr_abs<N>(x.data_[i]);
  return result;
}
template <std::ptrdiff_t N, typename T>
TRIVIAL constexpr auto constexpr_abs(simd::Unroll<1, 1, N, T> x) noexcept {
  return simd::Unroll<1, 1, N, T>{constexpr_abs<N>(x.vec_)};
}

template <std::integral T> TRIVIAL constexpr auto gcd(T x, T y) -> T {
  invariant(x != std::numeric_limits<T>::min());
  invariant(y != std::numeric_limits<T>::min());
  if (x == 0) return constexpr_abs(y);
  if (y == 0) return constexpr_abs(x);
  T a = constexpr_abs(x), b = constexpr_abs(y);
  if ((a == 1) | (b == 1)) return 1;
  using UT = std::make_unsigned_t<T>;
  T az = std::countr_zero(UT(x)), bz = std::countr_zero(UT(y));
  b >>= bz;
  T k = std::min(az, bz);
  for (;;) {
    a >>= az;
    T d = a - b;
    az = std::countr_zero(UT(d));
    b = std::min(a, b);
    if (!d) break;
    a = constexpr_abs(d);
  }
  return b << k;
}
// TODO: add `Unroll` method, use in vectorized GCD?
template <std::ptrdiff_t W, std::integral I>
TRIVIAL constexpr auto gcd(simd::Vec<W, I> x, simd::Vec<W, I> y)
  -> simd::Vec<W, I> {
  static_assert(W * sizeof(I) >= 16);
  static constexpr simd::Vec<W, I> zero = {};
  static constexpr simd::Vec<W, I> one = zero + 1;
  static constexpr simd::Vec<W, I> invalid =
    zero + std::numeric_limits<I>::min();

  invariant(!(simd::cmp::eq<W, I>(x, invalid)).any());
  invariant(!(simd::cmp::eq<W, I>(y, invalid)).any());
  // Mask shift amounts to avoid UB when crz returns bit_width (for zero input)
  static constexpr I shift_mask = I(8 * sizeof(I) - 1);
  simd::Vec<W, I> b = constexpr_abs<W, I>(y), a = constexpr_abs<W, I>(x),
                  bz = simd::crz<W, I>(y) & shift_mask,
                  az = simd::crz<W, I>(x) & shift_mask;
  auto on = ((a > 1) & (b > 1));
  simd::Vec<W, I> offb = (x == 0 ? b : (y == 0 ? a : one));
  if (!(simd::cmp::ne<W>(on, {})).any()) return offb;
  b = on ? (b >> bz) : offb;
  simd::Vec<W, I> k = on ? (az > bz ? bz : az) : zero;
  for (;;) {
    a >>= az;
    simd::Vec<W, I> d = a - b;
    az = simd::crz<W, I>(d) & shift_mask;
    b = (on & (a <= b)) ? a : b;
    on = on ? (d != zero) : on;
    if (!(simd::cmp::ne<W>(on, {})).any()) break;
    a = constexpr_abs<W, I>(d);
  }
  return b << k;
}
template <>
TRIVIAL constexpr auto gcd<1, std::int64_t>(simd::Vec<1, std::int64_t> x,
                                            simd::Vec<1, std::int64_t> y)
  -> simd::Vec<1, std::int64_t> {
  return gcd(x[0], y[0]);
}
template <>
TRIVIAL constexpr auto gcd<1, std::int32_t>(simd::Vec<1, std::int32_t> x,
                                            simd::Vec<1, std::int32_t> y)
  -> simd::Vec<1, std::int32_t> {
  return gcd(x[0], y[0]);
}

template <std::ptrdiff_t W, std::integral I>
TRIVIAL constexpr auto gcdreduce(simd::Vec<W, I> v) -> I {
  if constexpr (W != 2) {
    auto [a, b] = ::simd::split(v);
    if constexpr (W * sizeof(I) >= 32) {
      return gcdreduce<W / 2>(gcd<W / 2>(a, b));
    } else {
      static_assert(W == 4 && sizeof(I) == 4);
      static constexpr ::simd::Vec<2, I> zero{};
      ::simd::Vec<4, I> ap = __builtin_shufflevector(a, zero, 0, 1, 2, 3),
                        bp = __builtin_shufflevector(b, zero, 0, 1, 2, 3),
                        g = gcd<4>(ap, bp);
      return gcd(g[0], g[1]);
    }
  } else return gcd(v[0], v[1]);
}
template <>
TRIVIAL constexpr auto gcdreduce<1, std::int64_t>(simd::Vec<1, std::int64_t> v)
  -> std::int64_t {
  return v[0];
}
template <>
TRIVIAL constexpr auto gcdreduce<1, std::int32_t>(simd::Vec<1, std::int32_t> v)
  -> std::int32_t {
  return v[0];
}

// GCD for Unroll types
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, std::integral I>
requires((R * C) != 1) TRIVIAL constexpr auto gcd(simd::Unroll<R, C, N, I> x,
                                                  simd::Unroll<R, C, N, I> y)
  -> simd::Unroll<R, C, N, I> {
  simd::Unroll<R, C, N, I> result;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t i = 0; i < R * C; ++i)
    result.data_[i] = gcd<N>(x.data_[i], y.data_[i]);
  return result;
}

// GCD for Unroll<1, 1, N, int64_t> specialization (single vector)
template <std::ptrdiff_t N, std::integral I>
TRIVIAL constexpr auto gcd(simd::Unroll<1, 1, N, I> x,
                           simd::Unroll<1, 1, N, I> y)
  -> simd::Unroll<1, 1, N, I> {
  return simd::Unroll<1, 1, N, I>{gcd<N>(x.vec_, y.vec_)};
}

// gcdreduce for Unroll types
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, std::integral I>
requires((R * C) != 1)
TRIVIAL constexpr auto gcdreduce(simd::Unroll<R, C, N, I> v) -> I {
  // First reduce all Vecs to a single Vec using vector GCD
  ::simd::Vec<N, I> result = v.data_[0];
  for (std::ptrdiff_t i = 1; i < R * C; ++i)
    result = gcd<N>(result, v.data_[i]);
  // Then reduce the final Vec to a scalar
  return gcdreduce<N>(result);
}

// gcdreduce for Unroll<1, 1, N, int64_t> specialization
template <std::ptrdiff_t N>
TRIVIAL constexpr auto gcdreduce(simd::Unroll<1, 1, N, std::int64_t> v)
  -> std::int64_t {
  return gcdreduce<N>(v.vec_);
}

// gcdreduce for Unroll types (int32_t)
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N>
requires((R * C) != 1)
TRIVIAL constexpr auto gcdreduce(simd::Unroll<R, C, N, std::int32_t> v)
  -> std::int32_t {
  using VT = decltype(v.data_[0]);
  VT result = v.data_[0];
  for (std::ptrdiff_t i = 1; i < R * C; ++i)
    result = gcd<N>(result, v.data_[i]);
  return gcdreduce<N>(result);
}

// gcdreduce for Unroll<1, 1, N, int32_t> specialization
template <std::ptrdiff_t N>
TRIVIAL constexpr auto gcdreduce(simd::Unroll<1, 1, N, std::int32_t> v)
  -> std::int32_t {
  return gcdreduce<N>(v.vec_);
}

// GCD for Unroll types (float - assumes integer-valued inputs)
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N,
          std::floating_point F>
TRIVIAL constexpr auto gcd(simd::Unroll<R, C, N, F> x,
                           simd::Unroll<R, C, N, F> y) {
  using I = std::conditional_t<sizeof(F) == 4, std::int32_t, std::int64_t>;
  // Convert to int32, compute GCD, convert back
  simd::Unroll<R, C, N, I> xi = x, yi = y;
  return gcd(xi, yi);
}

template <std::integral I> TRIVIAL constexpr auto lcm(I x, I y) -> I {
  I ax = constexpr_abs(x), ay = constexpr_abs(y);
  if (ax == 1) return ay;
  if (ay == 1 || ay == ax) return ax;
  return ax * (ay / gcd(ax, ay));
}
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, std::integral T>
TRIVIAL constexpr auto lcm(simd::Unroll<R, C, N, T> x,
                           simd::Unroll<R, C, N, T> y) {
  auto ax = constexpr_abs(x), ay = constexpr_abs(y);
  return ax * (ay / gcd(ax, ay));
}

template <std::integral I> TRIVIAL constexpr auto copySign(I x, I s) -> I {
  if (s >= 0) return constexpr_abs(x);
  return -constexpr_abs(x);
}
template <std::ptrdiff_t W, std::integral I>
TRIVIAL constexpr auto copySign(simd::Vec<W, I> x, simd::Vec<W, I> s)
  -> simd::Vec<W, I> {
  x = __builtin_elementwise_abs(x);
  return s >= 0 ? x : -x;
}
template <std::ptrdiff_t W, std::floating_point I>
TRIVIAL constexpr auto copySign(simd::Vec<W, I> x, simd::Vec<W, I> s)
  -> simd::Vec<W, I> {
  return __builtin_elementwise_copysign(x, s);
}

// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
template <std::integral T>
TRIVIAL constexpr auto dgcdx(T a, T b) -> std::array<T, 5> {
  if (a == b) return {a, 0, 1, 1, 1};
  bool swap = a < b; // swapping can shave off an iteration
  T r_old = swap ? b : a, r = swap ? a : b;
  T s_old = 1, s = 0;
  T t_old = 0, t = 1;
  while (r) {
    T quotient = r_old / r, r_next = r_old - (quotient * r),
      s_next = s_old - (quotient * s), t_next = t_old - (quotient * t);
    r_old = r, s_old = s, t_old = t;
    r = r_next, s = s_next, t = t_next;
  }
  // Solving for `t` at the end has 1 extra division, but lets us remove
  // the `t` updates in the loop:
  // T t = (b == 0) ? 0 : ((old_r - old_s * a) / b);
  // For now, I'll favor forgoing the division.
  return {r_old, swap ? t_old : s_old, swap ? s_old : t_old,
          copySign(swap ? s : t, a), copySign(swap ? t : s, b)};
}
template <std::ptrdiff_t W, typename T>
TRIVIAL constexpr auto dgcdx(simd::Vec<W, T> a, simd::Vec<W, T> b)
  -> std::array<simd::Vec<W, T>, 5> {
  auto swap = a < b;
  simd::Vec<W, T> r_old = swap ? b : a, r = swap ? a : b;
  static constexpr simd::Vec<W, T> one = simd::vbroadcast<W, T>(1);
  static constexpr simd::Vec<W, T> zero = simd::vbroadcast<W, T>(0);
  simd::Vec<W, T> s_old = one, s = zero;
  simd::Vec<W, T> t_old = zero, t = one;
  auto m = r != zero;
  while (m.any()) {
    simd::Vec<W, T> quotient = r_old / r;
    if constexpr (std::floating_point<T>) quotient = trunc(quotient);
    simd::Vec<W, T> r_next = r_old - (quotient * r),
                    s_next = s_old - (quotient * s),
                    t_next = t_old - (quotient * t);
    r_old = r, s_old = s, t_old = t;
    r = m.select(r_next, r), s = m.select(s_next, s), t = m.select(t_next, t);
    m = simd::cmp::ne(r, zero);
  }
  // Solving for `t` at the end has 1 extra division, but lets us remove
  // the `t` updates in the loop:
  // T t = (b == 0) ? 0 : ((old_r - old_s * a) / b);
  // For now, I'll favor forgoing the division.
  return {r_old, swap ? t_old : s_old, swap ? s_old : t_old,
          copySign(swap ? s : t, a), copySign(swap ? t : s, b)};
}
/// [g, x, y] = gcdx(a, b)
/// a*x + b*y == g
template <std::integral T>
TRIVIAL constexpr auto gcdx(T a, T b) -> std::array<T, 3> {
  auto [g, x, y, t, s] = dgcdx(a, b);
  return {g, x, y};
}

/// divgcd(x, y) = (x / gcd(x, y), y / gcd(x, y))
TRIVIAL constexpr auto divgcd(std::int64_t a, std::int64_t b)
  -> std::array<std::int64_t, 2> {
  auto [g, x, y, t, s] = dgcdx(a, b);
  return {t, s};
}
template <std::ptrdiff_t W, std::floating_point T>
TRIVIAL constexpr auto lcm(simd::Vec<W, T> a, simd::Vec<W, T> b)
  -> simd::Vec<W, T> {
  a = __builtin_elementwise_abs(a);
  b = __builtin_elementwise_abs(b);
  simd::Vec<W, T> r_old = __builtin_elementwise_max(a, b),
                  r = __builtin_elementwise_min(a, b), maxval = r_old;
  static constexpr simd::Vec<W, T> one = simd::vbroadcast<W, T>(1);
  static constexpr simd::Vec<W, T> zero = simd::vbroadcast<W, T>(0);
  simd::Vec<W, T> s_old = one, s = zero;
  auto m = simd::cmp::ne(r, zero);
  while (m.any()) {
    simd::Vec<W, T> quotient = simd::trunc(r_old / r),
                    r_next = r_old - (quotient * r),
                    s_next = s_old - (quotient * s);
    r_old = r, s_old = s;
    r = m.select(r_next, r), s = m.select(s_next, s);
    m = simd::cmp::ne(r, zero);
  }
  // if b was negative
  // s is based on min
  return __builtin_elementwise_abs(maxval * s);
}

template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N,
          std::floating_point T>
TRIVIAL constexpr auto lcm(simd::Unroll<R, C, N, T> x,
                           simd::Unroll<R, C, N, T> y)
  -> simd::Unroll<R, C, N, T> {
  if constexpr (R * C != 1) {
    simd::Unroll<R, C, N, T> ret;
#pragma clang loop unroll(full)
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      ret.data_[i] = lcm(x.data_[i], y.data_[i]);
    return ret;

  } else return {lcm(x.vec_, y.vec_)};
}

} // namespace math
