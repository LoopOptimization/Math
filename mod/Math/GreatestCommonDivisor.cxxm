module;
#include "LoopMacros.hxx"
#include "Macros.hxx"
export module GCD;

import BaseUtils;
import SIMD;
import std;
export namespace math {
using utils::invariant;
TRIVIAL constexpr auto constexpr_abs(std::signed_integral auto x) noexcept {
  return x < 0 ? -x : x;
}
TRIVIAL constexpr auto constexpr_abs(std::unsigned_integral auto x) noexcept {
  return x;
}
template <std::ptrdiff_t W, std::integral T>
TRIVIAL constexpr auto constexpr_abs(simd::Vec<W, T> x) noexcept {
  if constexpr (std::signed_integral<T>) return x < 0 ? -x : x;
  else return x;
}
template <std::ptrdiff_t W, std::floating_point T>
TRIVIAL constexpr auto constexpr_abs(simd::Vec<W, T> x) noexcept {
  return x < 0 ? -x : x;
}
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, typename T>
requires((R * C) != 1)
TRIVIAL constexpr auto constexpr_abs(simd::Unroll<R, C, N, T> x) noexcept {
  simd::Unroll<R, C, N, T> result;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t i = 0; i < R * C; ++i)
    result.data_[i] = constexpr_abs<N>(x.data_[i]);
  return result;
}
template <std::ptrdiff_t N, typename T>
TRIVIAL constexpr auto constexpr_abs(simd::Unroll<1, 1, N, T> x) noexcept {
  return simd::Unroll<1, 1, N, T>{constexpr_abs<N>(x.vec_)};
}

template <std::integral T> TRIVIAL constexpr auto gcd(T x, T y) -> T {
  invariant(x != std::numeric_limits<T>::min());
  invariant(y != std::numeric_limits<T>::min());
  if (x == 0) return constexpr_abs(y);
  if (y == 0) return constexpr_abs(x);
  T a = constexpr_abs(x), b = constexpr_abs(y);
  if ((a == 1) | (b == 1)) return 1;
  using UT = std::make_unsigned_t<T>;
  T az = std::countr_zero(UT(x)), bz = std::countr_zero(UT(y));
  b >>= bz;
  T k = std::min(az, bz);
  for (;;) {
    a >>= az;
    T d = a - b;
    az = std::countr_zero(UT(d));
    b = std::min(a, b);
    if (!d) break;
    a = constexpr_abs(d);
  }
  return b << k;
}
// TODO: add `Unroll` method, use in vectorized GCD?
template <std::ptrdiff_t W, std::integral I>
TRIVIAL constexpr auto gcd(simd::Vec<W, I> x, simd::Vec<W, I> y)
  -> simd::Vec<W, I> {
  static_assert(W * sizeof(I) >= 16);
  static constexpr simd::Vec<W, I> zero = {};
  static constexpr simd::Vec<W, I> one = zero + 1;
  static constexpr simd::Vec<W, I> invalid =
    zero + std::numeric_limits<I>::min();

  invariant(!(simd::cmp::eq<W, I>(x, invalid)).any());
  invariant(!(simd::cmp::eq<W, I>(y, invalid)).any());
  simd::Vec<W, I> b = constexpr_abs<W, I>(y), a = constexpr_abs<W, I>(x),
                  bz = simd::crz<W, I>(y), az = simd::crz<W, I>(x);
  auto on = ((a > 1) & (b > 1));
  simd::Vec<W, I> offb = (x == 0 ? b : (y == 0 ? a : one));
  if (!(simd::cmp::ne<W>(on, {})).any()) return offb;
  b = on ? (b >> bz) : offb;
  simd::Vec<W, I> k = on ? (az > bz ? bz : az) : zero;
  for (;;) {
    a >>= az;
    simd::Vec<W, I> d = a - b;
    az = simd::crz<W, I>(d);
    b = (on & (a <= b)) ? a : b;
    on = on ? (d != zero) : on;
    if (!(simd::cmp::ne<W>(on, {})).any()) break;
    a = constexpr_abs<W, I>(d);
  }
  return b << k;
}
template <>
TRIVIAL constexpr auto gcd<1, std::int64_t>(simd::Vec<1, std::int64_t> x,
                                            simd::Vec<1, std::int64_t> y)
  -> simd::Vec<1, std::int64_t> {
  return gcd(x[0], y[0]);
}
template <>
TRIVIAL constexpr auto gcd<1, std::int32_t>(simd::Vec<1, std::int32_t> x,
                                            simd::Vec<1, std::int32_t> y)
  -> simd::Vec<1, std::int32_t> {
  return gcd(x[0], y[0]);
}

template <std::ptrdiff_t W, std::integral I>
TRIVIAL constexpr auto gcdreduce(simd::Vec<W, I> v) -> I {
  if constexpr (W != 2) {
    auto [a, b] = ::simd::split(v);
    if constexpr (W * sizeof(I) >= 32) {
      return gcdreduce<W / 2>(gcd<W / 2>(a, b));
    } else {
      static_assert(W == 4 && sizeof(I) == 4);
      static constexpr ::simd::Vec<2, I> zero{};
      ::simd::Vec<4, I> ap = __builtin_shufflevector(a, zero, 0, 1, 2, 3),
                        bp = __builtin_shufflevector(b, zero, 0, 1, 2, 3),
                        g = gcd<4>(ap, bp);
      return gcd(g[0], g[1]);
    }
  } else return gcd(v[0], v[1]);
}
template <>
constexpr auto gcdreduce<1, std::int64_t>(simd::Vec<1, std::int64_t> v)
  -> std::int64_t {
  return v[0];
}
template <>
constexpr auto gcdreduce<1, std::int32_t>(simd::Vec<1, std::int32_t> v)
  -> std::int32_t {
  return v[0];
}

// GCD for Unroll types (int64_t)
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N>
requires((R * C) != 1)
TRIVIAL constexpr auto gcd(simd::Unroll<R, C, N, std::int64_t> x,
                           simd::Unroll<R, C, N, std::int64_t> y)
  -> simd::Unroll<R, C, N, std::int64_t> {
  simd::Unroll<R, C, N, std::int64_t> result;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t i = 0; i < R * C; ++i)
    result.data_[i] = gcd<N>(x.data_[i], y.data_[i]);
  return result;
}

// GCD for Unroll<1, 1, N, int64_t> specialization (single vector)
template <std::ptrdiff_t N>
TRIVIAL constexpr auto gcd(simd::Unroll<1, 1, N, std::int64_t> x,
                           simd::Unroll<1, 1, N, std::int64_t> y)
  -> simd::Unroll<1, 1, N, std::int64_t> {
  return simd::Unroll<1, 1, N, std::int64_t>{gcd<N>(x.vec_, y.vec_)};
}

// GCD for Unroll types (int32_t)
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N>
requires((R * C) != 1)
TRIVIAL constexpr auto gcd(simd::Unroll<R, C, N, std::int32_t> x,
                           simd::Unroll<R, C, N, std::int32_t> y)
  -> simd::Unroll<R, C, N, std::int32_t> {
  simd::Unroll<R, C, N, std::int32_t> result;
  for (std::ptrdiff_t i = 0; i < R * C; ++i)
    result.data_[i] = gcd<N>(x.data_[i], y.data_[i]);
  return result;
}

// GCD for Unroll<1, 1, N, int32_t> specialization (single vector)
template <std::ptrdiff_t N>
TRIVIAL constexpr auto gcd(simd::Unroll<1, 1, N, std::int32_t> x,
                           simd::Unroll<1, 1, N, std::int32_t> y)
  -> simd::Unroll<1, 1, N, std::int32_t> {
  return simd::Unroll<1, 1, N, std::int32_t>{gcd<N>(x.vec_, y.vec_)};
}

// gcdreduce for Unroll types (int64_t)
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, std::integral I>
requires((R * C) != 1)
TRIVIAL constexpr auto gcdreduce(simd::Unroll<R, C, N, I> v) -> I {
  // First reduce all Vecs to a single Vec using vector GCD
  ::simd::Vec<N, I> result = v.data_[0];
  for (std::ptrdiff_t i = 1; i < R * C; ++i)
    result = gcd<N>(result, v.data_[i]);
  // Then reduce the final Vec to a scalar
  return gcdreduce<N>(result);
}

// gcdreduce for Unroll<1, 1, N, int64_t> specialization
template <std::ptrdiff_t N>
TRIVIAL constexpr auto gcdreduce(simd::Unroll<1, 1, N, std::int64_t> v)
  -> std::int64_t {
  return gcdreduce<N>(v.vec_);
}

// gcdreduce for Unroll types (int32_t)
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N>
requires((R * C) != 1)
TRIVIAL constexpr auto gcdreduce(simd::Unroll<R, C, N, std::int32_t> v)
  -> std::int32_t {
  using VT = decltype(v.data_[0]);
  VT result = v.data_[0];
  for (std::ptrdiff_t i = 1; i < R * C; ++i)
    result = gcd<N>(result, v.data_[i]);
  return gcdreduce<N>(result);
}

// gcdreduce for Unroll<1, 1, N, int32_t> specialization
template <std::ptrdiff_t N>
TRIVIAL constexpr auto gcdreduce(simd::Unroll<1, 1, N, std::int32_t> v)
  -> std::int32_t {
  return gcdreduce<N>(v.vec_);
}

// GCD for Unroll types (float - assumes integer-valued inputs)
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N,
          std::floating_point F>
TRIVIAL constexpr auto gcd(simd::Unroll<R, C, N, F> x,
                           simd::Unroll<R, C, N, F> y) {
  using I = std::conditional_t<sizeof(F) == 4, std::int32_t, std::int64_t>;
  // Convert to int32, compute GCD, convert back
  simd::Unroll<R, C, N, I> xi = x, yi = y;
  return gcd(xi, yi);
}

template <std::integral I> TRIVIAL constexpr auto lcm(I x, I y) -> I {
  I ax = constexpr_abs(x), ay = constexpr_abs(y);
  if (ax == 1) return ay;
  if (ay == 1 || ay == ax) return ax;
  return ax * (ay / gcd(ax, ay));
}
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, typename T>
TRIVIAL constexpr auto lcm(simd::Unroll<R, C, N, T> x,
                           simd::Unroll<R, C, N, T> y) {
  auto ax = constexpr_abs(x), ay = constexpr_abs(y);
  return ax * (ay / gcd(ax, ay));
}

// NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
template <std::integral I> TRIVIAL constexpr auto copySign(I x, I s) -> I {
  if (s >= 0) return constexpr_abs(x);
  return -constexpr_abs(x);
}

// https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
template <std::integral T>
TRIVIAL constexpr auto dgcdx(T a, T b)
  -> std::array<T, 5> { // NOLINT(bugprone-easily-swappable-parameters)
  T r_old = a, r = b;
  T s_old = 1, s = 0;
  T t_old = 0, t = 1;
  while (r) {
    T quotient = r_old / r, r_next = r_old - (quotient * r),
      s_next = s_old - (quotient * s), t_next = t_old - (quotient * t);
    r_old = r, s_old = s, t_old = t;
    r = r_next, s = s_next, t = t_next;
  }
  // Solving for `t` at the end has 1 extra division, but lets us remove
  // the `t` updates in the loop:
  // T t = (b == 0) ? 0 : ((old_r - old_s * a) / b);
  // For now, I'll favor forgoing the division.
  return {r_old, s_old, t_old, copySign(t, a), copySign(s, b)};
}
template <
  std::integral T> // NOLINTNEXTLINE(bugprone-easily-swappable-parameters)
TRIVIAL constexpr auto gcdx(T a, T b) -> std::array<T, 3> {
  auto [g, x, y, t, s] = dgcdx(a, b);
  return {g, x, y};
}

/// divgcd(x, y) = (x / gcd(x, y), y / gcd(x, y))
TRIVIAL constexpr auto divgcd(std::int64_t a, std::int64_t b)
  -> std::array<std::int64_t, 2> {
  auto [g, x, y, t, s] = dgcdx(a, b);
  return {t, s};
}

} // namespace math
