module;
#include "LoopMacros.hxx"
#include "Macros.hxx"

export module Dual;

export import Elementary;
import Arena;
import Array;
import ArrayConcepts;
import ArrayConstructors;
import AxisTypes;
import BaseUtils;
import CompressReference;
import CorePrint;
import ExprTemplates;
import ExprTemplateUtils;
import MatDim;
import SIMD;
import StaticArray;
import std;
import Tuple;
export namespace math {

template <class T, std::ptrdiff_t N, bool Compress = false> struct Dual {
  static_assert(Compress);
  using CT = utils::compressed_t<T>;
  CT val_{};
  SVector<T, N, true> partials_{CT{}};

  using decompressed_type = Dual<utils::decompressed_t<T>, N, false>;
  TRIVIAL constexpr operator decompressed_type() const {
    return decompressed_type::decompress(this);
  }
  TRIVIAL [[nodiscard]] constexpr auto value() -> T { return val_; }
  TRIVIAL [[nodiscard]] constexpr auto value() const -> const T & {
    return val_;
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient() -> SVector<T, N, true> & {
    return partials_;
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient() const
    -> const SVector<T, N, true> & {
    return partials_;
  }
  void print() const {
    utils::print("Dual<", N, ">{", value());
    for (std::ptrdiff_t n = 0; n < N; ++n) utils::print(", ", gradient()[n]);
    utils::print("}");
  };

  // TRIVIAL constexpr auto operator-() const & -> Dual {
  //   return {-val_, -partials};
  // }
  // TRIVIAL constexpr auto
  // operator+(const Dual &other) const & -> Dual {
  //   return {val_ + other.val_, partials + other.partials};
  // }
  // TRIVIAL constexpr auto operator-(const Dual &other) const
  //   -> Dual {
  //   return {val_ - other.val_, partials - other.partials};
  // }
  // TRIVIAL constexpr auto operator+=(const Dual &other)
  //   -> Dual & {
  //   val_ += other.val_;
  //   partials += other.partials;
  //   return *this;
  // }
  // TRIVIAL constexpr auto operator-=(const Dual &other)
  //   -> Dual & {
  //   val_ -= other.val_;
  //   partials -= other.partials;
  //   return *this;
  // }
};

template <simd::SIMDSupported T, std::ptrdiff_t N>
requires(std::popcount(std::size_t(N)) > 1) struct Dual<T, N, true> {
  SVector<T, N + 1, true> data_{T{}};

  using decompressed_type = Dual<utils::decompressed_t<T>, N, false>;
  TRIVIAL constexpr operator decompressed_type() const {
    return decompressed_type::decompress(this);
  }
  TRIVIAL [[nodiscard]] constexpr auto value() -> T { return data_[0]; }
  TRIVIAL [[nodiscard]] constexpr auto value() const -> const T & {
    return data_[0];
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient() -> MutArray<T, Length<N>> {
    return {data_.data() + 1, {}};
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient() const -> Array<T, Length<N>> {
    return {data_.data() + 1, {}};
  }

  // TRIVIAL constexpr auto operator-() const & -> Dual {
  //   return {-data_};
  // }
  // TRIVIAL constexpr auto
  // operator+(const Dual &other) const & -> Dual {
  //   return {data_ + other.data_};
  // }
  // TRIVIAL constexpr auto operator-(const Dual &other) const
  //   -> Dual {
  //   return {data_ - other.data_};
  // }
  // TRIVIAL constexpr auto operator+=(const Dual &other)
  //   -> Dual & {
  //   data_ += other.data_;
  //   return *this;
  // }
  // TRIVIAL constexpr auto operator-=(const Dual &other)
  //   -> Dual & {
  //   data_ -= other.data_;
  //   return *this;
  // }
};

template <class T, std::ptrdiff_t N> struct Dual<T, N, false> {
  // default decompressed separates the value and partials
  using data_type = SVector<T, N, false>;
  T val_{};
  data_type partials_{T{}};

  // using compressed_type = Dual<utils::compressed_t<T>, N, true>;
  using compressed_type = Dual<T, N, true>;
  using decompressed_type = Dual<utils::decompressed_t<T>, N, false>;
  static_assert(std::same_as<Dual, decompressed_type>);

  TRIVIAL constexpr Dual() = default;
  TRIVIAL constexpr Dual(T v) : val_(v) {}
  TRIVIAL constexpr Dual(T v, std::ptrdiff_t n) : val_(v) {
    partials_[n] = T{1};
  }
  TRIVIAL constexpr Dual(T v, data_type g) : val_(v), partials_(g) {}
  TRIVIAL constexpr Dual(T v, AbstractVector auto g) {
    value() = v;
    gradient() << g;
  }
  TRIVIAL constexpr Dual(std::integral auto v) : val_(v) {}
  TRIVIAL constexpr Dual(std::floating_point auto v) : val_(v) {}
  // constexpr Dual(const Dual &) = default;
  // constexpr auto operator=(const Dual &) -> Dual & = default;
  TRIVIAL constexpr auto value() -> T & { return val_; }
  TRIVIAL constexpr auto gradient() -> data_type & { return partials_; }
  TRIVIAL constexpr auto gradient(std::ptrdiff_t i) -> T & {
    return partials_[i];
  }
  TRIVIAL [[nodiscard]] constexpr auto value() const -> const T & {
    return val_;
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient() const -> const data_type & {
    return partials_;
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient(std::ptrdiff_t i) const -> T {
    return partials_[i];
  }
  TRIVIAL constexpr auto operator-() const -> Dual {
    return {-val_, -partials_};
  }
  TRIVIAL constexpr auto operator+(const Dual &other) const -> Dual {
    return {val_ + other.val_, partials_ + other.partials_};
  }
  TRIVIAL constexpr auto operator-(const Dual &other) const -> Dual {
    return {val_ - other.val_, partials_ - other.partials_};
  }
  TRIVIAL constexpr auto operator*(const Dual &other) const -> Dual {
#ifndef POLYMATHNOEXPLICITSIMDARRAY
    if constexpr (std::same_as<T, double> && (N > 1)) {
      Dual ret(val_ * other.val_);
      using V = typename data_type::V;
      constexpr std::ptrdiff_t W = data_type::W;
      V va = simd::vbroadcast<W, double>(val_),
        vb = simd::vbroadcast<W, double>(other.val_);
      if constexpr (data_type::L == 1) {
        ret.partials_.data_ = va * other.partials_.data_ + vb * partials_.data_;
      } else {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t i = 0; i < data_type::L; ++i)
          ret.partials_.memory_[i] =
            va * other.partials_.memory_[i] + vb * partials_.memory_[i];
      }
      return ret;
    } else
#endif
      return {val_ * other.val_,
              (val_ * other.partials_) + (other.val_ * partials_)};
  }
  TRIVIAL constexpr auto operator/(const Dual &other) const -> Dual {
    return {val_ / other.val_,
            (other.val_ * partials_ - val_ * other.partials_) /
              (other.val_ * other.val_)};
  }
  TRIVIAL constexpr auto operator+(const T &other) const & -> Dual
    requires(!std::same_as<T, double>) {
    return {val_ + other, partials_};
  }
  TRIVIAL constexpr auto operator-(const T &other) const -> Dual
    requires(!std::same_as<T, double>) {
    return {val_ - other, partials_};
  }
  TRIVIAL constexpr auto operator*(const T &other) const -> Dual
    requires(!std::same_as<T, double>) {
    return {val_ * other, partials_ * other};
  }
  TRIVIAL constexpr auto operator/(const T &other) const -> Dual
    requires(!std::same_as<T, double>) {
    return {val_ / other, partials_ / other};
  }
  TRIVIAL constexpr auto operator+=(const Dual &other) -> Dual & {
    val_ += other.val_;
    partials_ += other.partials_;
    return *this;
  }
  TRIVIAL constexpr auto operator-=(const Dual &other) -> Dual & {
    val_ -= other.val_;
    partials_ -= other.partials_;
    return *this;
  }
  TRIVIAL constexpr auto operator*=(const Dual &other) -> Dual & {
    partials_ << (val_ * other.partials_) + (other.val_ * partials_);
    val_ *= other.val_;
    return *this;
  }
  TRIVIAL constexpr auto operator/=(const Dual &other) -> Dual & {
    partials_ << (other.val_ * partials_ - val_ * other.partials_) /
                   (other.val_ * other.val_);
    val_ /= other.val_;
    return *this;
  }
  TRIVIAL constexpr auto operator+(double other) const & -> Dual {
    return {val_ + other, partials_};
  }
  TRIVIAL constexpr auto operator-(double other) const -> Dual {
    return {val_ - other, partials_};
  }
  TRIVIAL constexpr auto operator*(double other) const -> Dual {
    return {val_ * other, partials_ * other};
  }
  TRIVIAL constexpr auto operator/(double other) const -> Dual {
    return {val_ / other, partials_ / other};
  }
  TRIVIAL constexpr auto operator+=(double other) -> Dual & {
    val_ += other;
    return *this;
  }
  TRIVIAL constexpr auto operator-=(double other) -> Dual & {
    val_ -= other;
    return *this;
  }
  TRIVIAL constexpr auto operator*=(double other) -> Dual & {
    val_ *= other;
    partials_ *= other;
    return *this;
  }
  TRIVIAL constexpr auto operator/=(double other) -> Dual & {
    val_ /= other;
    partials_ /= other;
    return *this;
  }
  TRIVIAL constexpr auto operator==(const Dual &other) const -> bool {
    return val_ == other.val_; // && grad == other.grad;
  }
  TRIVIAL constexpr auto operator!=(const Dual &other) const -> bool {
    return val_ != other.val_; // || grad != other.grad;
  }
  TRIVIAL constexpr auto operator<(const Dual &other) const -> bool {
    return val_ < other.val_;
  }
  TRIVIAL constexpr auto operator>(const Dual &other) const -> bool {
    return val_ > other.val_;
  }
  TRIVIAL constexpr auto operator<=(const Dual &other) const -> bool {
    return val_ <= other.val_;
  }
  TRIVIAL constexpr auto operator>=(const Dual &other) const -> bool {
    return val_ >= other.val_;
  }
  TRIVIAL constexpr auto operator==(double other) const -> bool {
    return val_ == other;
  }
  TRIVIAL constexpr auto operator!=(double other) const -> bool {
    return val_ != other;
  }
  TRIVIAL constexpr auto operator<(double other) const -> bool {
    return val_ < other;
  }
  TRIVIAL constexpr auto operator>(double other) const -> bool {
    return val_ > other;
  }
  TRIVIAL constexpr auto operator<=(double other) const -> bool {
    return val_ <= other;
  }
  TRIVIAL constexpr auto operator>=(double other) const -> bool {
    return val_ >= other;
  }
  TRIVIAL constexpr auto operator==(T other) const -> bool
    requires(!std::same_as<T, double>) {
    return val_ == other;
  }
  TRIVIAL constexpr auto operator!=(T other) const -> bool
    requires(!std::same_as<T, double>) {
    return val_ != other;
  }
  TRIVIAL constexpr auto operator<(T other) const -> bool
    requires(!std::same_as<T, double>) {
    return val_ < other;
  }
  TRIVIAL constexpr auto operator>(T other) const -> bool
    requires(!std::same_as<T, double>) {
    return val_ > other;
  }
  TRIVIAL constexpr auto operator<=(T other) const -> bool
    requires(!std::same_as<T, double>) {
    return val_ <= other;
  }
  TRIVIAL constexpr auto operator>=(T other) const -> bool
    requires(!std::same_as<T, double>) {
    return val_ >= other;
  }
  TRIVIAL constexpr void compress(compressed_type *p) const {
    utils::compress(val_, &(p->val_));
    partials_.compress(&(p->partials_));
  }
  TRIVIAL static constexpr auto decompress(const compressed_type *p) -> Dual {
    return {utils::decompress<T>(&(p->val_)),
            SVector<T, N>::decompress(&(p->partials_))};
  }
  TRIVIAL constexpr operator compressed_type() const {
    compressed_type ret;
    compress(&ret);
    return ret;
  }

private:
  TRIVIAL friend constexpr auto value(const Dual &x) -> T { return x.value(); }
  TRIVIAL friend constexpr auto extractvalue(const Dual &x) {
    return extractvalue(x.value());
  }
  TRIVIAL friend constexpr auto operator>(double other, Dual x) -> bool {
    return other > x.value();
  }
  TRIVIAL friend constexpr auto operator>=(double other, Dual x) -> bool {
    return other >= x.value();
  }
  TRIVIAL friend constexpr auto operator<(double other, Dual x) -> bool {
    return other < x.value();
  }
  TRIVIAL friend constexpr auto operator<=(double other, Dual x) -> bool {
    return other <= x.value();
  }
  TRIVIAL friend constexpr auto operator==(double other, Dual x) -> bool {
    return other == x.value();
  }
  TRIVIAL friend constexpr auto operator!=(double other, Dual x) -> bool {
    return other != x.value();
  }
  void print() const {
    utils::print("Dual<", N, ">{", value());
    for (std::ptrdiff_t n = 0; n < N; ++n) utils::print(", ", gradient()[n]);
    utils::print("}");
  };
  TRIVIAL friend constexpr auto operator+(T a, Dual b) -> Dual
    requires(!std::same_as<T, double>) {
    return {a + b.val_, b.partials_};
  }
  TRIVIAL friend constexpr auto operator-(T a, Dual b) -> Dual
    requires(!std::same_as<T, double>) {
    return {a - b.val_, -b.partials_};
  }
  TRIVIAL friend constexpr auto operator*(T a, Dual b) -> Dual
    requires(!std::same_as<T, double>) {
    // Dual res;
    // res.val_ = val_ * other.val_;
    // res.partials << val_ * other.partials + other.val_ * partials;
    // return res;
    return {a * b.val_, a * b.partials_};
  }
  TRIVIAL friend constexpr auto operator/(T a, Dual b) -> Dual
    requires(!std::same_as<T, double>) {
    return {a / b.val_, (-a * b.partials_) / (b.val_ * b.val_)};
  }
  TRIVIAL friend constexpr auto operator+(double other, Dual x) -> Dual {
    return {x.value() + other, x.gradient()};
  }
  TRIVIAL friend constexpr auto operator-(double other, Dual x) -> Dual {
    return {other - x.value(), -x.gradient()};
  }
  TRIVIAL friend constexpr auto operator*(double other, Dual x) -> Dual {
    return {x.value() * other, other * x.gradient()};
  }
  TRIVIAL friend constexpr auto operator/(double other, Dual x) -> Dual {
    return {other / x.value(), -other * x.gradient() / (x.value() * x.value())};
  }
};

template <simd::SIMDSupported T, std::ptrdiff_t N>
requires(std::popcount(std::size_t(N)) > 1) struct Dual<T, N, false> {
  static constexpr std::ptrdiff_t value_idx = 0; // N;
  static constexpr std::ptrdiff_t partial_offset = value_idx != N;
  using data_type = SVector<T, N + 1, false>;
  data_type data_{T{}};
  using compressed_type = Dual<T, N, true>;
  using decompressed_type = Dual<T, N, false>;

  using V = typename data_type::V;
  static constexpr std::ptrdiff_t W = data_type::W;
  // constexpr Dual() = default;
  TRIVIAL constexpr Dual() = default;
  TRIVIAL constexpr Dual(T v) { data_[value_idx] = v; }
  TRIVIAL constexpr Dual(T v, std::ptrdiff_t n) {
    data_[value_idx] = v;
    data_[partial_offset + n] = T{1};
  }
  // constexpr Dual(T v, std::ptrdiff_t n, T p) {
  //   data_[value_idx] = v;
  //   data_[partial_offset + n] = p;
  // }
  TRIVIAL constexpr Dual(T v, AbstractVector auto g) {
    value() = v;
    gradient() << g;
  }
  TRIVIAL constexpr Dual(data_type d) : data_{d} {}
  TRIVIAL constexpr Dual(const AbstractVector auto &d)
    requires(std::convertible_to<utils::eltype_t<decltype(d)>, T>)
    : data_{d} {}
  TRIVIAL constexpr Dual(std::integral auto v) { value() = v; }
  TRIVIAL constexpr Dual(std::floating_point auto v) { value() = v; }
  TRIVIAL constexpr auto value() -> T & { return data_[value_idx]; }
  TRIVIAL constexpr auto gradient() -> MutArray<T, Length<N>> {
    return {data_.data() + partial_offset, {}};
  }
  TRIVIAL [[nodiscard]] constexpr auto value() const -> T {
    return data_[value_idx];
  }
  // zeros out partial part of the vector
  TRIVIAL [[nodiscard]] constexpr auto vvalue() const -> V {
    // return data_[value_idx];
    if constexpr (data_type::L == 1)
      return (simd::range<W, std::int64_t>() == simd::Vec<W, std::int64_t>{})
               ? data_.data_
               : V{};
    else
      return (simd::range<W, std::int64_t>() == simd::Vec<W, std::int64_t>{})
               ? data_.memory_[0]
               : V{};
  }
  // broadcasts value across register
  TRIVIAL [[nodiscard]] constexpr auto vbvalue() const -> V {
    if constexpr (data_type::L == 1) return simd::vbroadcast<W, T>(data_.data_);
    else return simd::vbroadcast<W, T>(data_.memory_[0]);
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient() const -> Array<T, Length<N>> {
    return {data_.data() + partial_offset, {}};
  }

  TRIVIAL constexpr auto operator-() const -> Dual { return {-data_}; }
  // constexpr auto operator+(const Dual &other) const -> Dual {
  //   return {data_ + other.data_};
  // }
  // constexpr auto operator-(const Dual &other) const -> Dual {
  //   return {data_ - other.data_};
  // }
  // constexpr auto operator*(const Dual &other) const -> Dual {
  //   // TODO: either update remaining methods to match this style,
  //   // or figure out how to get `conditional`'s codegen quality to match
  //   if constexpr (data_type::L == 1) {
  //     V vt = vbvalue(), vo = other.vbvalue(), x = vt * other.data_.data_;
  //     return {
  //       {simd::fmadd<T>(vo, data_.data_, x, simd::firstoff<W,
  //       std::int64_t>())}};
  //   } else {
  //     Dual ret;
  //     V vt = vbvalue(), vo = other.vbvalue(), x = vt *
  //     other.data_.memory_[0]; ret.data_.memory_[0] =
  //       simd::fmadd<T>(vo, data_.memory_[0], x, simd::firstoff<W,
  //       std::int64_t>());
  //     POLYMATHFULLUNROLL
  //     for (std::ptrdiff_t i = 1; i < data_type::L; ++i)
  //       ret.data_.memory_[i] = vt * other.data_.memory_[i] + vo *
  //       data_.memory_[i];
  //     return ret;
  //   }
  //   // return {conditional(std::plus<>{},
  //   //                     elementwise_not_equal(_(0, N + 1), value_idx),
  //   //                     value() * other.data_, data_ * other.value())};
  // }
  // constexpr auto operator/(const Dual &other) const -> Dual {
  //   Dual ret;
  //   if constexpr (data_type::L == 1) {
  //     V vt = vbvalue(), vo = other.vbvalue(), vo2 = vo * vo,
  //       x = vo * data_.data_;
  //     ret.data_.data_ =
  //       simd::fnmadd<T>(vt, other.data_.data_, x, simd::firstoff<W,
  //       std::int64_t>()) / vo2;
  //   } else {
  //     V vt = vbvalue(), vo = other.vbvalue(), vo2 = vo * vo,
  //       x = vo * data_.memory_[0];
  //     ret.data_.memory_[0] = simd::fnmadd<T>(vt, other.data_.memory_[0], x,
  //                                           simd::firstoff<W,
  //                                           std::int64_t>()) /
  //                           vo2;
  //     POLYMATHFULLUNROLL
  //     for (std::ptrdiff_t i = 1; i < data_type::L; ++i)
  //       ret.data_.memory_[i] =
  //         (vo * data_.memory_[i] - vt * other.data_.memory_[i]) / vo2;
  //   }
  //   return ret;
  //   // val_ = value() / other.value()
  //   // partials = (other.value() * gradient() - value() * other.gradient()) /
  //   // (other.value() * other.value())
  //   // partials = (gradient()) / (other.value())
  //   //  - (value() * other.gradient()) / (other.value() * other.value())
  //   // T v{other.value()};
  //   // return {conditional(std::minus<>{},
  //   //                     elementwise_not_equal(_(0, N + 1), value_idx),
  //   data_ /
  //   //                     v, value() * other.data_ / (v * v))};
  // }
  TRIVIAL constexpr auto operator+=(Dual other) -> Dual & {
    data_ += other.data_;
    return *this;
  }
  TRIVIAL constexpr auto operator-=(Dual other) -> Dual & {
    data_ -= other.data_;
    return *this;
  }
  TRIVIAL constexpr auto operator*=(Dual other) -> Dual & {
    if constexpr (data_type::L == 1) {
      V vt = vbvalue(), vo = other.vbvalue(), x = vt * other.data_.data_;
      data_.data_ =
        simd::fmadd<T>(vo, data_.data_, x, simd::firstoff<W, std::int64_t>());
    } else {
      V vt = vbvalue(), vo = other.vbvalue(), x = vt * other.data_.memory_[0];
      data_.memory_[0] = simd::fmadd<T>(vo, data_.memory_[0], x,
                                        simd::firstoff<W, std::int64_t>());
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 1; i < data_type::L; ++i)
        data_.memory_[i] = vt * other.data_.memory_[i] + vo * data_.memory_[i];
    }
    // data_ << conditional(std::plus<>{},
    //                     elementwise_not_equal(_(0, N + 1), value_idx),
    //                     value() * other.data_, data_ * other.value());
    return *this;
  }
  TRIVIAL constexpr auto operator/=(Dual other) -> Dual & {
    if constexpr (data_type::L == 1) {
      V vt = vbvalue(), vo = other.vbvalue(), vo2 = vo * vo,
        x = vo * data_.data_;
      data_.data_ = simd::fnmadd<T>(vt, other.data_.data_, x,
                                    simd::firstoff<W, std::int64_t>()) /
                    vo2;
    } else {
      V vt = vbvalue(), vo = other.vbvalue(), vo2 = vo * vo,
        x = vo * data_.memory_[0];
      data_.memory_[0] = simd::fnmadd<T>(vt, other.data_.memory_[0], x,
                                         simd::firstoff<W, std::int64_t>()) /
                         vo2;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 1; i < data_type::L; ++i)
        data_.memory_[i] =
          (vo * data_.memory_[i] - vt * other.data_.memory_[i]) / vo2;
    }
    // T v{other.value()};
    // data_ << conditional(std::minus<>{},
    //                     elementwise_not_equal(_(0, N + 1), value_idx), data_
    //                     / v, value() * other.data_ / (v * v));
    return *this;
  }
  // constexpr auto operator+(double other) const -> Dual {
  //   Dual ret = *this;
  //   if constexpr (data_type::L == 1)
  //     ret.data_.data_ += simd::Vec<SVector<T, N + 1>::W, T>{other};
  //   else ret.data_.memory_[0] += simd::Vec<SVector<T, N + 1>::W, T>{other};
  //   return ret;
  // }
  // constexpr auto operator-(double other) const -> Dual {
  //   Dual ret = *this;
  //   if constexpr (data_type::L == 1)
  //     ret.data_.data_ -= simd::Vec<SVector<T, N + 1>::W, T>{other};
  //   else ret.data_.memory_[0] -= simd::Vec<SVector<T, N + 1>::W, T>{other};
  //   return ret;
  // }
  // constexpr auto operator*(double other) const -> Dual {
  //   return {data_ * other};
  // }
  // constexpr auto operator/(double other) const -> Dual {
  //   return {data_ / other};
  // }
  TRIVIAL constexpr auto operator+=(double other) -> Dual & {
    if constexpr (data_type::L == 1)
      data_.data_ += simd::Vec<SVector<T, N + 1>::W, T>{other};
    else data_.memory_[0] += simd::Vec<SVector<T, N + 1>::W, T>{other};
    return *this;
  }
  TRIVIAL constexpr auto operator-=(double other) -> Dual & {
    if constexpr (data_type::L == 1)
      data_.data_ -= simd::Vec<SVector<T, N + 1>::W, T>{other};
    else data_.memory_[0] -= simd::Vec<SVector<T, N + 1>::W, T>{other};
    return *this;
  }
  TRIVIAL constexpr auto operator*=(double other) -> Dual & {
    data_ *= other;
    return *this;
  }
  TRIVIAL constexpr auto operator/=(double other) -> Dual & {
    data_ /= other;
    return *this;
  }
  TRIVIAL constexpr auto operator==(const Dual &other) const -> bool {
    return value() == other.value(); // && grad == other.grad;
  }
  TRIVIAL constexpr auto operator!=(const Dual &other) const -> bool {
    return value() != other.value(); // || grad != other.grad;
  }
  TRIVIAL constexpr auto operator==(double other) const -> bool {
    return value() == other;
  }
  TRIVIAL constexpr auto operator!=(double other) const -> bool {
    return value() != other;
  }
  TRIVIAL constexpr auto operator<(double other) const -> bool {
    return value() < other;
  }
  TRIVIAL constexpr auto operator>(double other) const -> bool {
    return value() > other;
  }
  TRIVIAL constexpr auto operator<=(double other) const -> bool {
    return value() <= other;
  }
  TRIVIAL constexpr auto operator>=(double other) const -> bool {
    return value() >= other;
  }
  TRIVIAL constexpr auto operator<(const Dual &other) const -> bool {
    return value() < other.value();
  }
  TRIVIAL constexpr auto operator>(const Dual &other) const -> bool {
    return value() > other.value();
  }
  TRIVIAL constexpr auto operator<=(const Dual &other) const -> bool {
    return value() <= other.value();
  }
  TRIVIAL constexpr auto operator>=(const Dual &other) const -> bool {
    return value() >= other.value();
  }
  TRIVIAL static constexpr auto decompress(const compressed_type *p) -> Dual {
    return {SVector<T, N + 1, false>{p->data_}};
  }
  TRIVIAL constexpr operator compressed_type() const {
    compressed_type ret;
    compress(&ret);
    return ret;
  }
  TRIVIAL constexpr void compress(compressed_type *p) const {
    p->data_ << data_;
  }

private:
  TRIVIAL friend constexpr auto value(const Dual &x) -> T { return x.value(); }
  TRIVIAL friend constexpr auto extractvalue(const Dual &x) -> T {
    return x.value();
  }
  TRIVIAL friend constexpr auto exp(Dual x) -> Dual {
    return {conditional(std::multiplies<>{},
                        elementwise_not_equal(_(0, N + 1), value_idx),
                        exp(x.value()), x.data_)};
  }
  TRIVIAL friend constexpr auto operator/(double a, Dual b) -> Dual {
    Dual ret;
    if constexpr (data_type::L == 1) {
      V vt = simd::vbroadcast<W, double>(a), vo = b.vbvalue(), vo2 = vo * vo,
        x = vo * simd::Vec<W, double>{a};
      ret.data_.data_ = simd::fnmadd<T>(vt, b.data_.data_, x,
                                        simd::firstoff<W, std::int64_t>()) /
                        vo2;
    } else {
      V vt = simd::vbroadcast<W, double>(a), vo = b.vbvalue(), vo2 = vo * vo,
        x = vo * simd::Vec<W, double>{a};
      ret.data_.memory_[0] =
        simd::fnmadd<T>(vt, b.data_.memory_[0], x,
                        simd::firstoff<W, std::int64_t>()) /
        vo2;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 1; i < data_type::L; ++i)
        ret.data_.memory_[i] = (-vt * b.data_.memory_[i]) / vo2;
    }
    return ret;
    // T v = other / x.value();
    // return {conditional(std::multiplies<>{},
    //                     elementwise_not_equal(_(0, N + 1), value_idx), v,
    //                     -x.data_ / x.value())};
    // return {v, -v * x.gradient() / (x.value())};
  }
  TRIVIAL friend constexpr auto operator>(double other, Dual x) -> bool {
    return other > x.value();
  }
  TRIVIAL friend constexpr auto operator>=(double other, Dual x) -> bool {
    return other >= x.value();
  }
  TRIVIAL friend constexpr auto operator<(double other, Dual x) -> bool {
    return other < x.value();
  }
  TRIVIAL friend constexpr auto operator<=(double other, Dual x) -> bool {
    return other <= x.value();
  }
  TRIVIAL friend constexpr auto operator==(double other, Dual x) -> bool {
    return other == x.value();
  }
  TRIVIAL friend constexpr auto operator!=(double other, Dual x) -> bool {
    return other != x.value();
  }
  void print() const {
    utils::print("Dual<", N, ">{", value());
    for (std::ptrdiff_t n = 0; n < N; ++n) utils::print(", ", gradient()[n]);
    utils::print("}");
  };

  TRIVIAL friend constexpr auto operator+(Dual x, Dual y) -> Dual {
    return {x.data_ + y.data_};
  }

  TRIVIAL friend constexpr auto operator-(Dual x, Dual y) -> Dual {
    return {x.data_ - y.data_};
  }

  TRIVIAL friend constexpr auto operator*(Dual a, Dual b) -> Dual {
    using D = Dual<T, N, false>;
    if constexpr (data_type::L == 1) {
      V vt = a.vbvalue(), vo = b.vbvalue(), x = vt * b.data_.data_;
      return {{simd::fmadd<T>(vo, a.data_.data_, x,
                              simd::firstoff<D::W, std::int64_t>())}};
    } else {
      Dual<T, N, false> ret;
      V vt = a.vbvalue(), vo = b.vbvalue(), x = vt * b.data_.memory_[0];
      ret.data_.memory_[0] = simd::fmadd<T>(
        vo, a.data_.memory_[0], x, simd::firstoff<D::W, std::int64_t>());
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 1; i < data_type::L; ++i)
        ret.data_.memory_[i] =
          vt * b.data_.memory_[i] + vo * a.data_.memory_[i];
      return ret;
    }
  }
  TRIVIAL friend constexpr auto operator/(Dual a, Dual b) -> Dual {
    Dual ret;
    if constexpr (data_type::L == 1) {
      V vt = a.vbvalue(), vo = b.vbvalue(), vo2 = vo * vo,
        x = vo * a.data_.data_;
      ret.data_.data_ = simd::fnmadd<T>(vt, b.data_.data_, x,
                                        simd::firstoff<W, std::int64_t>()) /
                        vo2;
    } else {
      V vt = a.vbvalue(), vo = b.vbvalue(), vo2 = vo * vo,
        x = vo * a.data_.memory_[0];
      ret.data_.memory_[0] =
        simd::fnmadd<T>(vt, b.data_.memory_[0], x,
                        simd::firstoff<W, std::int64_t>()) /
        vo2;
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t i = 1; i < data_type::L; ++i)
        ret.data_.memory_[i] =
          (vo * a.data_.memory_[i] - vt * b.data_.memory_[i]) / vo2;
    }
    return ret;
  }
  TRIVIAL friend constexpr auto operator+(Dual a, double b) -> Dual {
    if constexpr (data_type::L == 1)
      a.data_.data_ += simd::Vec<SVector<T, N + 1>::W, T>{b};
    else a.data_.memory_[0] += simd::Vec<SVector<T, N + 1>::W, T>{b};
    return a;
  }

  TRIVIAL friend constexpr auto operator+(double a, Dual b) -> Dual {
    if constexpr (data_type::L == 1)
      b.data_.data_ += simd::Vec<SVector<T, N + 1>::W, T>{a};
    else b.data_.memory_[0] += simd::Vec<SVector<T, N + 1>::W, T>{a};
    return b;
  }

  TRIVIAL friend constexpr auto operator-(Dual a, double b) -> Dual {
    if constexpr (data_type::L == 1)
      a.data_.data_ -= simd::Vec<SVector<T, N + 1>::W, T>{b};
    else a.data_.memory_[0] -= simd::Vec<SVector<T, N + 1>::W, T>{b};
    return a;
  }
  TRIVIAL friend constexpr auto operator-(double a, Dual b) -> Dual {
    if constexpr (data_type::L == 1)
      b.data_.data_ = simd::Vec<SVector<T, N + 1>::W, T>{a} - b.data_.data_;
    else {
      b.data_.memory_[0] =
        simd::Vec<SVector<T, N + 1>::W, T>{a} - b.data_.memory_[0];
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t l = 1; l < data_type::L; ++l)
        b.data_.memory_[l] = -b.data_.memory_[l];
    }
    return b;
  }
  TRIVIAL friend constexpr auto operator*(Dual a, double b) -> Dual {
    return {a.data_ * b};
  }
  TRIVIAL friend constexpr auto operator*(double a, Dual b) -> Dual {
    return {a * b.data_};
  }

  TRIVIAL friend constexpr auto operator/(Dual a, double b) -> Dual {
    return {a.data_ / b};
  }
};

static_assert(!std::convertible_to<Array<Dual<double, 7, true>, Length<2>>,
                                   Dual<double, 7, false>>);
static_assert(utils::Compressible<Dual<double, 7>>);
static_assert(utils::Compressible<Dual<double, 8>>);
static_assert(sizeof(Dual<Dual<double, 8, true>, 2, true>) ==
              sizeof(double) * 9UL * 3UL);
static_assert(sizeof(Dual<Dual<double, 8>, 2>) ==
              sizeof(double) * (8 + simd::Width<double>)*3UL);
static_assert(sizeof(Dual<double, 7>) == 64);
static_assert(std::same_as<Dual<double, 7>, Dual<double, 7, false>>);
// static_assert(
//   AbstractVector<Conditional<
//     ::math::ElementwiseBinaryOp<::math::Range<long, long>, long,
//                                 std::not_equal_to<void>>,
//     ::math::ElementwiseBinaryOp<
//       double, ::math::StaticArray<double, 1, 8, false>,
//       std::multiplies<void>>,
//     ::math::ElementwiseBinaryOp<::math::StaticArray<double, 1, 8, false>,
//                                 double, std::multiplies<void>>,
//     std::plus<void>>>);

template <class T, std::ptrdiff_t N> Dual(T, SVector<T, N>) -> Dual<T, N>;

template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto exp(const Dual<T, N> &x) -> Dual<T, N> {
  T expx = exp(x.value());
  return {expx, expx * x.gradient()};
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto sigmoid(const Dual<T, N> &x) -> Dual<T, N> {
  T s = sigmoid(x.value());
  return {s, (s - s * s) * x.gradient()};
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto softplus(const Dual<T, N> &x) -> Dual<T, N> {
  return {softplus(x.value()), sigmoid(x.value()) * x.gradient()};
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto log(const Dual<T, N> &x) -> Dual<T, N> {
  constexpr double logof2 = 0.6931471805599453; // log(2);
  return {log2(x.value()) * logof2, x.gradient() / x.value()};
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto log2(const Dual<T, N> &x) -> Dual<T, N> {
  constexpr double logof2 = 0.6931471805599453; // log(2);
  return {log2(x.value()), x.gradient() / (logof2 * x.value())};
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto log1p(const Dual<T, N> &x) -> Dual<T, N> {
  // d log(1+x)/dx = dx/1+x
  return {log1p(x.value()), x.gradient() / (1.0 + x.value())};
}

// Reference support...
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto exp(utils::Reference<Dual<T, N>> x) -> Dual<T, N> {
  return exp(Dual<T, N>{x});
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto sigmoid(utils::Reference<Dual<T, N>> x) -> Dual<T, N> {
  return sigmoid(Dual<T, N>{x});
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto log(utils::Reference<Dual<T, N>> x) -> Dual<T, N> {
  return log(Dual<T, N>{x});
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto log2(utils::Reference<Dual<T, N>> x) -> Dual<T, N> {
  return log2(Dual<T, N>{x});
}
template <class T, std::ptrdiff_t N>
TRIVIAL constexpr auto log1p(utils::Reference<Dual<T, N>> x) -> Dual<T, N> {
  return log1p(Dual<T, N>{x});
}
template <int l = 8> TRIVIAL constexpr auto smax(auto x, auto y, auto z) {
  double m =
    std::max(std::max(extractvalue(x), extractvalue(y)), extractvalue(z));
  static constexpr double f = l, i = 1 / f;
  return m + i * log(exp(f * (x - m)) + exp(f * (y - m)) + exp(f * (z - m)));
}
template <int l = 8>
TRIVIAL constexpr auto smax(auto w, auto x, auto y, auto z) {
  double m = std::max(std::max(extractvalue(w), extractvalue(y)),
                      std::max(extractvalue(x), extractvalue(z)));
  static constexpr double f = l, i = 1 / f;
  return m + i * log(exp(f * (w - m)) + exp(f * (x - m)) + exp(f * (y - m)) +
                     exp(f * (z - m)));
}
template <int l = 8, typename T, std::ptrdiff_t N>
TRIVIAL constexpr auto smax(SVector<T, N> x) -> T {
  static_assert(!std::is_integral_v<T>);
  static constexpr double f = l, i = 1 / f;
  double m = -std::numeric_limits<double>::max();
  for (std::ptrdiff_t n = 0; n < N; ++n) m = std::max(m, extractvalue(x[n]));
  T a{};
  for (std::ptrdiff_t n = 0; n < N; ++n) a += exp(f * (x[n] - m));
  return m + i * log(a);
}

TRIVIAL constexpr auto dval(double &x) -> double & { return x; }
template <typename T, std::ptrdiff_t N>
TRIVIAL constexpr auto dval(Dual<T, N> &x) -> double & {
  return dval(x.value());
}

class GradientResult {
  double value_;
  MutPtrVector<double> grad_;

public:
  TRIVIAL [[nodiscard]] constexpr auto value() const -> double {
    return value_;
  }
  TRIVIAL [[nodiscard]] constexpr auto gradient() const
    -> MutPtrVector<double> {
    return grad_;
  }
};
class HessianResultCore {
  double *ptr_;
  std::ptrdiff_t dim_;

public:
  TRIVIAL [[nodiscard]] constexpr auto gradient() const
    -> MutPtrVector<double> {
    return {ptr_, length(dim_)};
  }
  TRIVIAL [[nodiscard]] constexpr auto hessian() const
    -> MutSquarePtrMatrix<double> {
    return {ptr_ + dim_, SquareDims<>{row(dim_)}};
  }
  TRIVIAL constexpr HessianResultCore(alloc::Arena<> *alloc, std::ptrdiff_t d)
    : ptr_{alloc->allocate<double>(std::size_t(d) * (d + 1))}, dim_{d} {}
};
class HessianResult : public HessianResultCore {
  double x{};

public:
  [[nodiscard]] constexpr auto value() -> double & { return x; }
  [[nodiscard]] constexpr auto value() const -> double { return x; }

  constexpr HessianResult(alloc::Arena<> *alloc, unsigned d)
    : HessianResultCore{alloc, d} {}

  template <std::size_t I> TRIVIAL constexpr auto get() const {
    if constexpr (I == 0) return x;
    else if constexpr (I == 1) return gradient();
    else return hessian();
  }
};

template <std::ptrdiff_t N, AbstractVector T>
struct DualVector : Expr<Dual<utils::eltype_t<T>, N>, DualVector<N, T>> {
  using value_type = Dual<utils::eltype_t<T>, N>;
  static_assert(utils::TriviallyCopyable<T>);
  T x_;
  std::ptrdiff_t offset_;
  TRIVIAL [[nodiscard]] constexpr auto operator[](std::ptrdiff_t i) const
    -> value_type {
    value_type v{x_[i]};
    if ((i >= offset_) && (i < offset_ + N))
      dval(v.gradient()[i - offset_]) = 1.0;
    return v;
  }
  TRIVIAL [[nodiscard]] constexpr auto size() const -> std::ptrdiff_t {
    return x_.size();
  }
  TRIVIAL [[nodiscard]] constexpr auto numRow() const -> Row<1> { return {}; }
  TRIVIAL [[nodiscard]] constexpr auto numCol() const -> Col<> {
    return col(x_.size());
  }
  TRIVIAL [[nodiscard]] constexpr auto view() const -> DualVector {
    return *this;
  }
};
static_assert(AbstractVector<DualVector<8, PtrVector<double>>>);
static_assert(AbstractVector<DualVector<2, DualVector<8, PtrVector<double>>>>);

template <std::ptrdiff_t N>
TRIVIAL constexpr auto dual(const AbstractVector auto &x,
                            std::ptrdiff_t offset) {
  return DualVector<N, decltype(x.view())>{.x_ = x.view(), .offset_ = offset};
}

struct Assign {
  TRIVIAL constexpr void operator()(double &x, double y) const { x = y; }
};
struct Increment {
  TRIVIAL constexpr void operator()(double &x, double y) const { x += y; }
};
struct ScaledIncrement {
  double scale_;
  TRIVIAL constexpr void operator()(double &x, double y) const {
    x += scale_ * y;
  }
};

TRIVIAL constexpr auto gradient(alloc::Arena<> *arena, PtrVector<double> x,
                                const auto &f)
  -> containers::Pair<double, MutPtrVector<double>> {
  constexpr std::ptrdiff_t U = simd::Width<double> - (simd::Width<double> == 8);
  using D = Dual<double, U>;
  std::ptrdiff_t N = x.size();
  MutPtrVector<double> grad = vector<double>(arena, N);
  auto p = arena->scope();
  for (std::ptrdiff_t i = 0;; i += U) {
    D fx = alloc::call(*arena, f, dual<U>(x, i));
    for (std::ptrdiff_t j = 0; ((j < U) && (i + j < N)); ++j)
      grad[i + j] = fx.gradient()[j];
    if (i + U >= N) return {fx.value(), grad};
  }
}
//

/// fills the lower triangle of the hessian
TRIVIAL constexpr auto hessian(HessianResultCore hr, PtrVector<double> x,
                               const auto &f, auto update) -> double {
  constexpr std::ptrdiff_t Ui =
    simd::Width<double> - (simd::Width<double> == 8);
  constexpr std::ptrdiff_t Uj = 2;
  using D = Dual<double, Ui>;
  using DD = Dual<D, Uj>;
  std::ptrdiff_t N = x.size();
  MutPtrVector<double> grad = hr.gradient();
  MutSquarePtrMatrix<double> hess = hr.hessian();
  invariant(N == grad.size());
  invariant(N == hess.numCol());
  for (std::ptrdiff_t j = 0;; j += Uj) {
    bool jbr = j + Uj >= N;
    for (std::ptrdiff_t i = 0;; i += Ui) {
      // df^2/dx_i dx_j
      bool ibr = i + Ui - Uj >= j;
      // we want to copy into both regions _(j, j+Uj) and _(i, i+Ui)
      // these regions overlap for the last `i` iteration only
      DD fx = f(dual<Uj>(dual<Ui>(x, i), j));
      // DD fx = alloc::call(arena, f, x);
      for (std::ptrdiff_t k = 0; ((k < Uj) && (j + k < N)); ++k)
        for (std::ptrdiff_t l = 0; ((l < Ui) && (i + l < N)); ++l)
          update(hess[j + k, i + l], fx.gradient()[k].gradient()[l]);
      if (jbr)
        for (std::ptrdiff_t k = 0; ((k < Ui) && (i + k < N)); ++k)
          grad[i + k] = fx.value().gradient()[k];
      if (!ibr) continue;
      if (jbr) return fx.value().value();
      break;
    }
  }
}
TRIVIAL constexpr auto hessian(HessianResultCore hr, PtrVector<double> x,
                               const auto &f) -> double {
  Assign assign{};
  return hessian(hr, x, f, assign);
}

TRIVIAL constexpr auto hessian(alloc::Arena<> *arena, PtrVector<double> x,
                               const auto &f) -> HessianResult {
  unsigned N = x.size();
  HessianResult hr{arena, N};
  hr.value() = hessian(hr, x, f);
  return hr;
}
static_assert(MatrixDimension<SquareDims<>>);
static_assert(std::same_as<utils::compressed_t<Dual<Dual<double, 8>, 2>>,
                           Dual<Dual<double, 8>, 2, true>>);

template <typename T, std::ptrdiff_t N, bool Compress>
struct IsDualImpl<::math::Dual<T, N, Compress>> : std::true_type {};

template <typename T, std::ptrdiff_t N>
struct ScalarizeEltViaCast<Dual<T, N, true>> {
  using type = std::conditional_t<std::same_as<T, double>, double,
                                  scalarize_elt_cast_t<utils::compressed_t<T>>>;
};

} // namespace math

export {

  template <> struct std::tuple_size<math::HessianResult> {
    static constexpr std::size_t value = 3;
  };
  template <> struct std::tuple_element<std::size_t(0), math::HessianResult> {
    using type = double;
  };
  template <> struct std::tuple_element<std::size_t(1), math::HessianResult> {
    using type = math::MutPtrVector<double>;
  };
  template <> struct std::tuple_element<std::size_t(2), math::HessianResult> {
    using type = math::MutSquarePtrMatrix<double>;
  };

} // namespace std
