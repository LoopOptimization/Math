module;
#include "Macros.hxx"
export module NormalForm;

import Arena;
import Array;
import ArrayConcepts;
import ArrayConstructors;
import AxisTypes;
import BaseUtils;
import Comparisons;
import EmptyMatrix;
import GCD;
import GenericArrayConstructors;
import ManagedArray;
import Range;
import Rational;
import SIMD;
import std;
import Tuple;

export namespace math {
auto gcd(PtrVector<std::int64_t> x) -> std::int64_t;
void normalizeByGCD(MutPtrVector<std::int64_t> x);

constexpr auto lcm(AbstractVector auto x) -> std::int64_t {
  std::int64_t l = x[0];
  for (std::int64_t xi : x[_(1, end)]) l = lcm(l, xi);
  return l;
}
constexpr auto lcmNonUnity(AbstractVector auto x)
  -> containers::Pair<std::int64_t, bool> {
  std::int64_t l = x[0], a = l;
  bool non_unity = a < 0;
  for (std::int64_t xi : x[_(1, end)]) {
    non_unity |= (xi != a);
    l = lcm(l, xi);
  }
  return {l, non_unity};
}
constexpr auto lcmSkipZero(AbstractVector auto x) -> std::int64_t {
  std::int64_t l = 1;
  for (std::int64_t xi : x)
    if (xi) l = lcm(l, xi);
  return l;
}
namespace NormalForm {

// Forward declarations for concrete int64_t algorithms
auto gcdxScale(std::int64_t a, std::int64_t b) -> std::array<std::int64_t, 4>;

auto pivotRows(MutPtrMatrix<std::int64_t> A, MutSquarePtrMatrix<std::int64_t> K,
               std::ptrdiff_t i, Row<> M) -> bool;
auto pivotRows(MutPtrMatrix<std::int64_t> A, Col<> i, Row<> M, Row<> piv)
  -> bool;
auto pivotRows(MutPtrMatrix<std::int64_t> A, std::ptrdiff_t i, Row<> N) -> bool;

auto numNonZeroRows(PtrMatrix<std::int64_t> A) -> Row<>;

void bareiss(MutPtrMatrix<std::int64_t> A, MutPtrVector<std::ptrdiff_t> pivots);
auto bareiss(IntMatrix<> &A) -> Vector<std::ptrdiff_t>;

void solveColumn(MutPtrMatrix<std::int64_t> A, MutPtrMatrix<std::int64_t> B,
                 std::ptrdiff_t r, std::ptrdiff_t c);
void solveSystem(MutPtrMatrix<std::int64_t> A, MutPtrMatrix<std::int64_t> B);
void solveSystemRight(MutPtrMatrix<std::int64_t> A,
                      MutPtrMatrix<std::int64_t> B);
void solveSystem(MutPtrMatrix<std::int64_t> A, std::ptrdiff_t K);
void solveSystemSkip(MutPtrMatrix<std::int64_t> A);
void solveSystem(MutPtrMatrix<std::int64_t> A);

auto inv(Arena<> *alloc, MutSquarePtrMatrix<std::int64_t> A)
  -> MutSquarePtrMatrix<std::int64_t>;
auto scaledInv(MutSquarePtrMatrix<std::int64_t> A,
               MutSquarePtrMatrix<std::int64_t> B) -> std::int64_t;
auto scaledInv(Arena<> *alloc, MutSquarePtrMatrix<std::int64_t> A)
  -> containers::Pair<MutSquarePtrMatrix<std::int64_t>, std::int64_t>;

auto nullSpace(MutDensePtrMatrix<std::int64_t> B,
               MutDensePtrMatrix<std::int64_t> A)
  -> MutDensePtrMatrix<std::int64_t>;
auto nullSpace(Arena<> *alloc, MutDensePtrMatrix<std::int64_t> A)
  -> MutDensePtrMatrix<std::int64_t>;

auto orthogonalize(IntMatrix<> A)
  -> containers::Pair<SquareMatrix<std::int64_t>, Vector<unsigned>>;

// Template and general functions
auto updateForNewRow(MutPtrMatrix<std::int64_t> A) -> std::ptrdiff_t;
void simplifySystemsImpl(std::array<MutPtrMatrix<std::int64_t>, 2> AB);
void reduceColumnStack(MutPtrMatrix<std::int64_t> A,
                       MutPtrMatrix<std::int64_t> B, std::ptrdiff_t c,
                       std::ptrdiff_t r);
auto simplifySystemImpl(MutPtrMatrix<std::int64_t> A,
                        std::ptrdiff_t colInit = 0) -> Row<>;
void simplifySystem(EmptyMatrix<std::int64_t>, std::ptrdiff_t = 0) {}
void simplifySystem(MutPtrMatrix<std::int64_t> &E, std::ptrdiff_t colInit = 0);
auto rank(Arena<> alloc, PtrMatrix<std::int64_t> A) -> std::ptrdiff_t;

template <MatrixDimension S0, MatrixDimension S1>
TRIVIAL constexpr void simplifySystem(MutArray<std::int64_t, S0> &A,
                                      MutArray<std::int64_t, S1> &B) {
  simplifySystemsImpl({A, B});
  if (Row newM = numNonZeroRows(A); newM < A.numRow()) {
    A.truncate(newM);
    B.truncate(newM);
  }
}

void hermite(MutPtrMatrix<std::int64_t> A, MutSquarePtrMatrix<std::int64_t> U);

// SIMD-optimized functions
auto zeroWithRowOp(MutPtrMatrix<std::int64_t> A, Row<> i, Row<> j, Col<> k,
                   std::int64_t f) -> std::int64_t;
void zeroWithRowOp(MutPtrMatrix<std::int64_t> A, Row<> i, Row<> j, Col<> k);

namespace detail {
void zeroSupDiagonal(MutPtrMatrix<std::int64_t> A,
                     MutSquarePtrMatrix<std::int64_t> K, std::ptrdiff_t i,
                     Row<> M, Col<> N);
void zeroSubDiagonal(MutPtrMatrix<std::int64_t> A,
                     MutSquarePtrMatrix<std::int64_t> K, std::ptrdiff_t k,
                     Row<> M, Col<> N);
auto pivotRowsPair(std::array<MutPtrMatrix<std::int64_t>, 2> AK, Col<> i,
                   Row<> M, Row<> piv) -> bool;
auto pivotColsPair(std::array<MutPtrMatrix<std::int64_t>, 2> AK, Row<> i,
                   Col<> N, Col<> piv) -> bool;
void dropCol(MutPtrMatrix<std::int64_t> A, std::ptrdiff_t i, Row<> M, Col<> N);
void zeroSupDiagonal(MutPtrMatrix<std::int64_t> A, Col<> c, Row<> r);
void zeroSupDiagonal(std::array<MutPtrMatrix<std::int64_t>, 2> AB, Col<> c,
                     Row<> r);
void reduceSubDiagonal(MutPtrMatrix<std::int64_t> A, Col<> c, Row<> r);
void reduceSubDiagonalStack(MutPtrMatrix<std::int64_t> A,
                            MutPtrMatrix<std::int64_t> B, std::ptrdiff_t c,
                            std::ptrdiff_t r);
void reduceSubDiagonal(std::array<MutPtrMatrix<std::int64_t>, 2> AB, Col<> c,
                       Row<> r);
void reduceColumn(MutPtrMatrix<std::int64_t> A, Col<> c, Row<> r);
void reduceColumn(std::array<MutPtrMatrix<std::int64_t>, 2> AB, Col<> c,
                  Row<> r);
void removeZeroRows(MutDensePtrMatrix<std::int64_t> &A);
void zeroWithRowOperation(MutPtrMatrix<std::int64_t> A, Row<> i, Row<> j,
                          Col<> k, Range<std::ptrdiff_t, std::ptrdiff_t> skip);
void zeroColumnPair(std::array<MutPtrMatrix<std::int64_t>, 2> AB, Col<> c,
                    Row<> r);
void zeroColumnPair(std::array<MutPtrMatrix<std::int64_t>, 2> AB, Row<> r,
                    Col<> c);
void zeroColumn(MutPtrMatrix<std::int64_t> A, Col<> c, Row<> r);
auto pivotRowsBareiss(MutPtrMatrix<std::int64_t> A, std::ptrdiff_t i, Row<> M,
                      Row<> piv) -> std::optional<std::ptrdiff_t>;
auto orthogonalizeBang(MutDensePtrMatrix<std::int64_t> &A)
  -> containers::Pair<SquareMatrix<std::int64_t>, Vector<unsigned>>;
} // namespace detail

} // namespace NormalForm

auto orthogonalize(Arena<> *alloc, MutDensePtrMatrix<std::int64_t> A)
  -> MutDensePtrMatrix<std::int64_t>;
auto orthogonalNullSpace(Arena<> *alloc, MutDensePtrMatrix<std::int64_t> A)
  -> MutDensePtrMatrix<std::int64_t>;

} // namespace math
