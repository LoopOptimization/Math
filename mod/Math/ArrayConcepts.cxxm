module;
#include "Macros.hxx"
export module ArrayConcepts;

export import MatDim;
import AxisTypes;
import BaseUtils;
import std;

export namespace math {

template <typename T> TRIVIAL constexpr auto view(const T &x) {
  if constexpr (requires(const T &y) {
                  { y.view() } -> utils::TriviallyCopyable;
                })
    return x.view();
  else return x;
}

template <typename T, typename S = utils::eltype_t<T>>
concept LinearlyIndexable = requires(T t, std::ptrdiff_t i) {
  { t[i] } -> std::convertible_to<S>;
};
template <typename T, typename S = utils::eltype_t<T>>
concept CartesianIndexable = requires(T t, std::ptrdiff_t i) {
  { t[i, i] } -> std::convertible_to<S>;
};
// The `OrConvertible` concepts are for expression templates
template <typename T, typename S>
concept LinearlyIndexableOrConvertible =
  LinearlyIndexable<T, S> || std::convertible_to<T, S>;
template <typename T, typename S>
concept CartesianIndexableOrConvertible =
  CartesianIndexable<T, S> || std::convertible_to<T, S>;

template <typename T>
concept DefinesSize = requires(T t) {
  { t.size() } -> std::convertible_to<std::ptrdiff_t>;
};

template <typename T>
concept DefinesShape = requires(T t) {
  { t.numRow() } -> std::convertible_to<Row<>>;
  { t.numCol() } -> std::convertible_to<Col<>>;
};

template <typename T>
concept ShapelessSize = DefinesSize<T> && (!DefinesShape<T>);
template <typename T>
concept PrimitiveScalar = std::integral<T> || std::floating_point<T>;

template <typename T> TRIVIAL constexpr auto numRows(const T &A) {
  if constexpr (DefinesShape<T>) return A.numRow();
  else return Row<1>{};
}
template <typename T> TRIVIAL constexpr auto numCols(const T &A) {
  if constexpr (DefinesShape<T>) return A.numCol();
  else if constexpr (ShapelessSize<T>) return col(A.size());
  else return Col<1>{};
}
TRIVIAL constexpr auto shape(const auto &x) {
  return CartesianIndex(unwrapRow(numRows(x)), unwrapCol(numCols(x)));
}

template <typename T>
concept LinearlyIndexableTensor =
  DefinesSize<T> && utils::HasEltype<T> && LinearlyIndexable<T>;

template <typename T>
concept RowVectorCore = LinearlyIndexableTensor<T> && requires(T t) {
  { numRows(t) } -> std::same_as<Row<1>>;
};
template <typename T>
concept ColVectorCore =
  LinearlyIndexableTensor<T> && !RowVectorCore<T> && requires(T t) {
    { numCols(t) } -> std::same_as<Col<1>>;
  };
template <typename T>
concept RowVector = RowVectorCore<T> && requires(T t) {
  { t.view() } -> RowVectorCore;
};

template <typename T>
concept ColVector = ColVectorCore<T> && requires(T t) {
  { t.view() } -> ColVectorCore;
};
template <typename T>
concept AbstractVector = RowVector<T> || ColVector<T>;

template <typename T>
concept AbstractMatrixCore =
  DefinesShape<T> && utils::HasEltype<T> && CartesianIndexable<T>;
template <typename T>
concept AbstractMatrix =
  AbstractMatrixCore<T> && !AbstractVector<T> && requires(T t) {
    { t.view() } -> AbstractMatrixCore;
  };

template <typename T>
concept AbstractTensor = AbstractVector<T> || AbstractMatrix<T>;

template <typename T>
concept HasDataPtr = requires(T t) {
  { t.data() } -> std::same_as<utils::eltype_t<T> *>;
};
template <typename T>
concept DenseTensor = AbstractTensor<T> && requires(T t) {
  { t.begin() } -> std::convertible_to<const utils::eltype_t<T> *>;
};

template <std::ptrdiff_t M> TRIVIAL constexpr auto transpose_dim(Col<M> c) {
  if constexpr (M == -1) return row(std::ptrdiff_t(c));
  else return Row<M>{};
}
template <std::ptrdiff_t M> TRIVIAL constexpr auto transpose_dim(Row<M> r) {
  if constexpr (M == -1) return col(std::ptrdiff_t(r));
  else return Col<M>{};
}

template <typename T, typename U> TRIVIAL constexpr auto reinterpret(U x) {
  if constexpr (std::same_as<T, U>) return x;
  else return x.template reinterpretImpl<T>();
}

// Layout optimization concepts for order-independent operations
template <typename T>
concept CanFlatten = requires {
  { std::remove_cvref_t<T>::can_flatten } -> std::same_as<const bool &>;
} && std::remove_cvref_t<T>::can_flatten;
template <typename T>
concept IsTransposed = requires {
  { std::remove_cvref_t<T>::is_transposed } -> std::same_as<const bool &>;
} && std::remove_cvref_t<T>::is_transposed;

// template <typename T>
// concept HasUntransposedView = requires(const T &t) { t.untransposed_view();
// };

// Default untransposed_view - assumes all types with view() also have
// untransposed_view()
template <typename T> TRIVIAL constexpr auto untransposed_view(const T &x) {
  if constexpr (IsTransposed<T>) return x.untransposed_view();
  else return view(x);
}

// Check if both arrays are transposed (useful for determining when to
// untranspose both)
template <typename... A> TRIVIAL constexpr auto are_all_transposed() -> bool {
  return (... && (IsTransposed<A> || !AbstractTensor<A>));
}

// Check if arrays can be flattened for linear operations after dimension
// checking
template <typename... A> TRIVIAL constexpr auto can_flatten_together() -> bool {
  return (... && (CanFlatten<A> || !AbstractTensor<A>));
}

// Get flattened view for operations that care about linear order (find_if())
template <typename T> TRIVIAL constexpr auto flatten_if_possible(const T &x) {
  if constexpr (CanFlatten<T>) return x.flatview();
  else return view(x);
}

} // namespace math
