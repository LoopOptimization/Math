module;
export module ArrayConcepts;

export import MatDim;
import AxisTypes;
import std;
export namespace math {

template <typename T, typename S = utils::eltype_t<T>>
concept LinearlyIndexable = requires(T t, std::ptrdiff_t i) {
  { t[i] } -> std::convertible_to<S>;
};
template <typename T, typename S = utils::eltype_t<T>>
concept CartesianIndexable = requires(T t, std::ptrdiff_t i) {
  { t[i, i] } -> std::convertible_to<S>;
};
// The `OrConvertible` concepts are for expression templates
template <typename T, typename S>
concept LinearlyIndexableOrConvertible =
  LinearlyIndexable<T, S> || std::convertible_to<T, S>;
template <typename T, typename S>
concept CartesianIndexableOrConvertible =
  CartesianIndexable<T, S> || std::convertible_to<T, S>;

template <typename T>
concept DefinesSize = requires(T t) {
  { t.size() } -> std::convertible_to<std::ptrdiff_t>;
};

template <typename T>
concept DefinesShape = requires(T t) {
  { t.numRow() } -> std::convertible_to<Row<>>;
  { t.numCol() } -> std::convertible_to<Col<>>;
};

template <typename T>
concept ShapelessSize = DefinesSize<T> && (!DefinesShape<T>);
template <typename T>
concept PrimitiveScalar = std::integral<T> || std::floating_point<T>;

template <typename T> constexpr auto numRows(const T &A) {
  if constexpr (DefinesShape<T>) return A.numRow();
  else return Row<1>{};
}
template <typename T> constexpr auto numCols(const T &A) {
  if constexpr (DefinesShape<T>) return A.numCol();
  else if constexpr (ShapelessSize<T>) return col(A.size());
  else return Col<1>{};
}
constexpr auto shape(const auto &x) {
  return CartesianIndex(unwrapRow(numRows(x)), unwrapCol(numCols(x)));
}

template <typename T>
concept LinearlyIndexableTensor =
  DefinesSize<T> && utils::HasEltype<T> && LinearlyIndexable<T>;

template <typename T>
concept RowVectorCore = LinearlyIndexableTensor<T> && requires(T t) {
  { numRows(t) } -> std::same_as<Row<1>>;
};
template <typename T>
concept ColVectorCore =
  LinearlyIndexableTensor<T> && !RowVectorCore<T> && requires(T t) {
    { numCols(t) } -> std::same_as<Col<1>>;
  };
template <typename T>
concept RowVector = RowVectorCore<T> && requires(T t) {
  { t.view() } -> RowVectorCore;
};
template <typename T>
concept ColVector = ColVectorCore<T> && requires(T t) {
  { t.view() } -> ColVectorCore;
};
template <typename T>
concept AbstractVector = RowVector<T> || ColVector<T>;

template <typename T>
concept AbstractMatrixCore =
  DefinesShape<T> && utils::HasEltype<T> && CartesianIndexable<T>;
template <typename T>
concept AbstractMatrix =
  AbstractMatrixCore<T> && !AbstractVector<T> && requires(T t) {
    { t.view() } -> AbstractMatrixCore;
  };

template <typename T>
concept AbstractTensor = AbstractVector<T> || AbstractMatrix<T>;

template <typename T>
concept HasDataPtr = requires(T t) {
  { t.data() } -> std::same_as<utils::eltype_t<T> *>;
};
template <typename T>
concept DenseTensor = AbstractTensor<T> && requires(T t) {
  { t.begin() } -> std::convertible_to<const utils::eltype_t<T> *>;
};

template <std::ptrdiff_t M> constexpr auto transpose_dim(Col<M> c) {
  if constexpr (M == -1) return row(std::ptrdiff_t(c));
  else return Row<M>{};
}
template <std::ptrdiff_t M> constexpr auto transpose_dim(Row<M> r) {
  if constexpr (M == -1) return col(std::ptrdiff_t(r));
  else return Col<M>{};
}

template <typename T, typename U> constexpr auto reinterpret(U x) {
  if constexpr (std::same_as<T, U>) return x;
  else return x.template reinterpretImpl<T>();
}

// Layout optimization concepts for order-independent operations
template <typename T>
concept CanFlatten = requires {
  { T::can_flatten } -> std::same_as<bool>;
} && T::can_flatten;

template <typename T>
concept HasUntransposedView = requires(const T &t) { t.untransposed_view(); };

// Default untransposed_view - assumes all types with view() also have
// untransposed_view()
template <typename T> constexpr auto untransposed_view(const T &x) {
  return x.untransposed_view();
}

// Check if arrays can be flattened for linear operations after dimension
// checking
template <typename A, typename B>
constexpr auto can_flatten_together() -> bool {
  return CanFlatten<A> && CanFlatten<B>;
}

// Get untransposed + flattened view for operations that don't care about layout
// (any(), dot())
template <typename T> constexpr auto layout_optimized_view(const T &x) {
  if constexpr (CanFlatten<T>) {
    auto untransposed = untransposed_view(x);
    if constexpr (requires { untransposed.flatview(); })
      return untransposed.flatview();
    else return untransposed.view();
  } else {
    return x.view();
  }
}

// Get flattened view for operations that care about linear order (find_if())
template <typename T> constexpr auto flatten_if_possible(const T &x) {
  if constexpr (CanFlatten<T>) {
    auto v = x.view();
    if constexpr (requires { v.flatview(); }) return v.flatview();
    else return v;
  } else {
    return x.view();
  }
}

} // namespace math
