module;

#include <cstdio>
export module CorePrint;
import BaseUtils;
import std;
export namespace utils {

struct TinyString {
  // 21 to allow for typemin<std::int64_t> + new-line char
  static constexpr std::ptrdiff_t n_elts = 21;
  char data_[n_elts];
  std::ptrdiff_t len_{};
  constexpr operator std::string_view() const {
    utils::assume(len_ >= 0 && len_ <= n_elts);
    return {data_, std::size_t(len_)};
  }
  constexpr auto begin() -> char * { return data_; }
  constexpr auto end() -> char * { return data_ + len_; }
  constexpr auto push_back(char x) -> TinyString & {
    utils::assume(len_ >= 0 && len_ < n_elts);
    data_[len_++] = x;
    return *this;
  }
  constexpr TinyString() = default;
  template <std::integral T> explicit constexpr TinyString(T x) {
    static constexpr int base = std::is_unsigned_v<T> ? 16 : 10;
    auto ec = std::to_chars(end(), lastValid(), x, base);
    if (ec.ec == std::errc::value_too_large) __builtin_trap();
    setLength(ec.ptr);
  }
  template <std::integral T> explicit constexpr TinyString(char a, T x) {
    static constexpr int base = std::is_unsigned_v<T> ? 16 : 10;
    push_back(a);
    auto ec = std::to_chars(end(), lastValid(), x, base);
    if (ec.ec == std::errc::value_too_large) __builtin_trap();
    setLength(ec.ptr);
  }
  template <std::integral T>
  explicit constexpr TinyString(char a, char b, T x) {
    static constexpr int base = std::is_unsigned_v<T> ? 16 : 10;
    push_back(a).push_back(b);
    auto ec = std::to_chars(end(), lastValid(), x, base);
    if (ec.ec == std::errc::value_too_large) __builtin_trap();
    setLength(ec.ptr);
  }
  template <std::integral T>
  explicit constexpr TinyString(char a, char b, char c, T x) {
    static constexpr int base = std::is_unsigned_v<T> ? 16 : 10;
    push_back(a).push_back(b).push_back(c);
    auto ec = std::to_chars(end(), lastValid(), x, base);
    if (ec.ec == std::errc::value_too_large) __builtin_trap();
    setLength(ec.ptr);
  }
  explicit constexpr TinyString(const void *ptr)
    : TinyString('0', 'x', std::bit_cast<std::uintptr_t>(ptr)) {}
  explicit constexpr TinyString(char a, const void *ptr)
    : TinyString(a, '0', 'x', std::bit_cast<std::uintptr_t>(ptr)) {}
  explicit constexpr TinyString(double x) {
    setLength(std::to_chars(begin(), lastValid(), x).ptr);
  }

private:
  constexpr void setLength(const char *end_ptr) { len_ = end_ptr - data_; }
  constexpr auto lastValid() -> char * { return data_ + n_elts - 1; }
};

// Concept for objects with a .print() member function
template <typename T>
concept HasPrintMethod = requires(const T &x) {
  { x.print() } -> std::same_as<void>;
};

inline void flush() {
  [[maybe_unused]] int erc = std::fflush(stdout);
#ifndef NDEBUG
  if (erc) __builtin_trap();
#endif
}
inline void print(char c) { std::putchar(c); }
inline void println(char c) { std::putchar(c), std::putchar('\n'); }
inline void print(std::string_view s) {
  std::fwrite(s.data(), 1, s.size(), stdout);
}
inline void print(TinyString s) { print(std::string_view{s}); }
inline void println(std::string_view s) { print(s), std::putchar('\n'); }
inline void println(TinyString s) {
  print(std::string_view{s.push_back('\n')});
}
inline void println() { std::putchar('\n'); }

inline void print(std::integral auto x) {
  // if (__builtin_constant_p(x)) {
  if constexpr (std::same_as<decltype(x), bool>) std::putchar('0' + x);
  else if (x >= 0 && x < 10) std::putchar('0' + x);
  else print(TinyString{x});
}
inline void print(std::floating_point auto x) { print(TinyString{x}); }

// Print function for types with .print() member function
template <HasPrintMethod T> inline void print(const T &x) { x.print(); }

// Println variants
template <typename T>
inline void println(const T &x)
  requires(std::integral<T> || std::floating_point<T>) {
  print(TinyString(x).push_back('\n'));
}

template <HasPrintMethod T> inline void println(const T &x) {
  x.print();
  print('\n');
}

template <typename T> inline void print(T x) requires(std::is_enum_v<T>) {
  print(std::to_underlying(x));
}
template <typename T> inline void println(T x) requires(std::is_enum_v<T>) {
  println(std::to_underlying(x));
}

// Variadic print functions using const references
template <typename... Args>
inline void print(const auto &x, const auto &y, const Args &...z) {
  print(x);
  print(y);
  (print(z), ...);
}

template <typename... Args>
inline void println(const auto &x, const auto &y, const Args &...z) {
  print(x); // pop off first
  // the branch halves the number of recursive calls vs `println(y, z...)`
  if constexpr (sizeof...(z)) {
    print(y);
    println(z...); // recurse
  } else println(y);
}

template <typename T>
concept Printable = requires(const T &x) {
  { ::utils::print(x) };
  { ::utils::println(x) };
};

} // namespace utils
