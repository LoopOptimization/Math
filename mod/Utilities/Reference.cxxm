module;
#include "Macros.hxx"
export module CompressReference;

import TypeCompression;
import std;
export namespace utils {
template <typename T> struct Reference {
  using C = utils::compressed_t<T>;
  static_assert(!std::same_as<C, T>);
  C *c_;
  TRIVIAL constexpr operator T() const { return T::decompress(c_); }
  TRIVIAL constexpr auto view() const -> T { return T::decompress(c_); }
  // constexpr operator T &() const { return *t; }
  TRIVIAL constexpr auto operator=(const T &t) -> Reference & {
    t.compress(c_);
    return *this;
  }
  TRIVIAL constexpr auto operator=(const C &x) -> Reference & {
    // Probably shouldn't be needed?
    // TODO: try removing this method
    *c_ = x;
    return *this;
  }
  TRIVIAL constexpr auto operator==(const T &t) const -> bool {
    return T::decompress(c_) == t;
  }
  TRIVIAL constexpr auto operator+=(const auto &x) {
    T y{T::decompress(c_)};
    y += x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator-=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y -= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator*=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y *= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator/=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y /= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator%=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y %= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator<<=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y <<= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator>>=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y >>= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator&=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y &= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator^=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y ^= x;
    y.compress(c_);
    return y;
    // return *this;
  }
  TRIVIAL constexpr auto operator|=(const auto &x) {
    // -> Reference & {
    T y{T::decompress(c_)};
    y |= x;
    y.compress(c_);
    return y;
    // return *this;
  }

  TRIVIAL constexpr auto operator[](auto i) -> decltype(auto) {
    return c_->operator[](i);
  }
  TRIVIAL constexpr auto operator[](auto i) const -> decltype(auto) {
    return c_->operator[](i);
  }
  TRIVIAL constexpr auto operator[](auto i, auto j) -> decltype(auto) {
    return c_->operator[](i, j);
  }
  TRIVIAL constexpr auto operator[](auto i, auto j) const -> decltype(auto) {
    return c_->operator[](i, j);
  }

private:
  // TODO: are these really needed / can we rely on implicit conversion?
  TRIVIAL friend constexpr auto operator+(Reference x, const auto &y) {
    return T::decompress(x.c_) + y;
  }
  TRIVIAL friend constexpr auto operator-(Reference x, const auto &y) {
    return T::decompress(x.c_) - y;
  }
  TRIVIAL friend constexpr auto operator*(Reference x, const auto &y) {
    return T::decompress(x.c_) * y;
  }
  TRIVIAL friend constexpr auto operator/(Reference x, const auto &y) {
    return T::decompress(x.c_) / y;
  }
  TRIVIAL friend constexpr auto operator%(Reference x, const auto &y) {
    return T::decompress(x.c_) % y;
  }
  TRIVIAL friend constexpr auto operator>>(Reference x, const auto &y) {
    return T::decompress(x.c_) >> y;
  }
  TRIVIAL friend constexpr auto operator<<(Reference x, const auto &y) {
    return T::decompress(x.c_) << y;
  }
  TRIVIAL friend constexpr auto operator&(Reference x, const auto &y) {
    return T::decompress(x.c_) & y;
  }
  TRIVIAL friend constexpr auto operator^(Reference x, const auto &y) {
    return T::decompress(x.c_) ^ y;
  }
  TRIVIAL friend constexpr auto operator|(Reference x, const auto &y) {
    return T::decompress(x.c_) | y;
  }
  TRIVIAL friend constexpr auto operator>(Reference x, const auto &y) {
    return T::decompress(x.c_) > y;
  }
  TRIVIAL friend constexpr auto operator>=(Reference x, const auto &y) {
    return T::decompress(x.c_) >= y;
  }
  TRIVIAL friend constexpr auto operator<(Reference x, const auto &y) {
    return T::decompress(x.c_) < y;
  }
  TRIVIAL friend constexpr auto operator<=(Reference x, const auto &y) {
    return T::decompress(x.c_) <= y;
  }
  TRIVIAL friend constexpr auto operator==(Reference x, const auto &y) {
    return T::decompress(x.c_) == y;
  }
  TRIVIAL friend constexpr auto operator!=(Reference x, const auto &y) {
    return T::decompress(x.c_) != y;
  }
  TRIVIAL friend constexpr auto operator+(const auto &x, Reference y) {
    return x + T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator-(const auto &x, Reference y) {
    return x - T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator*(const auto &x, Reference y) {
    return x * T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator/(const auto &x, Reference y) {
    return x / T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator%(const auto &x, Reference y) {
    return x % T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator>>(const auto &x, Reference y) {
    return x >> T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator<<(const auto &x, Reference y) {
    return x << T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator&(const auto &x, Reference y) {
    return x & T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator^(const auto &x, Reference y) {
    return x ^ T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator|(const auto &x, Reference y) {
    return x | T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator<(const auto &x, Reference y) {
    return x < T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator<=(const auto &x, Reference y) {
    return x <= T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator>(const auto &x, Reference y) {
    return x > T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator>=(const auto &x, Reference y) {
    return x >= T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator==(const auto &x, Reference y) {
    return x == T::decompress(y.c_);
  }
  TRIVIAL friend constexpr auto operator!=(const auto &x, Reference y) {
    return x != T::decompress(y.c_);
  }
  TRIVIAL friend constexpr void swap(Reference x, Reference y) {
    std::swap(*x.c_, *y.c_);
  }
  TRIVIAL friend constexpr auto value(Reference x) {
    using math::value;
    if constexpr (requires(C *cc) { cc->value(); }) return value(x.c_->value());
    else return value(*x.c_);
  }
  TRIVIAL friend constexpr auto extractvalue(Reference x) {
    using math::extractvalue;
    if constexpr (requires(C *cc) { cc->value(); })
      return extractvalue(x.c_->value());
    else return extractvalue(*x.c_);
  }
};

template <typename T>
TRIVIAL constexpr auto ref(T *p, std::ptrdiff_t i) -> T & {
  return p[i];
}
template <typename T>
TRIVIAL constexpr auto ref(const T *p, std::ptrdiff_t i) -> const T & {
  return p[i];
}
template <utils::Compressible T>
TRIVIAL constexpr auto ref(utils::compressed_t<T> *p, std::ptrdiff_t i)
  -> Reference<T> {
  return Reference<T>{p + i};
}

template <utils::Compressible T>
TRIVIAL constexpr auto ref(const utils::compressed_t<T> *p, std::ptrdiff_t i)
  -> T {
  return T::decompress(p + i);
}

} // namespace utils
