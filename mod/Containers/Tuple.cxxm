module;
#include "Macros.hxx"
export module Tuple;
import std;
export namespace containers {

template <typename... Ts> struct Tuple;
template <typename T, typename... Ts>
TRIVIAL constexpr auto cattuple(T, Tuple<Ts...>) -> Tuple<T, Ts...>;

template <typename T, typename... Ts, typename U, typename... Us>
TRIVIAL constexpr void copyFrom(Tuple<T, Ts...> &dst,
                                const Tuple<U, Us...> &src)
  requires(sizeof...(Ts) == sizeof...(Us) && std::assignable_from<T, U> &&
           (... && std::assignable_from<Ts, Us>)) {
  dst = src;
}
template <typename... Ts> struct Tuple {
  static_assert(false, "should be able to instantiate the primary template.");
};
template <typename... Ts>
TRIVIAL constexpr auto tuple(Ts... x) -> Tuple<std::remove_cvref_t<Ts>...> {
  return {x...};
}
template <typename T> struct Tuple<T> {
  [[no_unique_address]] T _0;
  // TRIVIAL constexpr Tuple() = default;
  // TRIVIAL constexpr Tuple(T _0_) : _0(_0_){};
  // TRIVIAL constexpr Tuple(const Tuple &) = default;
  template <std::size_t I> TRIVIAL constexpr auto get() -> T & {
    static_assert(I == 0);
    return _0;
  }
  template <std::size_t I>
  TRIVIAL [[nodiscard]] constexpr auto get() const -> const T & {
    static_assert(I == 0);
    return _0;
  }
  // TRIVIAL constexpr auto operator=(const Tuple &) -> Tuple & = default;
  // TRIVIAL constexpr auto operator=(Tuple &&) -> Tuple & = default;
  TRIVIAL constexpr void apply(const auto &f) { f(_0); }
  template <typename U>
  TRIVIAL constexpr void apply(const Tuple<U> &x, const auto &f) {
    f(_0, x._0);
  }
  TRIVIAL constexpr auto mutmap(const auto &f) -> Tuple<decltype(f(_0))> {
    return {f(_0)};
  }
  TRIVIAL constexpr auto map(const auto &f) const -> Tuple<decltype(f(_0))> {
    return {f(_0)};
  }
  template <typename U>
  TRIVIAL constexpr auto map(const Tuple<U> &x, const auto &f) const
    -> Tuple<decltype(f(_0, x._0))> {
    return {f(_0, x._0)};
  }
  template <typename U0, typename U1>
  TRIVIAL constexpr auto map_reduce(const Tuple<U0, U1> &x, const auto &f,
                                    const auto &) const {
    return f(_0, x._0);
  }
  template <typename U> TRIVIAL constexpr void operator+=(const Tuple<U> &);
  template <typename U> TRIVIAL constexpr void operator-=(const Tuple<U> &);
  template <typename U> TRIVIAL constexpr void operator*=(const Tuple<U> &);
  template <typename U> TRIVIAL constexpr void operator/=(const Tuple<U> &);

  template <typename U>
  TRIVIAL constexpr auto operator=(Tuple<U> x)
    -> Tuple & requires((!std::same_as<T, U>) && std::is_assignable_v<T, U>) {
    _0 = std::move(x._0);
    return *this;
  }

private:
  template <typename U>
  TRIVIAL friend constexpr void operator<<(Tuple<T> &dst, const Tuple<U> &src) {
    dst << src;
  }
  template <typename U>
  TRIVIAL friend constexpr void operator<<(Tuple<T> &&dst,
                                           const Tuple<U> &src) {
    dst << src;
  }
};
template <typename T0, typename T1> struct Tuple<T0, T1> {
  [[no_unique_address]] T0 _0;
  [[no_unique_address]] T1 _1;
  // TRIVIAL constexpr Tuple() = default;
  // TRIVIAL constexpr Tuple(const Tuple &) = default;
  // TRIVIAL constexpr auto operator=(const Tuple &) -> Tuple & = default;
  // TRIVIAL constexpr auto operator=(Tuple &&) -> Tuple & = default;
  // TRIVIAL constexpr Tuple(T0 _0_, T1 _1_) : _0(_0_), _1(_1_){};

  template <std::size_t I> TRIVIAL constexpr auto get() -> auto & {
    static_assert(I < 2);
    if constexpr (I == 0) return _0;
    else return _1;
  }
  template <std::size_t I>
  TRIVIAL [[nodiscard]] constexpr auto get() const -> const auto & {
    static_assert(I < 2);
    if constexpr (I == 0) return _0;
    else return _1;
  }
  TRIVIAL constexpr void apply(const auto &f) {
    f(_0);
    f(_1);
  }
  template <typename U0, typename U1>
  TRIVIAL constexpr void apply(const Tuple<U0, U1> &x, const auto &f) {
    f(_0, x._0);
    f(_1, x._1);
  }
  TRIVIAL constexpr auto mutmap(const auto &f) { return tuple(f(_0), f(_1)); }
  TRIVIAL constexpr auto map(const auto &f) const {
    return tuple(f(_0), f(_1));
  }
  template <typename U0, typename U1>
  TRIVIAL constexpr void map(const Tuple<U0, U1> &x, const auto &f) const {
    return tuple(f(_0, x._0), f(_1, x._1));
  }
  template <typename U0, typename U1>
  TRIVIAL constexpr auto map_reduce(const Tuple<U0, U1> &x, const auto &f,
                                    const auto &op) const {
    return op(f(_0, x._0), f(_1, x._1));
  }
  template <typename U0, typename U1>
  TRIVIAL [[gnu::flatten]] constexpr void operator+=(const Tuple<U0, U1> &src) {
    copyFrom(*this, tuple(_0 + src._0, _1 + src._1));
  }
  template <typename U0, typename U1>
  TRIVIAL [[gnu::flatten]] constexpr void operator-=(const Tuple<U0, U1> &src) {
    copyFrom(*this, tuple(_0 - src._0, _1 - src._1));
  }
  template <typename U0, typename U1>
  TRIVIAL [[gnu::flatten]] constexpr void operator*=(const Tuple<U0, U1> &src) {
    copyFrom(*this, tuple(_0 * src._0, _1 * src._1));
  }
  template <typename U0, typename U1>
  TRIVIAL [[gnu::flatten]] constexpr void operator/=(const Tuple<U0, U1> &src) {
    copyFrom(*this, tuple(_0 / src._0, _1 / src._1));
  }

  template <typename U0, typename U1>
  TRIVIAL constexpr auto operator=(Tuple<U0, U1> x)
    -> Tuple & requires(std::is_assignable_v<T0, U0> &&
                        std::is_assignable_v<T1, U1>) {
    _0 = std::move(x._0);
    _1 = std::move(x._1);
    return *this;
  }

  template <typename U0, typename U1>
  TRIVIAL constexpr void operator<<(const Tuple<U0, U1> &src) {
    copyFrom(*this, src);
  }
};

template <typename T0, typename T1> using Pair = Tuple<T0, T1>;

template <typename T0, typename T1, typename T2> struct Tuple<T0, T1, T2> {
  [[no_unique_address]] T0 _0;
  [[no_unique_address]] T1 _1;
  [[no_unique_address]] T2 _2;
  // TRIVIAL constexpr Tuple() = default;
  // TRIVIAL constexpr Tuple(const Tuple &) = default;
  // TRIVIAL constexpr auto operator=(const Tuple &) -> Tuple & = default;
  // TRIVIAL constexpr auto operator=(Tuple &&) -> Tuple & = default;
  // TRIVIAL constexpr Tuple(T0 _0_, T1 _1_, T2 _2_) : _0(_0_), _1(_1_),
  // _2(_2_){};

  template <std::size_t I> TRIVIAL constexpr auto get() -> auto & {
    static_assert(I < 3);
    if constexpr (I == 0) return _0;
    else if constexpr (I == 1) return _1;
    else return _2;
  }
  template <std::size_t I> TRIVIAL constexpr auto get() const -> const auto & {
    static_assert(I < 3);
    if constexpr (I == 0) return _0;
    else if constexpr (I == 1) return _1;
    else return _2;
  }
  TRIVIAL constexpr void apply(const auto &f) {
    f(_0);
    f(_1);
    f(_2);
  }
  template <typename U0, typename U1, typename U2>
  TRIVIAL constexpr void apply(const Tuple<U0, U1, U2> &x, const auto &f) {
    f(_0, x._0);
    f(_1, x._1);
    f(_2, x._2);
  }
  TRIVIAL constexpr auto mutmap(const auto &f) {
    return tuple(f(_0), f(_1), f(_2));
  }
  TRIVIAL constexpr auto map(const auto &f) const {
    return tuple(f(_0), f(_1), f(_2));
  }
  template <typename U0, typename U1, typename U2>
  TRIVIAL constexpr void map(const Tuple<U0, U1, U2> &x, const auto &f) const {
    return tuple(f(_0, x._0), f(_1, x._1), f(_2, x._2));
  }
  template <typename U0, typename U1, typename U2>
  TRIVIAL constexpr auto map_reduce(const Tuple<U0, U1, U2> &x, const auto &f,
                                    const auto &op) const {
    return op(op(f(_0, x._0), f(_1, x._1)), f(_2, x._2));
  }
  template <typename U0, typename U1, typename U2>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator+=(const Tuple<U0, U1, U2> &src) {
    copyFrom(*this, tuple(_0 + src._0, _1 + src._1, _2 + src._2));
  }
  template <typename U0, typename U1, typename U2>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator-=(const Tuple<U0, U1, U2> &src) {
    copyFrom(*this, tuple(_0 - src._0, _1 - src._1, _2 - src._2));
  }
  template <typename U0, typename U1, typename U2>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator*=(const Tuple<U0, U1, U2> &src) {
    copyFrom(*this, tuple(_0 * src._0, _1 * src._1, _2 * src._2));
  }
  template <typename U0, typename U1, typename U2>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator/=(const Tuple<U0, U1, U2> &src) {
    copyFrom(*this, tuple(_0 / src._0, _1 / src._1, _2 / src._2));
  }

  template <typename U0, typename U1, typename U2>
  TRIVIAL constexpr auto operator=(Tuple<U0, U1, U2> x)
    -> Tuple & requires(std::is_assignable_v<T0, U0> &&
                        std::is_assignable_v<T1, U1> &&
                        std::is_assignable_v<T2, U2>) {
    _0 = std::move(x._0);
    _1 = std::move(x._1);
    _2 = std::move(x._2);
    return *this;
  }

  template <typename U0, typename U1, typename U2>
  TRIVIAL constexpr void operator<<(const Tuple<U0, U1, U2> &src) {
    copyFrom(*this, src);
  }
};

template <typename T0, typename T1, typename T2, typename T3>
struct Tuple<T0, T1, T2, T3> {
  [[no_unique_address]] T0 _0;
  [[no_unique_address]] T1 _1;
  [[no_unique_address]] T2 _2;
  [[no_unique_address]] T3 _3;
  // TRIVIAL constexpr Tuple() = default;
  // TRIVIAL constexpr Tuple(const Tuple &) = default;
  // TRIVIAL constexpr auto operator=(const Tuple &) -> Tuple & = default;
  // TRIVIAL constexpr auto operator=(Tuple &&) -> Tuple & = default;
  // TRIVIAL constexpr Tuple(T0 _0_, T1 _1_, T2 _2_, T3 _3_)
  //   : _0(_0_), _1(_1_), _2(_2_), _3(_3_){};

  template <std::size_t I> TRIVIAL constexpr auto get() -> auto & {
    static_assert(I < 4);
    if constexpr (I == 0) return _0;
    else if constexpr (I == 1) return _1;
    else if constexpr (I == 2) return _2;
    else return _3;
  }
  template <std::size_t I> TRIVIAL constexpr auto get() const -> const auto & {
    static_assert(I < 4);
    if constexpr (I == 0) return _0;
    else if constexpr (I == 1) return _1;
    else if constexpr (I == 2) return _2;
    else return _3;
  }
  TRIVIAL constexpr void apply(const auto &f) {
    f(_0);
    f(_1);
    f(_2);
    f(_3);
  }
  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL constexpr void apply(const Tuple<U0, U1, U2, U3> &x, const auto &f) {
    f(_0, x._0);
    f(_1, x._1);
    f(_2, x._2);
    f(_3, x._3);
  }
  TRIVIAL constexpr auto mutmap(const auto &f) {
    return tuple(f(_0), f(_1), f(_2), f(_3));
  }
  TRIVIAL constexpr auto map(const auto &f) const {
    return tuple(f(_0), f(_1), f(_2), f(_3));
  }
  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL constexpr void map(const Tuple<U0, U1, U2, U3> &x,
                             const auto &f) const {
    return tuple(f(_0, x._0), f(_1, x._1), f(_2, x._2), f(_3, x._3));
  }
  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL constexpr auto map_reduce(const Tuple<U0, U1, U2, U3> &x,
                                    const auto &f, const auto &op) const {
    return op(op(f(_0, x._0), f(_1, x._1)), op(f(_2, x._2), f(_3, x._3)));
  }
  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator+=(const Tuple<U0, U1, U2, U3> &src) {
    copyFrom(*this, tuple(_0 + src._0, _1 + src._1, _2 + src._2, _3 + src._3));
  }
  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator-=(const Tuple<U0, U1, U2, U3> &src) {
    copyFrom(*this, tuple(_0 - src._0, _1 - src._1, _2 - src._2, _3 - src._3));
  }
  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator*=(const Tuple<U0, U1, U2, U3> &src) {
    copyFrom(*this, tuple(_0 * src._0, _1 * src._1, _2 * src._2, _3 * src._3));
  }
  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator/=(const Tuple<U0, U1, U2, U3> &src) {
    copyFrom(*this, tuple(_0 / src._0, _1 / src._1, _2 / src._2, _3 / src._3));
  }

  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL constexpr auto operator=(Tuple<U0, U1, U2, U3> x)
    -> Tuple & requires(std::is_assignable_v<T0, U0> &&
                        std::is_assignable_v<T1, U1> &&
                        std::is_assignable_v<T2, U2> &&
                        std::is_assignable_v<T3, U3>) {
    _0 = std::move(x._0);
    _1 = std::move(x._1);
    _2 = std::move(x._2);
    _3 = std::move(x._3);
    return *this;
  }

  template <typename U0, typename U1, typename U2, typename U3>
  TRIVIAL constexpr void operator<<(const Tuple<U0, U1, U2, U3> &src) {
    copyFrom(*this, src);
  }
};

template <typename T0, typename T1, typename T2, typename T3, typename T4,
          typename... Ts>
struct Tuple<T0, T1, T2, T3, T4, Ts...> {
  [[no_unique_address]] T0 _0;
  [[no_unique_address]] T1 _1;
  [[no_unique_address]] T2 _2;
  [[no_unique_address]] T3 _3;
  [[no_unique_address]] Tuple<T4, Ts...> tail_;
  TRIVIAL constexpr Tuple() = default;
  // template <std::convertible_to<T> U, std::convertible_to<Ts>... Us>
  // TRIVIAL constexpr Tuple(U head, Us... tail)
  //   : head_(std::forward<U>(head)), tail_(std::forward<Us>(tail)...){};
  TRIVIAL constexpr Tuple(T0 _0_, T1 _1_, T2 _2_, T3 _3_, T4 _4_, Ts... tail)
    : _0(_0_), _1(_1_), _2(_2_), _3(_3_), tail_(_4_, tail...){};

  TRIVIAL constexpr Tuple(const Tuple &) = default;
  template <std::size_t I> TRIVIAL constexpr auto get() -> auto & {
    if constexpr (I == 0) return _0;
    else if constexpr (I == 1) return _1;
    else if constexpr (I == 2) return _2;
    else if constexpr (I == 3) return _3;
    else if constexpr (I == 4) return tail_._0;
    else if constexpr (I == 5) return tail_._1;
    else if constexpr (I == 6) return tail_._2;
    else if constexpr (I == 7) return tail_._3;
    else return tail_.tail_.template get<I - 8>();
  }
  template <std::size_t I>
  TRIVIAL [[nodiscard]] constexpr auto get() const -> const auto & {
    if constexpr (I == 0) return _0;
    else if constexpr (I == 1) return _1;
    else if constexpr (I == 2) return _2;
    else if constexpr (I == 3) return _3;
    else if constexpr (I == 4) return tail_._0;
    else if constexpr (I == 5) return tail_._1;
    else if constexpr (I == 6) return tail_._2;
    else if constexpr (I == 7) return tail_._3;
    else return tail_.tail_.template get<I - 8>();
  }
  TRIVIAL constexpr void apply(const auto &f) {
    f(_0);
    f(_1);
    f(_2);
    f(_3);
    tail_.apply(f);
  }
  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL constexpr void apply(const Tuple<U0, U1, U2, U3, U4, Us...> &x,
                               const auto &f)
    requires(sizeof...(Ts) == sizeof...(Us)) {
    f(_0, x._0);
    f(_1, x._1);
    f(_2, x._2);
    f(_3, x._3);
    tail_.apply(x.tail_, f);
  }
  TRIVIAL constexpr auto mutmap(const auto &f) {
    return cattuple(f(_0), f(_1), f(_2), f(_3), tail_.mutmap(f));
  }
  TRIVIAL constexpr auto map(const auto &f) const {
    return cattuple(f(_0), f(_1), f(_2), f(_3), tail_.map(f));
  }
  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL constexpr auto map(const Tuple<U0, U1, U2, U3, U4, Us...> &x,
                             const auto &f) const
    requires(sizeof...(Ts) == sizeof...(Us)) {
    return cattuple(f(_0, x._0), f(_1, x._1), f(_2, x._2), f(_3, x._3),
                    tail_.map(x.tail_, f));
  }
  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL constexpr auto map_reduce(const Tuple<U0, U1, U2, U3, U4, Us...> &x,
                                    const auto &f, const auto &op) const
    requires(sizeof...(Ts) == sizeof...(Us)) {
    return op(op(op(f(_0, x._0), f(_1, x._1)), op(f(_2, x._2), f(_3, x._3))),
              tail_.map_reduce(x.tail_, f, op));
  }

  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator+=(const Tuple<U0, U1, U2, U3, U4, Us...> &src)
    requires(sizeof...(Ts) == sizeof...(Us)) {
    (*this) << map(src, [](const auto &d, const auto &s) { return d + s; });
  }
  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator-=(const Tuple<U0, U1, U2, U3, U4, Us...> &src)
    requires(sizeof...(Ts) == sizeof...(Us)) {
    (*this) << map(src, [](const auto &d, const auto &s) { return d - s; });
  }
  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator*=(const Tuple<U0, U1, U2, U3, U4, Us...> &src)
    requires(sizeof...(Ts) == sizeof...(Us)) {
    (*this) << map(src, [](const auto &d, const auto &s) { return d * s; });
  }
  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL [[gnu::flatten]] constexpr void
  operator/=(const Tuple<U0, U1, U2, U3, U4, Us...> &src)
    requires(sizeof...(Ts) == sizeof...(Us)) {
    (*this) << map(src, [](const auto &d, const auto &s) { return d / s; });
  }
  TRIVIAL constexpr auto operator=(const Tuple &) -> Tuple & = default;
  TRIVIAL constexpr auto operator=(Tuple &&) -> Tuple & = default;
  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL constexpr auto operator=(Tuple<U0, U1, U2, U3, U4, Us...> x)
    -> Tuple & requires((std::is_assignable_v<T0, U0> &&
                         std::is_assignable_v<T1, U1> &&
                         std::is_assignable_v<T2, U2> &&
                         std::is_assignable_v<T3, U3> &&
                         std::is_assignable_v<T4, U4>) &&
                        ... && std::is_assignable_v<Ts, Us>) {
    _0 = std::move(x._0);
    _1 = std::move(x._1);
    _2 = std::move(x._2);
    _3 = std::move(x._3);
    tail_ = std::move(x.tail_);
    return *this;
  }

  template <typename U0, typename U1, typename U2, typename U3, typename U4,
            typename... Us>
  TRIVIAL constexpr void operator<<(const Tuple<U0, U1, U2, U3, U4, Us...> &src)
    requires(sizeof...(Ts) == sizeof...(Us)) {
    copyFrom(*this, src);
  }

private:
  TRIVIAL constexpr Tuple(T0 _0_, T1 _1_, T2 _2_, T3 _3_, Tuple<T4, Ts...> tail)
    : _0(_0_), _1(_1_), _2(_2_), _3(_3_), tail_(tail){};
};
template <typename T, typename... Ts>
TRIVIAL constexpr auto cattuple(T x, Tuple<Ts...> y) -> Tuple<T, Ts...> {
  return {x, y};
}

template <typename... Ts> Tuple(Ts...) -> Tuple<Ts...>;

template <typename T> struct Add {
  T &x_;
  TRIVIAL constexpr auto operator=(T y) -> Add & {
    x_ += y;
    return *this;
  }
};
template <typename T> struct And {
  T &x_;
  TRIVIAL constexpr auto operator=(T y) -> And & {
    x_ &= y;
    return *this;
  }
};
template <typename T> struct Or {
  T &x_;
  TRIVIAL constexpr auto operator=(T y) -> Or & {
    x_ |= y;
    return *this;
  }
};
template <typename T> struct Max {
  T &x_;
  TRIVIAL constexpr auto operator=(T y) -> Max & {
    x_ = x_ >= y ? x_ : y;
    // x_ = std::max(x_, y);
    return *this;
  }
};
template <typename T> struct Min {
  T &x_;
  TRIVIAL constexpr auto operator=(T y) -> Min & {
    x_ = x_ >= y ? y : x_;
    // x_ = std::min(x_, y);
    return *this;
  }
};
inline constexpr struct IgnoreImpl {
  // NOLINTNEXTLINE
  TRIVIAL constexpr auto operator=(const auto &) const -> const IgnoreImpl & {
    return *this;
  }
} Ignore;

template <typename... Ts>
TRIVIAL constexpr auto tie(Ts &&...x) -> Tuple<Ts...> {
  return {x...};
}

// template <typename F, typename S>
// using Pair = Tuple<F,S>;

} // namespace containers

template <typename T, typename... Ts>
struct std::tuple_size<containers::Tuple<T, Ts...>>
  : public std::integral_constant<std::size_t, 1 + sizeof...(Ts)> {};

template <typename T, typename... Ts>
struct std::tuple_element<0, containers::Tuple<T, Ts...>> {
  using type = T;
};
template <std::size_t I, typename T, typename... Ts>
struct std::tuple_element<I, containers::Tuple<T, Ts...>> {
  using type = std::tuple_element_t<I - 1, containers::Tuple<Ts...>>;
};
