module;
#include "Macros.hxx"
#include "Owner.hxx"
export module TinyVector;
import ArrayPrint;
import AxisTypes;
import CorePrint;
import BaseUtils;
import MatDim;
import Storage;
import std;
export namespace containers {
using utils::invariant;

template <class T, std::size_t N, std::signed_integral L = std::ptrdiff_t>
class MATH_GSL_OWNER TinyVector {
  static_assert(N > 0);
  static_assert(std::numeric_limits<std::ptrdiff_t>::max() >= N);
  using Length = math::Length<-1, L>;
  Storage<T, N> data_;
  Length len_{};

public:
  using value_type = T;
  using reference = T &;

  void print() const requires(utils::Printable<T>) {
    using ::utils::print;
    ::utils::print('[');
    if constexpr (std::same_as<T, std::int8_t> ||
                  std::same_as<T, std::uint8_t>) {
      if (!empty()) print(int((*this)[0]));
      for (L i = 1; i < size(); ++i) print(", ", int((*this)[i]));
    } else {
      if (!empty()) print((*this)[0]);
      for (L i = 1; i < size(); ++i) print(", ", (*this)[i]);
    }
    ::utils::print("]");
  }
  TRIVIAL constexpr TinyVector(){}; // NOLINT (modernize-use-equals-default)
  TRIVIAL constexpr TinyVector(const std::initializer_list<T> &list)
    : len_{math::length(L(list.size()))} {
    invariant(list.size() <= N);
    if constexpr (Storage<T, N>::trivial)
      std::copy_n(list.begin(), size(), data_.data());
    else std::uninitialized_move_n(list.begin(), size(), data_.data());
  }
  TRIVIAL constexpr TinyVector(T t) : len_{math::length(L(1))} {
    std::construct_at(data_.data(), std::move(t));
  }

  constexpr auto operator=(const std::initializer_list<T> &list)
    -> TinyVector & {
    invariant(list.size() <= std::ptrdiff_t(N));
    std::ptrdiff_t slen = std::ssize(list), old_len = size();
    len_ = math::length(L(slen));
    auto I = list.begin();
    if constexpr (Storage<T, N>::trivial) {
      // implicit lifetime type
      std::copy_n(I, slen, data_.data());
    } else {
      std::ptrdiff_t J = std::min(slen, old_len);
      // old values exist
      std::move(I, I + J, data_.data());
      if (old_len < len_) {
        std::uninitialized_move_n(I + old_len, slen - old_len,
                                  data_.data() + old_len);
      } else if constexpr (!std::is_trivially_destructible_v<T>)
        if (old_len > len_) std::destroy_n(data_.data() + slen, old_len - slen);
    }
    return *this;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) -> T & {
    invariant(i < len_);
    return data_.data()[i];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) const -> const T & {
    invariant(i < len_);
    return data_.data()[i];
  }
  TRIVIAL constexpr auto back() -> T & {
    invariant(len_ > 0);
    return data_.data()[size() - 1z];
  }
  TRIVIAL constexpr auto back() const -> const T & {
    invariant(len_ > 0);
    return data_.data()[size() - 1z];
  }
  TRIVIAL constexpr auto front() -> T & {
    invariant(len_ > 0);
    return data_.data()[0z];
  }
  TRIVIAL constexpr auto front() const -> const T & {
    invariant(len_ > 0);
    return data_.data()[0z];
  }
  TRIVIAL constexpr void push_back(const T &t) {
    invariant(len_ < std::ptrdiff_t(N));
    std::construct_at(data_.data() + std::ptrdiff_t(L(len_++)), t);
  }
  TRIVIAL constexpr void push_back(T &&t) {
    invariant(len_ < std::ptrdiff_t(N));
    std::construct_at(data_.data() + std::ptrdiff_t(L(len_++)), std::move(t));
  }
  template <class... Args>
  TRIVIAL constexpr auto emplace_back(Args &&...args) -> T & {
    invariant(len_ < std::ptrdiff_t(N));
    return *std::construct_at(data_.data() + std::ptrdiff_t(L(len_++)),
                              std::forward<Args>(args)...);
  }
  TRIVIAL constexpr void pop_back() {
    invariant(len_ > 0);
    --len_;
    if constexpr (!std::is_trivially_destructible_v<T>)
      std::destroy_at(data_.data() + size());
  }
  [[nodiscard]] TRIVIAL constexpr auto pop_back_val() -> T {
    invariant(len_ > 0);
    return std::move(data_.data()[std::ptrdiff_t(L(--len_))]);
  }
  [[nodiscard]] TRIVIAL constexpr auto size() const -> std::ptrdiff_t {
    auto l = std::ptrdiff_t(L(len_));
    utils::assume(l <= std::ptrdiff_t(N));
    return l;
  }
  [[nodiscard]] TRIVIAL constexpr auto empty() const -> bool {
    return len_ == 0z;
  }
  TRIVIAL constexpr void clear() {
    if constexpr (!std::is_trivially_destructible_v<T>)
      std::destroy_n(data_.data(), size());
    len_ = Length{};
  }

  TRIVIAL constexpr auto data() -> T * { return data_.data(); }
  TRIVIAL constexpr auto data() const -> const T * { return data_.data(); }
  TRIVIAL constexpr auto begin() -> T * { return data_.data(); }
  TRIVIAL constexpr auto begin() const -> const T * { return data_.data(); }
  TRIVIAL constexpr auto end() -> T * { return data_.data() + size(); }
  TRIVIAL constexpr auto end() const -> const T * {
    return data_.data() + size();
  }
  TRIVIAL constexpr auto rbegin() { return std::reverse_iterator(end()); }
  TRIVIAL constexpr auto rbegin() const { return std::reverse_iterator(end()); }
  TRIVIAL constexpr auto rend() { return std::reverse_iterator(begin()); }
  TRIVIAL constexpr auto rend() const { return std::reverse_iterator(begin()); }
  TRIVIAL constexpr void resize(L new_size) {
    // initialize new data
    for (std::ptrdiff_t i = size(); i < new_size; ++i)
      std::construct_at(data_.data() + i);
    len_ = math::length(new_size);
  }
  TRIVIAL constexpr void reserve(L space) {
    invariant(space >= 0);
    invariant(std::size_t(space) <= N);
  }
  TRIVIAL constexpr ~TinyVector() requires(std::is_trivially_destructible_v<T>)
  = default;
  TRIVIAL constexpr ~TinyVector() requires(!std::is_trivially_destructible_v<T>)
  {
    std::destroy_n(data_.data(), size());
  }
  TRIVIAL constexpr auto mview() -> std::span<T> {
    return {data(), std::size_t(std::ptrdiff_t(len_))};
  }
  template <std::invocable<TinyVector> F>
  TRIVIAL constexpr auto operator|(F &&f) const {
    return std::forward<F>(f)(*this);
  }
};
} // namespace containers
