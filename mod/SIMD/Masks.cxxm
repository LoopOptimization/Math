module;

#include "Macros.hxx"

#ifdef __x86_64__
#include <immintrin.h>
#endif

export module SIMD:Mask;

import std;
import BaseUtils;

template <std::ptrdiff_t W, typename T>
using Vec_ [[gnu::vector_size(W * sizeof(T))]] = T;
export namespace simd {
template <std::ptrdiff_t W, typename T>
using Vec = std::conditional_t<W == 1, T, Vec_<W, T>>;
#ifdef __x86_64__
#ifdef __AVX512F__
inline constexpr std::ptrdiff_t REGISTERS = 32;
inline constexpr std::ptrdiff_t VECTORWIDTH = 64;
#else // not __AVX512F__
inline constexpr std::ptrdiff_t REGISTERS = 16;
#ifdef __AVX__
inline constexpr std::ptrdiff_t VECTORWIDTH = 32;
#else  // no AVX
inline constexpr std::ptrdiff_t VECTORWIDTH = 16;
#endif // no AVX
#endif
#else  // not __x86_64__
inline constexpr std::ptrdiff_t REGISTERS = 32;
inline constexpr std::ptrdiff_t VECTORWIDTH = 16;
#endif // __x86_64__
template <std::ptrdiff_t W,
          typename I = std::conditional_t<W == 2, std::int64_t, std::int32_t>>
consteval auto range() -> Vec<W, I> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  if constexpr (W == 2) return Vec<W, I>{0, 1};
  else if constexpr (W == 4) return Vec<W, I>{0, 1, 2, 3};
  else if constexpr (W == 8) return Vec<W, I>{0, 1, 2, 3, 4, 5, 6, 7};
  else if constexpr (W == 16)
    return Vec<W, I>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
  else {
    Vec<W, I> r;
    for (std::ptrdiff_t w = 0; w < W; ++w) r[w] = I(w);
    return r;
  }
}

#if defined(__x86_64__) && defined(__AVX512VL__)
template <std::ptrdiff_t W>
#include "Macros.hxx"

TRIVIAL constexpr auto sextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  if constexpr (W == 2) {
    return std::bit_cast<Vec<2, std::int64_t>>(
      _mm_cvtepi32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 4) {
    return std::bit_cast<Vec<4, std::int64_t>>(
      _mm256_cvtepi32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 8) {
    return std::bit_cast<Vec<8, std::int64_t>>(
      _mm512_cvtepi32_epi64(std::bit_cast<__m256i>(v)));
  } else static_assert(false);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto zextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  if constexpr (W == 2) {
    return std::bit_cast<Vec<2, std::int64_t>>(
      _mm_cvtepu32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 4) {
    return std::bit_cast<Vec<4, std::int64_t>>(
      _mm256_cvtepu32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 8) {
    return std::bit_cast<Vec<8, std::int64_t>>(
      _mm512_cvtepu32_epi64(std::bit_cast<__m256i>(v)));
  } else static_assert(false);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto truncelts(Vec<W, std::int64_t> v)
  -> Vec<W, std::int32_t> {
  if constexpr (W == 2) {
    return std::bit_cast<Vec<2, std::int32_t>>(
      _mm_cvtepi64_epi32(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 4) {
    return std::bit_cast<Vec<4, std::int32_t>>(
      _mm256_cvtepi64_epi32(std::bit_cast<__m256i>(v)));
  } else if constexpr (W == 8) {
    return std::bit_cast<Vec<8, std::int32_t>>(
      _mm512_cvtepi64_epi32(std::bit_cast<__m512i>(v)));
  } else static_assert(false);
}
#else
template <std::ptrdiff_t W>
TRIVIAL constexpr auto sextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  if constexpr (W != 1) {
    Vec<W, std::int64_t> r;
    for (std::ptrdiff_t w = 0; w < W; ++w)
      r[w] = static_cast<std::int64_t>(v[w]);
    return r;
  } else return static_cast<std::int64_t>(v);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto zextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  using R = Vec<W, std::int64_t>;
  static constexpr Vec<W, std::int32_t> z{};
  if constexpr (W == 1)
    return static_cast<std::int64_t>(
      static_cast<std::uint64_t>(static_cast<std::uint32_t>(v)));
  else if constexpr (W == 2)
    return std::bit_cast<R>(__builtin_shufflevector(v, z, 0, 2, 1, 3));
  else if constexpr (W == 4)
    return std::bit_cast<R>(
      __builtin_shufflevector(v, z, 0, 4, 1, 5, 2, 6, 3, 7));
  else if constexpr (W == 8)
    return std::bit_cast<R>(__builtin_shufflevector(
      v, z, 0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15));
  else static_assert(false);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto truncelts(Vec<W, std::int64_t> v)
  -> Vec<W, std::int32_t> {
  using R = Vec<W, std::int64_t>;
  if constexpr (W == 1) return static_cast<R>(v);
  else {
    Vec<2 * W, std::int32_t> x = std::bit_cast<Vec<2 * W, std::int32_t>>(v);
    if constexpr (W == 2) return __builtin_shufflevector(x, x, 0, 2);
    else if constexpr (W == 4) return __builtin_shufflevector(x, x, 0, 2, 4, 6);
    else if constexpr (W == 8)
      return __builtin_shufflevector(x, x, 0, 2, 4, 6, 8, 10, 12, 14);
    else static_assert(false);
  }
}
#endif

namespace mask {
/// Treats all elements as unmasked
template <std::ptrdiff_t W> struct None {
  TRIVIAL static constexpr auto onBegin() -> std::ptrdiff_t { return 0; }
  /// Values >= W indicate full masks
  TRIVIAL static constexpr auto onEnd() -> std::ptrdiff_t { return W; }
  TRIVIAL static constexpr auto offBegin() -> std::ptrdiff_t { return W; }
  TRIVIAL static constexpr auto offEnd() -> std::ptrdiff_t { return 0; }
};

// Alternatives we can have: BitMask and VectorMask
// We use `BitMask` on AVX512, VectorMask elsewhere.
// ARM SVE(2) will eventually want bitmasks as well.
#ifdef __x86_64__
#ifdef __AVX512F__
template <std::ptrdiff_t W> struct Bit {
  std::uint64_t mask_;
  // template <std::unsigned_integral U> TRIVIAL explicit constexpr operator U()
  // {
  //   return U(mask_);
  // }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool { return mask_; }
  /// Returns the first `idx` where the mask bit is `0`
  TRIVIAL [[nodiscard]] constexpr auto onBegin() const -> std::ptrdiff_t {
    return std::ptrdiff_t(std::countr_zero(mask_));
  }
  /// Returns the last `idx` where the mask bit is `1`
  /// Values >= W indicate full masks
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    if constexpr (W < 64z) {
      // could make this `countr_ones` if we decide to only
      // support leading masks
      std::uint64_t m = mask_ & ((1UL << W) - 1UL);
      return 64z - std::ptrdiff_t(std::countl_zero(m));
    } else return 64z - std::ptrdiff_t(std::countl_zero(mask_));
  }
  /// Returns the first `idx` where the mask bit is `0`
  TRIVIAL [[nodiscard]] constexpr auto offBegin() const -> std::ptrdiff_t {
    return std::ptrdiff_t(std::countr_one(mask_));
  }
  /// Returns the last `idx` where the mask bit is `0`
  TRIVIAL [[nodiscard]] constexpr auto offEnd() const -> std::ptrdiff_t {
    if constexpr (W < 64z) {
      std::uint64_t m = (~mask_) & ((1UL << W) - 1UL);
      return 64z - std::ptrdiff_t(std::countl_zero(m));
    } else return 64z - std::ptrdiff_t(std::countl_one(mask_));
  }
  template <std::ptrdiff_t S>
  TRIVIAL [[nodiscard]] constexpr auto sub() -> Bit<S> {
    static_assert(S <= W);
    std::uint64_t s = mask_;
    mask_ >>= S;
    return {s};
  }

private:
  TRIVIAL friend inline constexpr auto operator&(Bit<W> a, Bit<W> b) -> Bit<W> {
    return {a.mask_ & b.mask_};
  }
  TRIVIAL friend inline constexpr auto operator&(None<W>, Bit<W> b) -> Bit<W> {
    return b;
  }
  TRIVIAL friend inline constexpr auto operator&(Bit<W> a, None<W>) -> Bit<W> {
    return a;
  }
  TRIVIAL friend inline constexpr auto operator|(Bit<W> a, Bit<W> b) -> Bit<W> {
    return {a.mask_ | b.mask_};
  }
  TRIVIAL friend inline constexpr auto operator|(None<W>, Bit<W>) -> Bit<W> {
    return None<W>{};
  }
  TRIVIAL friend inline constexpr auto operator|(Bit<W>, None<W>) -> Bit<W> {
    return None<W>{};
  }
};
template <std::ptrdiff_t W> struct ExplicitLengthBit : Bit<W> {
  std::ptrdiff_t explicit_on_end_;
  TRIVIAL constexpr ExplicitLengthBit(std::uint64_t mask, std::ptrdiff_t on_end)
    : Bit<W>{mask}, explicit_on_end_(on_end) {}
  /// Values >= W indicate full masks
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    return explicit_on_end_;
  }
};
#endif // AVX512F
#ifdef __AVX512VL__
// In: iteration count `i.i` is the total length of the loop
// Out: mask for the final iteration. Zero indicates no masked iter.
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i) -> ExplicitLengthBit<W> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  utils::invariant(i >= 0);
  std::ptrdiff_t rem = i & (W - 1);
  return {_bzhi_u64(0xffffffffffffffff, std::uint64_t(rem)), rem};
};
// In: index::Vector where `i.i` is for the current iteration, and total loop
// length. Out: mask for the current iteration, 0 indicates exit loop.
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len)
  -> ExplicitLengthBit<W> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  std::uint64_t x;
  if (__builtin_usubl_overflow(len, i, &x)) return {0, 0};
  if (x >= 64) return {0xffffffffffffffff, W};
  std::ptrdiff_t on_end = std::min(std::ptrdiff_t(x), W);
  return {_bzhi_u64(0xffffffffffffffff, x), on_end};
};
// Requires: 0 <= m <= 255
template <std::ptrdiff_t W>
TRIVIAL constexpr auto createSmallPositive(std::ptrdiff_t m)
  -> ExplicitLengthBit<W> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  utils::invariant(0 <= m);
  utils::invariant(m <= 255);
  std::ptrdiff_t on_end = std::min(m, W);
  return {_bzhi_u64(0xffffffffffffffff, std::uint64_t(m)), on_end};
};

template <std::ptrdiff_t W> using Mask = Bit<W>;

#else // ifdef __AVX512VL__

template <std::ptrdiff_t W, std::size_t Bytes> struct Vector {
  static_assert(Bytes <= 8, "Only at most 8 bytes per element supported.");
  using I = utils::signed_integer_t<Bytes>;
  using V = Vec<W, I>;
  static_assert(sizeof(I) == Bytes);
  // static_assert(sizeof(I) * W <= VECTORWIDTH);
  // TODO: add support for smaller mask types, we we can use smaller eltypes
  V m;
  template <std::size_t newBytes>
  TRIVIAL constexpr operator Vector<W, newBytes>() const {
    if constexpr (newBytes == Bytes) return *this;
    else if constexpr (newBytes == 2 * Bytes) return {sextelts<W>(m)};
    else if constexpr (2 * newBytes == Bytes) return {truncelts<W>(m)};
    else static_assert(false);
  }
  TRIVIAL [[nodiscard]] constexpr auto intmask() const -> std::int32_t {
    if constexpr (sizeof(I) == 8)
      if constexpr (W == 2) {
        __m128d arg = std::bit_cast<__m128d>(m);
        return _mm_movemask_pd(arg);
      } else return _mm256_movemask_pd(std::bit_cast<__m256d>(m));
    else if constexpr (sizeof(I) == 4)
      if constexpr (W == 4) {
        __m128 mm = std::bit_cast<__m128>(m);
        return _mm_movemask_ps(mm);
      } else return _mm256_movemask_ps(std::bit_cast<__m256>(m));
    else if constexpr (W == 16)
      return _mm_movemask_epi8(std::bit_cast<__m128i>(m));
    else return _mm256_movemask_epi8(std::bit_cast<__m256i>(m));
  }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool { return intmask(); }
  TRIVIAL [[nodiscard]] constexpr auto onBegin() const -> std::ptrdiff_t {
    return std::countr_zero(std::uint32_t(intmask()));
  }
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    return 32 - std::countl_zero(std::uint32_t(intmask()));
  }
  TRIVIAL [[nodiscard]] constexpr auto offBegin() const -> std::ptrdiff_t {
    return std::countr_one(std::uint32_t(intmask()));
  }
  TRIVIAL [[nodiscard]] constexpr auto offEnd() const -> std::ptrdiff_t {
    std::uint32_t m = (~std::uint32_t(intmask())) & ((1U << W) - 1U);
    return 32 - std::countl_zero(m);
  }
  TRIVIAL constexpr operator __m128i() requires(sizeof(I) * W == 16) {
    return std::bit_cast<__m128i>(m);
  }
  TRIVIAL constexpr operator __m128d() requires(sizeof(I) * W == 16) {
    return std::bit_cast<__m128d>(m);
  }
  TRIVIAL constexpr operator __m128() requires(sizeof(I) * W == 16) {
    return std::bit_cast<__m128>(m);
  }
  TRIVIAL constexpr operator __m256i() requires(sizeof(I) * W == 32) {
    return std::bit_cast<__m256i>(m);
  }
  TRIVIAL constexpr operator __m256d() requires(sizeof(I) * W == 32) {
    return std::bit_cast<__m256d>(m);
  }
  TRIVIAL constexpr operator __m256() requires(sizeof(I) * W == 32) {
    return std::bit_cast<__m256>(m);
  }

private:
  TRIVIAL friend constexpr auto operator&(Vector a, Vector b) -> Vector {
    return {a.m & b.m};
  }
  TRIVIAL friend constexpr auto operator&(mask::None<W>, Vector b) -> Vector {
    return b;
  }
  TRIVIAL friend constexpr auto operator&(Vector a, mask::None<W>) -> Vector {
    return a;
  }
  TRIVIAL friend constexpr auto operator|(Vector a, Vector b) -> Vector {
    return {a.m | b.m};
  }
  TRIVIAL friend constexpr auto operator|(mask::None<W>, Vector) -> None<W> {
    return {};
  }
  TRIVIAL friend constexpr auto operator|(Vector, mask::None<W>) -> None<W> {
    return {};
  }
};
static_assert(!std::convertible_to<Vector<2, 8>, Vector<4, 8>>);
static_assert(!std::convertible_to<Vector<4, 4>, Vector<8, 4>>);
template <std::ptrdiff_t W, std::size_t Bytes>
struct ExplicitLengthVector : Vector<W, Bytes> {
  std::ptrdiff_t explicit_on_end_;
  TRIVIAL constexpr ExplicitLengthVector(typename Vector<W, Bytes>::V mask_vec,
                                         std::ptrdiff_t on_end)
    : Vector<W, Bytes>{{mask_vec}}, explicit_on_end_(on_end) {}
  /// Values >= W indicate full masks
  TRIVIAL constexpr auto onEnd() const -> std::ptrdiff_t {
    return explicit_on_end_;
  }

  template <std::size_t newBytes>
  TRIVIAL constexpr operator ExplicitLengthVector<W, newBytes>() {
    if constexpr (newBytes == Bytes) return *this;
    else if constexpr (newBytes == 2 * Bytes)
      return {sextelts<W>(this->m), explicit_on_end_};
    else if constexpr (2 * newBytes == Bytes)
      return {truncelts<W>(this->m), explicit_on_end_};
    else static_assert(false);
  }
};
#ifdef __AVX512F__

// but no VL!!! xeon phi
template <std::ptrdiff_t W> TRIVIAL constexpr auto create(std::ptrdiff_t i) {
  if constexpr (W == 8) {
    std::ptrdiff_t rem = i & 7;
    return ExplicitLengthBit<8>{
      _bzhi_u64(0xffffffffffffffff, std::uint64_t(rem)), rem};
  } else {
    std::ptrdiff_t rem = i & (W - 1);
    return ExplicitLengthVector<W, 8>{range<W, std::int64_t>() < rem, rem};
  }
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len) {
  if constexpr (W == 8) {
    std::ptrdiff_t rem = len - i;
    return ExplicitLengthBit<8>{
      _bzhi_u64(0xffffffffffffffff, std::uint64_t(rem)), rem};
  } else {
    std::ptrdiff_t rem = len - i;
    return ExplicitLengthVector<W, 8>{range<W, std::int64_t>() < rem, rem};
  }
}
template <std::ptrdiff_t W, typename I = std::int64_t>
using Mask = std::conditional_t<sizeof(I) * W == 64, Bit<W>, Vector<W, I>>;
#else  // ifdef __AVX512F__

template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i)
  -> ExplicitLengthVector<W, std::min(8z, VECTORWIDTH / W)> {
  static constexpr std::ptrdiff_t R = VECTORWIDTH / W;
  using I = utils::signed_integer_t<R >= 8 ? 8 : R>;
  std::ptrdiff_t rem = i & (W - 1);
  return {range<W, I>() < static_cast<I>(rem), rem};
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len)
  -> ExplicitLengthVector<W, std::min(8z, VECTORWIDTH / W)> {
  static constexpr std::ptrdiff_t R = VECTORWIDTH / W;
  using I = utils::signed_integer_t<R >= 8 ? 8 : R>;
  std::ptrdiff_t rem = len - i;
  return {range<W, I>() < static_cast<I>(rem), rem};
}
template <std::ptrdiff_t W, typename I = std::int64_t>
using Mask = Vector<W, sizeof(I)>;
#endif // ifdef __AVX512F__; else

#endif // ifdef __AVX512VL__; else
#else  // ifdef __x86_64__

template <std::ptrdiff_t W, std::size_t Bytes> struct Vector {
  using I = utils::signed_integer_t<Bytes>;
  static_assert(sizeof(I) == Bytes);
  using V = Vec<W, I>;
  V m;
  template <std::size_t newBytes>
  TRIVIAL constexpr operator Vector<W, newBytes>() const {
    if constexpr (newBytes == Bytes) return *this;
    else if constexpr (newBytes == 2 * Bytes) return {sextelts<W>(m)};
    else if constexpr (2 * newBytes == Bytes) return {truncelts<W>(m)};
    else static_assert(false);
  }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    bool any{false};
    for (std::ptrdiff_t w = 0; w < W; ++w) any |= m[w];
    return any;
  }
  TRIVIAL [[nodiscard]] constexpr auto onBegin() const -> std::ptrdiff_t {
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (m[w]) return w;
    return W;
  }
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    std::ptrdiff_t l = 0;
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (m[w]) l = w;
    return l;
  }
  TRIVIAL [[nodiscard]] constexpr auto offBegin() const -> std::ptrdiff_t {
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (!m[w]) return w;
    return W;
  }
  TRIVIAL [[nodiscard]] constexpr auto offEnd() const -> std::ptrdiff_t {
    std::ptrdiff_t l = 0;
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (!m[w]) l = w;
    return l;
  }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    if constexpr (W == 2) {
      return m[0] || m[1];
    } else {
      for (std::ptrdiff_t w = 0; w < W; ++w)
        if (m[w]) return true;
      return false;
    }
  }

private:
  TRIVIAL friend constexpr auto operator&(Vector a, Vector b) -> Vector {
    return {a.m & b.m};
  }
  TRIVIAL friend constexpr auto operator&(mask::None<W>, Vector b) -> Vector {
    return b;
  }
  TRIVIAL friend constexpr auto operator&(Vector a, mask::None<W>) -> Vector {
    return a;
  }
  TRIVIAL friend constexpr auto operator|(Vector a, Vector b) -> Vector {
    return {a.m | b.m};
  }
  TRIVIAL friend constexpr auto operator|(mask::None<W>, Vector) -> None<W> {
    return {};
  }
  TRIVIAL friend constexpr auto operator|(Vector, mask::None<W>) -> None<W> {
    return {};
  }
};
template <std::ptrdiff_t W> struct ExplicitLengthBit : Bit<W> {
  std::ptrdiff_t explicit_on_end_;
  TRIVIAL constexpr ExplicitLengthBit(std::uint64_t mask, std::ptrdiff_t on_end)
    : Bit<W>{mask}, explicit_on_end_(on_end) {}
  /// Values >= W indicate full masks
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    return explicit_on_end_;
  }
};

template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i)
  -> ExplicitLengthVector<W, VECTORWIDTH / W> {
  using I = utils::signed_integer_t<VECTORWIDTH / W>;
  std::ptrdiff_t rem = i & (W - 1);
  return {range<W, I>() < static_cast<I>(rem), rem};
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len)
  -> ExplicitLengthVector<W, VECTORWIDTH / W> {
  using I = utils::signed_integer_t<VECTORWIDTH / W>;
  std::ptrdiff_t rem = len - i;
  return {range<W, I>() < static_cast<I>(rem), rem};
}
#endif // ifdef __x86_64__; else

} // namespace mask

namespace cmp {
#ifdef __AVX512VL__

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto eq(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 8)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 0)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 0)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 8)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 0)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 0)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {
        _mm_cmp_ps_mask(std::bit_cast<__m128>(x), std::bit_cast<__m128>(y), 8)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 0)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 0)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ne(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 4)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 4)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 4)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 4)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 4)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 4)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {
        _mm_cmp_ps_mask(std::bit_cast<__m128>(x), std::bit_cast<__m128>(y), 4)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 4)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 4)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto lt(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 25)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 1)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 1)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 25)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 1)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 1)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 25)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 1)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 1)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto gt(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 22)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 6)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 6)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 22)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 6)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 6)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 22)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 6)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 6)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto le(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 26)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 2)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 2)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 26)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 2)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 2)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 26)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 2)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 2)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ge(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 21)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 5)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 5)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 21)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 5)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 5)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 21)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 5)};
    else static_assert(false);
  } else if constexpr (W == 2) {

    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 5)};
    else static_assert(false);
  } else static_assert(false);
}

#elif defined(__AVX512F__)

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto eq(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 0)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x == y};
  }
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ne(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 4)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x != y};
  }
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto lt(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 1)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x < y};
  }
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto gt(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 6)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x > y};
  }
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto le(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 2)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x <= y};
  }
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ge(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 5)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x >= y};
  }
}

#else  // ifdef __AVX512VL__

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto eq(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x == y};
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ne(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x != y};
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto lt(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x < y};
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto gt(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x > y};
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto le(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x <= y};
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ge(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x >= y};
}
#endif // ifdef __AVX512VL__; else
} // namespace cmp
template <std::ptrdiff_t W,
          typename I = std::conditional_t<W == 2, std::int64_t, std::int32_t>>
TRIVIAL inline auto firstoff() {
  return cmp::ne<W, I>(range<W, I>(), Vec<W, I>{});
}

namespace mask {
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N,
          std::size_t Bytes>
struct Unroll {
  static constexpr std::ptrdiff_t W =
    std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
  static_assert(R * C > 0);
#ifdef __AVX512VL__
  using MaskType = mask::Bit<W>;
#elif defined(__AVX512F__)
  using MaskType =
    std::conditional_t<Bytes * W == 64, mask::Bit<W>, mask::Vector<W, Bytes>>;
#else
  using MaskType = mask::Vector<W, Bytes>;
#endif
  MaskType data_[R * C];

  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) -> MaskType & {
    return data_[i];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r, std::ptrdiff_t c)
    -> MaskType & {
    return data_[(r * C) + c];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) const -> MaskType {
    return data_[i];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r, std::ptrdiff_t c) const
    -> MaskType {
    return data_[(r * C) + c];
  }

  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      if (data_[i].any()) return true;
    return false;
  }

  [[nodiscard]] TRIVIAL constexpr auto onBegin() const -> std::ptrdiff_t {
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      if (auto begin = data_[i].onBegin(); begin < W) return (i * W) + begin;
    return R * C * W;
  }

  [[nodiscard]] TRIVIAL constexpr auto onEnd() const -> std::ptrdiff_t {
    std::ptrdiff_t last = 0;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      if (auto end = data_[i].onEnd(); end > 0) last = (i * W) + end;
    return last;
  }

private:
  TRIVIAL friend constexpr auto operator&(Unroll a, Unroll b) -> Unroll {
    Unroll result;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      result.data_[i] = a.data_[i] & b.data_[i];
    return result;
  }

  TRIVIAL friend constexpr auto operator|(Unroll a, Unroll b) -> Unroll {
    Unroll result;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      result.data_[i] = a.data_[i] | b.data_[i];
    return result;
  }
  TRIVIAL friend constexpr auto operator^(Unroll a, Unroll b) -> Unroll {
    Unroll result;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      result.data_[i] = a.data_[i] ^ b.data_[i];
    return result;
  }
};

// Specialization for 1x1 Unroll
template <std::ptrdiff_t N, std::size_t Bytes> struct Unroll<1, 1, N, Bytes> {
  static constexpr std::ptrdiff_t W =
    std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
#ifdef __AVX512VL__
  using MaskType = mask::Bit<W>;
#elif defined(__AVX512F__)
  using MaskType =
    std::conditional_t<Bytes * W == 64, mask::Bit<W>, mask::Vector<W, Bytes>>;
#else
  using MaskType = mask::Vector<W, Bytes>;
#endif
  MaskType mask_;

  TRIVIAL constexpr auto operator[](std::ptrdiff_t) -> MaskType & {
    return mask_;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t, std::ptrdiff_t)
    -> MaskType & {
    return mask_;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t) const -> MaskType {
    return mask_;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t, std::ptrdiff_t) const
    -> MaskType {
    return mask_;
  }

  TRIVIAL constexpr operator MaskType() const { return mask_; }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    return mask_.any();
  }

  [[nodiscard]] TRIVIAL constexpr auto onBegin() const -> std::ptrdiff_t {
    return mask_.onBegin();
  }

  [[nodiscard]] TRIVIAL constexpr auto onEnd() const -> std::ptrdiff_t {
    return mask_.onEnd();
  }

private:
  TRIVIAL friend constexpr auto operator&(Unroll a, Unroll b) -> Unroll {
    return {a.mask_ & b.mask_};
  }

  TRIVIAL friend constexpr auto operator|(Unroll a, Unroll b) -> Unroll {
    return {a.mask_ | b.mask_};
  }
  TRIVIAL friend constexpr auto operator^(Unroll a, Unroll b) -> Unroll {
    return {a.mask_ ^ b.mask_};
  }
};
} // namespace mask

} // namespace simd
