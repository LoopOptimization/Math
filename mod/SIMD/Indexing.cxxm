module;

export module SIMD:Index;

import :Mask;
import AxisTypes;
import std;
export namespace simd::index {

// template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t W, typename M,
// std::ptrdiff_t X> constexpr auto unroll(std::ptrdiff_t index, M mask,
// RowStride<X> rs){
//   return Unroll<R,C,W,M,X>{index,mask,rs};
// }

/// UnrollDims<R,C,W,M,Transposed=false>
/// Transposed means that the `W` dim indexes across the stride
/// !Tranposed means that the `W` dim is contiguous.
/// Note that `UnrollDims<R,C,1,mask::None<1>,false>` is thus morally
/// equivalent to `UnrollDims<C,R,1,mask::None<1>,true>`
///
template <std::ptrdiff_t R, std::ptrdiff_t C = 1, std::ptrdiff_t W = 1,
          typename M = mask::None<W>, bool Transposed = false,
          std::ptrdiff_t X = -1>
struct UnrollDims {
  static_assert(W != 1 || std::same_as<M, mask::None<1>>,
                "Only mask vector dims");
  static_assert(W != 1 || !Transposed,
                "Canonicalize scalar with Tranpose=false");
  [[no_unique_address]] M mask_;
  [[no_unique_address]] math::RowStride<X> rs_;
};

template <typename T> inline constexpr bool issimd = false;

template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t W, typename M,
          bool Transposed, std::ptrdiff_t X>
inline constexpr bool issimd<UnrollDims<R, C, W, M, Transposed, X>> = true;
} // namespace simd::index
