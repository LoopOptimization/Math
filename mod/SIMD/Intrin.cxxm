module;

#include "LoopMacros.hxx"
#include "Macros.hxx"
#ifdef __x86_64__
#include <immintrin.h>
#endif

export module SIMD:Intrin;

import AxisTypes;
import BaseUtils;
import std;

template <std::ptrdiff_t W, typename T>
using Vec_ [[gnu::vector_size(W * sizeof(T))]] = T;

export namespace simd {

template <std::ptrdiff_t W, typename T>
using Vec = std::conditional_t<W == 1, T, Vec_<W, T>>;
#ifdef __x86_64__
#ifdef __AVX512F__
inline constexpr std::ptrdiff_t REGISTERS = 32;
inline constexpr std::ptrdiff_t VECTORWIDTH = 64;
#else // not __AVX512F__
inline constexpr std::ptrdiff_t REGISTERS = 16;
#ifdef __AVX__
inline constexpr std::ptrdiff_t VECTORWIDTH = 32;
#else  // no AVX
inline constexpr std::ptrdiff_t VECTORWIDTH = 16;
#endif // no AVX
#endif
#else  // not __x86_64__
inline constexpr std::ptrdiff_t REGISTERS = 32;
inline constexpr std::ptrdiff_t VECTORWIDTH = 16;
#endif // __x86_64__
template <std::ptrdiff_t W,
          typename I = std::conditional_t<W == 2, std::int64_t, std::int32_t>>
consteval auto range() -> Vec<W, I> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  if constexpr (W == 2) return Vec<W, I>{0, 1};
  else if constexpr (W == 4) return Vec<W, I>{0, 1, 2, 3};
  else if constexpr (W == 8) return Vec<W, I>{0, 1, 2, 3, 4, 5, 6, 7};
  else if constexpr (W == 16)
    return Vec<W, I>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
  else {
    Vec<W, I> r;
    for (std::ptrdiff_t w = 0; w < W; ++w) r[w] = I(w);
    return r;
  }
}

#if defined(__x86_64__) && defined(__AVX512VL__)
template <std::ptrdiff_t W>
#include "Macros.hxx"

TRIVIAL constexpr auto sextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  if constexpr (W == 2) {
    return std::bit_cast<Vec<2, std::int64_t>>(
      _mm_cvtepi32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 4) {
    return std::bit_cast<Vec<4, std::int64_t>>(
      _mm256_cvtepi32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 8) {
    return std::bit_cast<Vec<8, std::int64_t>>(
      _mm512_cvtepi32_epi64(std::bit_cast<__m256i>(v)));
  } else static_assert(false);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto zextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  if constexpr (W == 2) {
    return std::bit_cast<Vec<2, std::int64_t>>(
      _mm_cvtepu32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 4) {
    return std::bit_cast<Vec<4, std::int64_t>>(
      _mm256_cvtepu32_epi64(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 8) {
    return std::bit_cast<Vec<8, std::int64_t>>(
      _mm512_cvtepu32_epi64(std::bit_cast<__m256i>(v)));
  } else static_assert(false);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto truncelts(Vec<W, std::int64_t> v)
  -> Vec<W, std::int32_t> {
  if constexpr (W == 2) {
    return std::bit_cast<Vec<2, std::int32_t>>(
      _mm_cvtepi64_epi32(std::bit_cast<__m128i>(v)));
  } else if constexpr (W == 4) {
    return std::bit_cast<Vec<4, std::int32_t>>(
      _mm256_cvtepi64_epi32(std::bit_cast<__m256i>(v)));
  } else if constexpr (W == 8) {
    return std::bit_cast<Vec<8, std::int32_t>>(
      _mm512_cvtepi64_epi32(std::bit_cast<__m512i>(v)));
  } else static_assert(false);
}
#else
template <std::ptrdiff_t W>
TRIVIAL constexpr auto sextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  if constexpr (W != 1) {
    Vec<W, std::int64_t> r;
    for (std::ptrdiff_t w = 0; w < W; ++w)
      r[w] = static_cast<std::int64_t>(v[w]);
    return r;
  } else return static_cast<std::int64_t>(v);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto zextelts(Vec<W, std::int32_t> v)
  -> Vec<W, std::int64_t> {
  using R = Vec<W, std::int64_t>;
  static constexpr Vec<W, std::int32_t> z{};
  if constexpr (W == 1)
    return static_cast<std::int64_t>(
      static_cast<std::uint64_t>(static_cast<std::uint32_t>(v)));
  else if constexpr (W == 2)
    return std::bit_cast<R>(__builtin_shufflevector(v, z, 0, 2, 1, 3));
  else if constexpr (W == 4)
    return std::bit_cast<R>(
      __builtin_shufflevector(v, z, 0, 4, 1, 5, 2, 6, 3, 7));
  else if constexpr (W == 8)
    return std::bit_cast<R>(__builtin_shufflevector(
      v, z, 0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15));
  else static_assert(false);
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto truncelts(Vec<W, std::int64_t> v)
  -> Vec<W, std::int32_t> {
  using R = Vec<W, std::int64_t>;
  if constexpr (W == 1) return static_cast<R>(v);
  else {
    Vec<2 * W, std::int32_t> x = std::bit_cast<Vec<2 * W, std::int32_t>>(v);
    if constexpr (W == 2) return __builtin_shufflevector(x, x, 0, 2);
    else if constexpr (W == 4) return __builtin_shufflevector(x, x, 0, 2, 4, 6);
    else if constexpr (W == 8)
      return __builtin_shufflevector(x, x, 0, 2, 4, 6, 8, 10, 12, 14);
    else static_assert(false);
  }
}
#endif

namespace mask {
/// Treats all elements as unmasked
template <std::ptrdiff_t W> struct None {
  TRIVIAL static constexpr auto onBegin() -> std::ptrdiff_t { return 0; }
  /// Values >= W indicate full masks
  TRIVIAL static constexpr auto onEnd() -> std::ptrdiff_t { return W; }
  TRIVIAL static constexpr auto offBegin() -> std::ptrdiff_t { return W; }
  TRIVIAL static constexpr auto offEnd() -> std::ptrdiff_t { return 0; }
};

// Alternatives we can have: BitMask and VectorMask
// We use `BitMask` on AVX512, VectorMask elsewhere.
// ARM SVE(2) will eventually want bitmasks as well.
#ifdef __x86_64__
#ifdef __AVX512F__
template <std::ptrdiff_t W> struct Bit {
  std::uint64_t mask_;
  // template <std::unsigned_integral U> TRIVIAL explicit constexpr operator U()
  // {
  //   return U(mask_);
  // }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool { return mask_; }
  /// Returns the first `idx` where the mask bit is `0`
  TRIVIAL [[nodiscard]] constexpr auto onBegin() const -> std::ptrdiff_t {
    return std::ptrdiff_t(std::countr_zero(mask_));
  }
  /// Returns the last `idx` where the mask bit is `1`
  /// Values >= W indicate full masks
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    if constexpr (W < 64z) {
      // could make this `countr_ones` if we decide to only
      // support leading masks
      std::uint64_t m = mask_ & ((1UL << W) - 1UL);
      return 64z - std::ptrdiff_t(std::countl_zero(m));
    } else return 64z - std::ptrdiff_t(std::countl_zero(mask_));
  }
  /// Returns the first `idx` where the mask bit is `0`
  TRIVIAL [[nodiscard]] constexpr auto offBegin() const -> std::ptrdiff_t {
    return std::ptrdiff_t(std::countr_one(mask_));
  }
  /// Returns the last `idx` where the mask bit is `0`
  TRIVIAL [[nodiscard]] constexpr auto offEnd() const -> std::ptrdiff_t {
    if constexpr (W < 64z) {
      std::uint64_t m = (~mask_) & ((1UL << W) - 1UL);
      return 64z - std::ptrdiff_t(std::countl_zero(m));
    } else return 64z - std::ptrdiff_t(std::countl_one(mask_));
  }
  template <std::ptrdiff_t S>
  TRIVIAL [[nodiscard]] constexpr auto sub() -> Bit<S> {
    static_assert(S <= W);
    std::uint64_t s = mask_;
    mask_ >>= S;
    return {s};
  }

private:
  TRIVIAL friend inline constexpr auto operator&(Bit<W> a, Bit<W> b) -> Bit<W> {
    return {a.mask_ & b.mask_};
  }
  TRIVIAL friend inline constexpr auto operator&(None<W>, Bit<W> b) -> Bit<W> {
    return b;
  }
  TRIVIAL friend inline constexpr auto operator&(Bit<W> a, None<W>) -> Bit<W> {
    return a;
  }
  TRIVIAL friend inline constexpr auto operator|(Bit<W> a, Bit<W> b) -> Bit<W> {
    return {a.mask_ | b.mask_};
  }
  TRIVIAL friend inline constexpr auto operator|(None<W>, Bit<W>) -> Bit<W> {
    return None<W>{};
  }
  TRIVIAL friend inline constexpr auto operator|(Bit<W>, None<W>) -> Bit<W> {
    return None<W>{};
  }
};
template <std::ptrdiff_t W> struct ExplicitLengthBit : Bit<W> {
  std::ptrdiff_t explicit_on_end_;
  TRIVIAL constexpr ExplicitLengthBit(std::uint64_t mask, std::ptrdiff_t on_end)
    : Bit<W>{mask}, explicit_on_end_(on_end) {}
  /// Values >= W indicate full masks
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    return explicit_on_end_;
  }
};
#endif // AVX512F
#ifdef __AVX512VL__
// In: iteration count `i.i` is the total length of the loop
// Out: mask for the final iteration. Zero indicates no masked iter.
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i) -> ExplicitLengthBit<W> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  utils::invariant(i >= 0);
  std::ptrdiff_t rem = i & (W - 1);
  return {_bzhi_u64(0xffffffffffffffff, std::uint64_t(rem)), rem};
};
// In: index::Vector where `i.i` is for the current iteration, and total loop
// length. Out: mask for the current iteration, 0 indicates exit loop.
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len)
  -> ExplicitLengthBit<W> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  std::uint64_t x;
  if (__builtin_usubl_overflow(len, i, &x)) return {0, 0};
  if (x >= 64) return {0xffffffffffffffff, W};
  std::ptrdiff_t on_end = std::min(std::ptrdiff_t(x), W);
  return {_bzhi_u64(0xffffffffffffffff, x), on_end};
};
// Requires: 0 <= m <= 255
template <std::ptrdiff_t W>
TRIVIAL constexpr auto createSmallPositive(std::ptrdiff_t m)
  -> ExplicitLengthBit<W> {
  static_assert(std::popcount(std::size_t(W)) == 1);
  utils::invariant(0 <= m);
  utils::invariant(m <= 255);
  std::ptrdiff_t on_end = std::min(m, W);
  return {_bzhi_u64(0xffffffffffffffff, std::uint64_t(m)), on_end};
};

template <std::ptrdiff_t W> using Mask = Bit<W>;

#else // ifdef __AVX512VL__

template <std::ptrdiff_t W, std::size_t Bytes> struct Vector {
  static_assert(Bytes <= 8, "Only at most 8 bytes per element supported.");
  using I = utils::signed_integer_t<Bytes>;
  using V = Vec<W, I>;
  static_assert(sizeof(I) == Bytes);
  // static_assert(sizeof(I) * W <= VECTORWIDTH);
  // TODO: add support for smaller mask types, we we can use smaller eltypes
  V m;
  template <std::size_t newBytes>
  TRIVIAL constexpr operator Vector<W, newBytes>() const {
    if constexpr (newBytes == Bytes) return *this;
    else if constexpr (newBytes == 2 * Bytes) return {sextelts<W>(m)};
    else if constexpr (2 * newBytes == Bytes) return {truncelts<W>(m)};
    else static_assert(false);
  }
  TRIVIAL [[nodiscard]] constexpr auto intmask() const -> std::int32_t {
    if constexpr (sizeof(I) == 8)
      if constexpr (W == 2) {
        __m128d arg = std::bit_cast<__m128d>(m);
        return _mm_movemask_pd(arg);
      } else return _mm256_movemask_pd(std::bit_cast<__m256d>(m));
    else if constexpr (sizeof(I) == 4)
      if constexpr (W == 4) {
        __m128 mm = std::bit_cast<__m128>(m);
        return _mm_movemask_ps(mm);
      } else return _mm256_movemask_ps(std::bit_cast<__m256>(m));
    else if constexpr (W == 16)
      return _mm_movemask_epi8(std::bit_cast<__m128i>(m));
    else return _mm256_movemask_epi8(std::bit_cast<__m256i>(m));
  }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool { return intmask(); }
  TRIVIAL [[nodiscard]] constexpr auto onBegin() const -> std::ptrdiff_t {
    return std::countr_zero(std::uint32_t(intmask()));
  }
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    return 32 - std::countl_zero(std::uint32_t(intmask()));
  }
  TRIVIAL [[nodiscard]] constexpr auto offBegin() const -> std::ptrdiff_t {
    return std::countr_one(std::uint32_t(intmask()));
  }
  TRIVIAL [[nodiscard]] constexpr auto offEnd() const -> std::ptrdiff_t {
    std::uint32_t m = (~std::uint32_t(intmask())) & ((1U << W) - 1U);
    return 32 - std::countl_zero(m);
  }
  TRIVIAL constexpr operator __m128i() requires(sizeof(I) * W == 16) {
    return std::bit_cast<__m128i>(m);
  }
  TRIVIAL constexpr operator __m128d() requires(sizeof(I) * W == 16) {
    return std::bit_cast<__m128d>(m);
  }
  TRIVIAL constexpr operator __m128() requires(sizeof(I) * W == 16) {
    return std::bit_cast<__m128>(m);
  }
  TRIVIAL constexpr operator __m256i() requires(sizeof(I) * W == 32) {
    return std::bit_cast<__m256i>(m);
  }
  TRIVIAL constexpr operator __m256d() requires(sizeof(I) * W == 32) {
    return std::bit_cast<__m256d>(m);
  }
  TRIVIAL constexpr operator __m256() requires(sizeof(I) * W == 32) {
    return std::bit_cast<__m256>(m);
  }

private:
  TRIVIAL friend constexpr auto operator&(Vector a, Vector b) -> Vector {
    return {a.m & b.m};
  }
  TRIVIAL friend constexpr auto operator&(mask::None<W>, Vector b) -> Vector {
    return b;
  }
  TRIVIAL friend constexpr auto operator&(Vector a, mask::None<W>) -> Vector {
    return a;
  }
  TRIVIAL friend constexpr auto operator|(Vector a, Vector b) -> Vector {
    return {a.m | b.m};
  }
  TRIVIAL friend constexpr auto operator|(mask::None<W>, Vector) -> None<W> {
    return {};
  }
  TRIVIAL friend constexpr auto operator|(Vector, mask::None<W>) -> None<W> {
    return {};
  }
};
static_assert(!std::convertible_to<Vector<2, 8>, Vector<4, 8>>);
static_assert(!std::convertible_to<Vector<4, 4>, Vector<8, 4>>);
template <std::ptrdiff_t W, std::size_t Bytes>
struct ExplicitLengthVector : Vector<W, Bytes> {
  std::ptrdiff_t explicit_on_end_;
  TRIVIAL constexpr ExplicitLengthVector(typename Vector<W, Bytes>::V mask_vec,
                                         std::ptrdiff_t on_end)
    : Vector<W, Bytes>{{mask_vec}}, explicit_on_end_(on_end) {}
  /// Values >= W indicate full masks
  TRIVIAL constexpr auto onEnd() const -> std::ptrdiff_t {
    return explicit_on_end_;
  }

  template <std::size_t newBytes>
  TRIVIAL constexpr operator ExplicitLengthVector<W, newBytes>() {
    if constexpr (newBytes == Bytes) return *this;
    else if constexpr (newBytes == 2 * Bytes)
      return {sextelts<W>(this->m), explicit_on_end_};
    else if constexpr (2 * newBytes == Bytes)
      return {truncelts<W>(this->m), explicit_on_end_};
    else static_assert(false);
  }
};
#ifdef __AVX512F__

// but no VL!!! xeon phi
template <std::ptrdiff_t W> TRIVIAL constexpr auto create(std::ptrdiff_t i) {
  if constexpr (W == 8) {
    std::ptrdiff_t rem = i & 7;
    return ExplicitLengthBit<8>{
      _bzhi_u64(0xffffffffffffffff, std::uint64_t(rem)), rem};
  } else {
    std::ptrdiff_t rem = i & (W - 1);
    return ExplicitLengthVector<W, 8>{range<W, std::int64_t>() < rem, rem};
  }
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len) {
  if constexpr (W == 8) {
    std::ptrdiff_t rem = len - i;
    return ExplicitLengthBit<8>{
      _bzhi_u64(0xffffffffffffffff, std::uint64_t(rem)), rem};
  } else {
    std::ptrdiff_t rem = len - i;
    return ExplicitLengthVector<W, 8>{range<W, std::int64_t>() < rem, rem};
  }
}
template <std::ptrdiff_t W, typename I = std::int64_t>
using Mask = std::conditional_t<sizeof(I) * W == 64, Bit<W>, Vector<W, I>>;
#else  // ifdef __AVX512F__

template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i)
  -> ExplicitLengthVector<W, std::min(8z, VECTORWIDTH / W)> {
  static constexpr std::ptrdiff_t R = VECTORWIDTH / W;
  using I = utils::signed_integer_t<R >= 8 ? 8 : R>;
  std::ptrdiff_t rem = i & (W - 1);
  return {range<W, I>() < static_cast<I>(rem), rem};
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len)
  -> ExplicitLengthVector<W, std::min(8z, VECTORWIDTH / W)> {
  static constexpr std::ptrdiff_t R = VECTORWIDTH / W;
  using I = utils::signed_integer_t<R >= 8 ? 8 : R>;
  std::ptrdiff_t rem = len - i;
  return {range<W, I>() < static_cast<I>(rem), rem};
}
template <std::ptrdiff_t W, typename I = std::int64_t>
using Mask = Vector<W, sizeof(I)>;
#endif // ifdef __AVX512F__; else

#endif // ifdef __AVX512VL__; else
#else  // ifdef __x86_64__

template <std::ptrdiff_t W, std::size_t Bytes> struct Vector {
  using I = utils::signed_integer_t<Bytes>;
  static_assert(sizeof(I) == Bytes);
  using V = Vec<W, I>;
  V m;
  template <std::size_t newBytes>
  TRIVIAL constexpr operator Vector<W, newBytes>() const {
    if constexpr (newBytes == Bytes) return *this;
    else if constexpr (newBytes == 2 * Bytes) return {sextelts<W>(m)};
    else if constexpr (2 * newBytes == Bytes) return {truncelts<W>(m)};
    else static_assert(false);
  }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    bool any{false};
    for (std::ptrdiff_t w = 0; w < W; ++w) any |= m[w];
    return any;
  }
  TRIVIAL [[nodiscard]] constexpr auto onBegin() const -> std::ptrdiff_t {
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (m[w]) return w;
    return W;
  }
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    std::ptrdiff_t l = 0;
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (m[w]) l = w;
    return l;
  }
  TRIVIAL [[nodiscard]] constexpr auto offBegin() const -> std::ptrdiff_t {
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (!m[w]) return w;
    return W;
  }
  TRIVIAL [[nodiscard]] constexpr auto offEnd() const -> std::ptrdiff_t {
    std::ptrdiff_t l = 0;
    for (std::ptrdiff_t w = 0; w < W; ++w)
      if (!m[w]) l = w;
    return l;
  }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    if constexpr (W == 2) {
      return m[0] || m[1];
    } else {
      for (std::ptrdiff_t w = 0; w < W; ++w)
        if (m[w]) return true;
      return false;
    }
  }

private:
  TRIVIAL friend constexpr auto operator&(Vector a, Vector b) -> Vector {
    return {a.m & b.m};
  }
  TRIVIAL friend constexpr auto operator&(mask::None<W>, Vector b) -> Vector {
    return b;
  }
  TRIVIAL friend constexpr auto operator&(Vector a, mask::None<W>) -> Vector {
    return a;
  }
  TRIVIAL friend constexpr auto operator|(Vector a, Vector b) -> Vector {
    return {a.m | b.m};
  }
  TRIVIAL friend constexpr auto operator|(mask::None<W>, Vector) -> None<W> {
    return {};
  }
  TRIVIAL friend constexpr auto operator|(Vector, mask::None<W>) -> None<W> {
    return {};
  }
};
template <std::ptrdiff_t W> struct ExplicitLengthBit : Bit<W> {
  std::ptrdiff_t explicit_on_end_;
  TRIVIAL constexpr ExplicitLengthBit(std::uint64_t mask, std::ptrdiff_t on_end)
    : Bit<W>{mask}, explicit_on_end_(on_end) {}
  /// Values >= W indicate full masks
  TRIVIAL [[nodiscard]] constexpr auto onEnd() const -> std::ptrdiff_t {
    return explicit_on_end_;
  }
};

template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i)
  -> ExplicitLengthVector<W, VECTORWIDTH / W> {
  using I = utils::signed_integer_t<VECTORWIDTH / W>;
  std::ptrdiff_t rem = i & (W - 1);
  return {range<W, I>() < static_cast<I>(rem), rem};
}
template <std::ptrdiff_t W>
TRIVIAL constexpr auto create(std::ptrdiff_t i, std::ptrdiff_t len)
  -> ExplicitLengthVector<W, VECTORWIDTH / W> {
  using I = utils::signed_integer_t<VECTORWIDTH / W>;
  std::ptrdiff_t rem = len - i;
  return {range<W, I>() < static_cast<I>(rem), rem};
}
#endif // ifdef __x86_64__; else

} // namespace mask

namespace cmp {
#ifdef __AVX512VL__

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto eq(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 8)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 0)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 0)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 8)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 0)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 0)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {
        _mm_cmp_ps_mask(std::bit_cast<__m128>(x), std::bit_cast<__m128>(y), 8)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 0)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 0)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ne(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 4)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 4)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 4)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 4)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 4)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 4)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {
        _mm_cmp_ps_mask(std::bit_cast<__m128>(x), std::bit_cast<__m128>(y), 4)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 4)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 4)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto lt(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 25)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 1)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 1)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 25)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 1)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 1)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 25)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 1)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 1)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto gt(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 22)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 6)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 6)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 22)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 6)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 6)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 22)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 6)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 6)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto le(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 26)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 2)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 2)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 26)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 2)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 2)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 26)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 2)};
    else static_assert(false);
  } else if constexpr (W == 2) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 2)};
    else static_assert(false);
  } else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ge(Vec<W, T> x, Vec<W, T> y) -> mask::Bit<W> {
  if constexpr (W == 16) {
    if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm512_cmp_ps_mask(std::bit_cast<__m512>(x),
                                 std::bit_cast<__m512>(y), 21)};
    else if constexpr (sizeof(T) == 4)
      return {_mm512_cmp_epi32_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 5)};
    else static_assert(false);
  } else if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 5)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm256_cmp_ps_mask(std::bit_cast<__m256>(x),
                                 std::bit_cast<__m256>(y), 21)};
    else if constexpr (sizeof(T) == 4)
      return {_mm256_cmp_epi32_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 5)};
    else static_assert(false);
  } else if constexpr (W == 4) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm256_cmp_pd_mask(std::bit_cast<__m256d>(x),
                                 std::bit_cast<__m256d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm256_cmp_epi64_mask(std::bit_cast<__m256i>(x),
                                    std::bit_cast<__m256i>(y), 5)};
    else if constexpr (std::same_as<T, float>) // UQ (unordered quiet?)
      return {_mm_cmp_ps_mask(std::bit_cast<__m128>(x),
                              std::bit_cast<__m128>(y), 21)};
    else if constexpr (sizeof(T) == 4)
      return {_mm_cmp_epi32_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 5)};
    else static_assert(false);
  } else if constexpr (W == 2) {

    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm_cmp_pd_mask(std::bit_cast<__m128d>(x),
                              std::bit_cast<__m128d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm_cmp_epi64_mask(std::bit_cast<__m128i>(x),
                                 std::bit_cast<__m128i>(y), 5)};
    else static_assert(false);
  } else static_assert(false);
}

#elif defined(__AVX512F__)

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto eq(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 8)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 0)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x == y};
  }
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ne(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 4)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 4)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x != y};
  }
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto lt(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 25)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 1)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x < y};
  }
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto gt(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 22)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 6)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x > y};
  }
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto le(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 26)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 2)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x <= y};
  }
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ge(Vec<W, T> x, Vec<W, T> y) {
  if constexpr (W == 8) {
    if constexpr (std::same_as<T, double>) // UQ (unordered quiet?)
      return {_mm512_cmp_pd_mask(std::bit_cast<__m512d>(x),
                                 std::bit_cast<__m512d>(y), 21)};
    else if constexpr (sizeof(T) == 8)
      return {_mm512_cmp_epi64_mask(std::bit_cast<__m512i>(x),
                                    std::bit_cast<__m512i>(y), 5)};
    else static_assert(false);
  } else {
    return mask::Vector<W>{x >= y};
  }
}

#else  // ifdef __AVX512VL__

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto eq(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x == y};
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ne(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x != y};
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto lt(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x < y};
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto gt(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x > y};
}

template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto le(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x <= y};
}
template <std::ptrdiff_t W, typename T>
TRIVIAL inline auto ge(Vec<W, T> x, Vec<W, T> y) -> mask::Vector<W, sizeof(T)> {
  return {x >= y};
}
#endif // ifdef __AVX512VL__; else
} // namespace cmp
template <std::ptrdiff_t W,
          typename I = std::conditional_t<W == 2, std::int64_t, std::int32_t>>
TRIVIAL inline auto firstoff() {
  return cmp::ne<W, I>(range<W, I>(), Vec<W, I>{});
}

namespace mask {
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N,
          std::size_t Bytes>
struct Unroll {
  static constexpr std::ptrdiff_t W =
    std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
  static_assert(R * C > 0);
#ifdef __AVX512VL__
  using MaskType = mask::Bit<W>;
#elif defined(__AVX512F__)
  using MaskType =
    std::conditional_t<Bytes * W == 64, mask::Bit<W>, mask::Vector<W, Bytes>>;
#else
  using MaskType = mask::Vector<W, Bytes>;
#endif
  MaskType data_[R * C];

  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) -> MaskType & {
    return data_[i];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r, std::ptrdiff_t c)
    -> MaskType & {
    return data_[(r * C) + c];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) const -> MaskType {
    return data_[i];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r, std::ptrdiff_t c) const
    -> MaskType {
    return data_[(r * C) + c];
  }

  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      if (data_[i].any()) return true;
    return false;
  }

  [[nodiscard]] TRIVIAL constexpr auto onBegin() const -> std::ptrdiff_t {
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      if (auto begin = data_[i].onBegin(); begin < W) return (i * W) + begin;
    return R * C * W;
  }

  [[nodiscard]] TRIVIAL constexpr auto onEnd() const -> std::ptrdiff_t {
    std::ptrdiff_t last = 0;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      if (auto end = data_[i].onEnd(); end > 0) last = (i * W) + end;
    return last;
  }

private:
  TRIVIAL friend constexpr auto operator&(Unroll a, Unroll b) -> Unroll {
    Unroll result;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      result.data_[i] = a.data_[i] & b.data_[i];
    return result;
  }

  TRIVIAL friend constexpr auto operator|(Unroll a, Unroll b) -> Unroll {
    Unroll result;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      result.data_[i] = a.data_[i] | b.data_[i];
    return result;
  }
  TRIVIAL friend constexpr auto operator^(Unroll a, Unroll b) -> Unroll {
    Unroll result;
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      result.data_[i] = a.data_[i] ^ b.data_[i];
    return result;
  }
};

// Specialization for 1x1 Unroll
template <std::ptrdiff_t N, std::size_t Bytes> struct Unroll<1, 1, N, Bytes> {
  static constexpr std::ptrdiff_t W =
    std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
#ifdef __AVX512VL__
  using MaskType = mask::Bit<W>;
#elif defined(__AVX512F__)
  using MaskType =
    std::conditional_t<Bytes * W == 64, mask::Bit<W>, mask::Vector<W, Bytes>>;
#else
  using MaskType = mask::Vector<W, Bytes>;
#endif
  MaskType mask_;

  TRIVIAL constexpr auto operator[](std::ptrdiff_t) -> MaskType & {
    return mask_;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t, std::ptrdiff_t)
    -> MaskType & {
    return mask_;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t) const -> MaskType {
    return mask_;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t, std::ptrdiff_t) const
    -> MaskType {
    return mask_;
  }

  TRIVIAL constexpr operator MaskType() const { return mask_; }
  TRIVIAL [[nodiscard]] constexpr auto any() const -> bool {
    return mask_.any();
  }

  [[nodiscard]] TRIVIAL constexpr auto onBegin() const -> std::ptrdiff_t {
    return mask_.onBegin();
  }

  [[nodiscard]] TRIVIAL constexpr auto onEnd() const -> std::ptrdiff_t {
    return mask_.onEnd();
  }

private:
  TRIVIAL friend constexpr auto operator&(Unroll a, Unroll b) -> Unroll {
    return {a.mask_ & b.mask_};
  }

  TRIVIAL friend constexpr auto operator|(Unroll a, Unroll b) -> Unroll {
    return {a.mask_ | b.mask_};
  }
  TRIVIAL friend constexpr auto operator^(Unroll a, Unroll b) -> Unroll {
    return {a.mask_ ^ b.mask_};
  }
};
} // namespace mask

// Supported means by this library currently; more types may be added in the
// future as needed.

#ifndef POLYMATHNOEXPLICITSIMDARRAY
template <typename T>
concept SIMDSupported =
  (std::integral<T> || std::floating_point<T>) && (sizeof(T) >= 4);
#else
template <typename T>
concept SIMDSupported = false;
#endif

template <std::ptrdiff_t W, typename T>
TRIVIAL constexpr auto vbroadcast(Vec<W, T> v) -> Vec<W, T> {
  if constexpr (W == 1) return v;
  else if constexpr (W == 2) return __builtin_shufflevector(v, v, 0, 0);
  else if constexpr (W == 4) return __builtin_shufflevector(v, v, 0, 0, 0, 0);
  else if constexpr (W == 8)
    return __builtin_shufflevector(v, v, 0, 0, 0, 0, 0, 0, 0, 0);
  else if constexpr (W == 16)
    return __builtin_shufflevector(v, v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0);
  else if constexpr (W == 32)
    return __builtin_shufflevector(v, v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                   0, 0, 0, 0);
  else if constexpr (W == 64)
    return __builtin_shufflevector(
      v, v, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  else static_assert(false);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL constexpr auto vbroadcast(T x) -> Vec<W, T> {
  if constexpr (W > 1) {
    if consteval {
      return Vec<W, T>{} + x;
    } else {
      return vbroadcast<W, T>(Vec<W, T>{x});
    }
  } else return x;
}
template <typename T> TRIVIAL inline auto load(const T *p, mask::None<1>) -> T {
  return *p;
}
template <typename T>
TRIVIAL constexpr auto load(const T *p, mask::None<1>, std::int32_t)
  -> const T & {
  return *p;
}
template <typename T> TRIVIAL inline void store(T *p, mask::None<1>, T x) {
  *p = x;
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<1>, T x, std::int32_t) {
  *p = x;
}
#ifdef __x86_64__

template <std::ptrdiff_t W, typename T> TRIVIAL consteval auto mmzero() {
  // Extend if/when supporting more types
  static_assert(std::popcount(std::size_t(W)) == 1 && (W * sizeof(T) <= 64));
  if constexpr (std::same_as<T, double>) {
    if constexpr (W == 8) return __m512d{};
    else if constexpr (W == 4) return __m256d{};
    else return __m128d{};
  } else if constexpr (std::same_as<T, float>) {
    if constexpr (W == 16) return __m512{};
    else if constexpr (W == 8) return __m256{};
    else return __m128{};
  } else {
    static_assert(std::integral<T>);
    if constexpr (W * sizeof(T) == 64) return __m512i{};
    else if constexpr (W * sizeof(T) == 32) return __m256i{};
    else return __m128i{};
  }
}

#ifdef __AVX512F__

template auto vbroadcast<8, std::int64_t>(Vec<8, std::int64_t>)
  -> Vec<8, std::int64_t>;

// namespace hw {
// typedef double __m512d_u __attribute__((__vector_size__(64),
// __aligned__(8)));

// typedef std::int64_t __m512i_u __attribute__((__vector_size__(64),
// __aligned__(8))); } // namespace hw

template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<16>) -> Vec<16, T> {
  const void *vp = p;
  if constexpr (std::same_as<T, float>) {
    return std::bit_cast<Vec<16, float>>(_mm512_loadu_ps(vp));
  } else if constexpr (sizeof(T) == 4) {
    return std::bit_cast<Vec<16, T>>(_mm512_loadu_epi32(vp));
#ifdef __AVX512VL__
  } else if constexpr (sizeof(T) == 2) {
    return std::bit_cast<Vec<16, T>>(_mm256_loadu_epi16(vp));
#endif
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Bit<8> i) -> Vec<8, T> {
  const void *vp = p;
  if constexpr (std::same_as<T, double>) {
    return std::bit_cast<Vec<8, double>>(
      _mm512_maskz_loadu_pd(std::uint8_t(i.mask_), vp));
  } else if constexpr (sizeof(T) == 8) {
    return std::bit_cast<Vec<8, T>>(
      _mm512_maskz_loadu_epi64(std::uint8_t(i.mask_), vp));
#ifdef __AVX512VL__
  } else if constexpr (std::same_as<T, float>) {
    return std::bit_cast<Vec<8, float>>(
      _mm256_maskz_loadu_ps(std::uint8_t(i.mask_), vp));
  } else if constexpr (sizeof(T) == 4) {
    return std::bit_cast<Vec<8, T>>(
      _mm256_maskz_loadu_epi32(std::uint8_t(i.mask_), vp));
  } else if constexpr (sizeof(T) == 2) {
    return std::bit_cast<Vec<8, T>>(
      _mm_maskz_loadu_epi16(std::uint8_t(i.mask_), vp));
#endif
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *pt, mask::Bit<16> i) -> Vec<16, T> {
  const void *p = pt;
  if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<16, float>>(
      _mm512_maskz_loadu_ps(std::uint16_t(i.mask_), p));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<16, T>>(
      _mm512_maskz_loadu_epi32(std::uint16_t(i.mask_), p));
#ifdef __AVX512VL__
  else if constexpr (sizeof(T) == 2)
    return std::bit_cast<Vec<16, T>>(
      _mm256_maskz_loadu_epi16(std::uint16_t(i.mask_), p));
#endif
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *pt, mask::None<16>, Vec<16, T> x) {
  void *p = pt;
  if constexpr (std::same_as<T, float>) {
    __m512 xf = std::bit_cast<__m512>(x);
    _mm512_storeu_ps(p, xf);
  } else if constexpr (sizeof(T) == 4) {
    __m512i xi = std::bit_cast<__m512i>(x);
    _mm512_storeu_epi32(p, xi);
#ifdef __AVX512VL__
  } else if constexpr (sizeof(T) == 2) {
    __m256i xi = std::bit_cast<__m256i>(x);
    _mm256_storeu_epi16(p, xi);
#endif
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Bit<8> i, Vec<8, T> x) {
  void *vp = p;
  if constexpr (std::same_as<T, double>) {
    __m512d xd = std::bit_cast<__m512d>(x);
    _mm512_mask_storeu_pd(vp, std::uint8_t(i.mask_), xd);
  } else if constexpr (sizeof(T) == 8) {
    __m512i xi = std::bit_cast<__m512i>(x);
    _mm512_mask_storeu_epi64(vp, std::uint8_t(i.mask_), xi);
#ifdef __AVX512VL__
  } else if constexpr (std::same_as<T, float>) {
    __m256 xf = std::bit_cast<__m256>(x);
    _mm256_mask_storeu_ps(vp, std::uint8_t(i.mask_), xf);
  } else if constexpr (sizeof(T) == 4) {
    __m256i xi = std::bit_cast<__m256i>(x);
    _mm256_mask_storeu_epi32(vp, std::uint8_t(i.mask_), xi);
  } else if constexpr (sizeof(T) == 2) {
    __m128i xi = std::bit_cast<__m128i>(x);
    _mm_mask_storeu_epi16(vp, std::uint8_t(i.mask_), xi);
#endif
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *pt, mask::Bit<16> i, Vec<16, T> x) {
  void *p = pt;
  if constexpr (std::same_as<T, float>) {
    __m512 xf = std::bit_cast<__m512>(x);
    _mm512_mask_storeu_ps(p, std::uint16_t(i.mask_), xf);
  } else if constexpr (sizeof(T) == 4) {
    __m512i xi = std::bit_cast<__m512i>(x);
    _mm512_mask_storeu_epi32(p, std::uint16_t(i.mask_), xi);
#ifdef __AVX512VL__
  } else if constexpr (sizeof(T) == 2) {
    __m256i xi = std::bit_cast<__m256i>(x);
    _mm256_mask_storeu_epi16(p, std::uint16_t(i.mask_), xi);
#endif
  } else static_assert(false);
}

// strided memory accesses
template <typename T>
TRIVIAL inline auto gather(const T *pt, mask::None<16>, Vec<16, std::int32_t> i)
  -> Vec<16, T> {
  auto inds = std::bit_cast<__m512i>(i);
  const void *p = pt;
  if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<16, T>>(_mm512_i32gather_ps(inds, p, 4));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<8, T>>(_mm512_i32gather_epi32(inds, p, 4));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<16>, std::int32_t stride)
  -> Vec<16, T> {
  return gather(p, mask::None<16>{}, range<16>() * stride);
}
template <typename T>
TRIVIAL inline auto gather(const T *pt, mask::Bit<8> i,
                           Vec<8, std::int32_t> indv) -> Vec<8, T> {
  auto inds = std::bit_cast<__m256i>(indv);
  const void *p = pt;
  static constexpr auto src = mmzero<8, T>();
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<8, double>>(
      _mm512_mask_i32gather_pd(src, std::uint8_t(i.mask_), inds, p, 8));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<8, T>>(
      _mm512_mask_i32gather_epi64(src, std::uint8_t(i.mask_), inds, p, 8));
#ifdef __AVX512VL__
  else if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<8, float>>(
      _mm256_mmask_i32gather_ps(src, std::uint8_t(i.mask_), inds, p, 4));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<8, T>>(
      _mm256_mmask_i32gather_epi32(src, std::uint8_t(i.mask_), inds, p, 4));
#endif
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto gather(const T *pt, mask::Bit<8> i,
                           Vec<8, std::int64_t> indv) -> Vec<8, T> {
  auto inds = std::bit_cast<__m512i>(indv);
  const void *p = pt;
  static constexpr auto src = mmzero<8, T>();
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<8, double>>(
      _mm512_mask_i64gather_pd(src, std::uint8_t(i.mask_), inds, p, 8));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<8, T>>(
      _mm512_mask_i64gather_epi64(src, std::uint8_t(i.mask_), inds, p, 8));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Bit<8> i, std::int32_t stride)
  -> Vec<8, T> {
  return gather(p, i, range<8>() * stride);
}
template <typename T>
TRIVIAL inline auto gather(const T *pt, mask::Bit<16> i,
                           Vec<16, std::int32_t> indv) -> Vec<16, T> {
  auto inds = std::bit_cast<__m512i>(indv);
  const void *p = pt;
  auto src = mmzero<8, T>();
  if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<16, float>>(
      _mm512_mask_i32gather_ps(src, std::uint16_t(i.mask_), inds, p, 4));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<16, T>>(
      _mm512_mask_i32gather_epi32(src, std::uint16_t(i.mask_), inds, p, 4));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Bit<16> i, std::int32_t stride)
  -> Vec<16, T> {
  return gather(p, i, range<16>() * stride);
}
template <typename T>
TRIVIAL inline void scatter(T *pt, mask::None<8>, Vec<8, T> x,
                            Vec<8, std::int32_t> indv) {
  auto inds = std::bit_cast<__m256i>(indv);
  void *p = pt;
  if constexpr (std::same_as<T, double>)
    _mm512_i32scatter_pd(p, inds, std::bit_cast<__m512d>(x), 8);
  else if constexpr (sizeof(T) == 8)
    _mm512_i32scatter_epi64(p, inds, std::bit_cast<__m512i>(x), 8);
#ifdef __AVX512VL__
  else if constexpr (std::same_as<T, float>)
    _mm256_i32scatter_ps(p, inds, std::bit_cast<__m256>(x), 4);
  else if constexpr (sizeof(T) == 4)
    _mm256_i32scatter_epi32(p, inds, std::bit_cast<__m256i>(x), 4);
#endif
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<8>, Vec<8, T> x,
                          std::int32_t stride) {
  scatter(p, mask::None<8>{}, x, range<8>() * stride);
}

template <typename T>
TRIVIAL inline void scatter(T *pt, mask::None<16>, Vec<16, T> x,
                            Vec<16, std::int32_t> indv) {
  auto inds = std::bit_cast<__m512i>(indv);
  void *p = pt;
  if constexpr (std::same_as<T, float>)
    _mm512_i32scatter_ps(p, inds, std::bit_cast<__m512>(x), 4);
  else if constexpr (sizeof(T) == 4)
    _mm512_i32scatter_epi32(p, inds, std::bit_cast<__m512i>(x), 4);
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<16>, Vec<16, T> x,
                          std::int32_t stride) {
  scatter(p, mask::None<16>{}, x, range<16>() * stride);
}
template <typename T>
TRIVIAL inline void scatter(T *pt, mask::Bit<8> i, Vec<8, T> x,
                            Vec<8, std::int32_t> indv) {
  auto inds = std::bit_cast<__m256i>(indv);
  void *p = pt;
  if constexpr (std::same_as<T, double>)
    _mm512_mask_i32scatter_pd(p, std::uint8_t(i.mask_), inds,
                              std::bit_cast<__m512d>(x), 8);
  else if constexpr (sizeof(T) == 8)
    _mm512_mask_i32scatter_epi64(p, std::uint8_t(i.mask_), inds,
                                 std::bit_cast<__m512i>(x), 8);
#ifdef __AVX512VL__
  else if constexpr (std::same_as<T, float>)
    _mm256_mask_i32scatter_ps(p, std::uint8_t(i.mask_), inds,
                              std::bit_cast<__m256>(x), 4);
  else if constexpr (sizeof(T) == 4)
    _mm256_mask_i32scatter_epi32(p, std::uint8_t(i.mask_), inds,
                                 std::bit_cast<__m256i>(x), 4);
#endif
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Bit<8> i, Vec<8, T> x,
                          std::int32_t stride) {
  scatter(p, i, x, range<8>() * stride);
}
template <typename T>
TRIVIAL inline void scatter(T *pt, mask::Bit<16> i, Vec<16, T> x,
                            Vec<16, std::int32_t> indv) {
  auto inds = std::bit_cast<__m512i>(indv);
  void *p = pt;
  if constexpr (std::same_as<T, float>)
    _mm512_mask_i32scatter_ps(p, std::uint16_t(i.mask_), inds,
                              std::bit_cast<__m512>(x), 4);
  else if constexpr (sizeof(T) == 4)
    _mm512_mask_i32scatter_epi32(p, std::uint16_t(i.mask_), inds,
                                 std::bit_cast<__m512i>(x), 4);
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Bit<16> i, Vec<16, T> x,
                          std::int32_t stride) {
  scatter(p, i, x, range<16>() * stride);
}
template <typename T>
TRIVIAL constexpr auto select(mask::Bit<8> m, Vec<8, T> x, Vec<8, T> y)
  -> Vec<8, T> {
  if constexpr (std::same_as<T, double>) {
    __m512d xd = std::bit_cast<__m512d>(x), yd = std::bit_cast<__m512d>(y);
    return std::bit_cast<Vec<8, T>>(
      _mm512_mask_mov_pd(yd, std::uint8_t(m.mask_), xd));
  } else if constexpr (sizeof(T) == 8) {
    __m512i xi = std::bit_cast<__m512i>(x), yi = std::bit_cast<__m512i>(y);
    return std::bit_cast<Vec<8, T>>(
      _mm512_mask_mov_epi64(yi, std::uint8_t(m.mask_), xi));
#ifdef __AVX512VL__
  } else if constexpr (std::same_as<T, float>) {
    __m256 xf = std::bit_cast<__m256>(x), yf = std::bit_cast<__m256>(y);
    return std::bit_cast<Vec<8, T>>(
      _mm256_mask_mov_ps(yf, std::uint8_t(m.mask_), xf));
  } else if constexpr (sizeof(T) == 4) {
    __m256i xi = std::bit_cast<__m256i>(x), yi = std::bit_cast<__m256i>(y);
    return std::bit_cast<Vec<8, T>>(
      _mm256_mask_mov_epi32(yi, std::uint8_t(m.mask_), xi));
#endif
  } else static_assert(false);
}

template <typename T>
TRIVIAL constexpr auto select(mask::Bit<16> m, Vec<16, T> x, Vec<16, T> y)
  -> Vec<16, T> {
  if constexpr (std::same_as<T, float>) {
    __m512 xf = std::bit_cast<__m512>(x), yf = std::bit_cast<__m512>(y);
    return std::bit_cast<Vec<16, T>>(
      _mm512_mask_mov_ps(yf, std::uint16_t(m.mask_), xf));
  } else if constexpr (sizeof(T) == 4) {
    __m512i xi = std::bit_cast<__m512i>(x), yi = std::bit_cast<__m512i>(y);
    return std::bit_cast<Vec<16, T>>(
      _mm512_mask_mov_epi32(yi, std::uint16_t(m.mask_), xi));
  } else static_assert(false);
}

#endif // AVX512F
#ifdef __AVX__
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<8>) -> Vec<8, T> {
  if constexpr (std::same_as<T, float>) {
    return std::bit_cast<Vec<8, float>>(_mm256_loadu_ps(p));
#ifdef __AVX512F__
  } else if constexpr (sizeof(T) == 4) {
    const void *vp = p;
    return std::bit_cast<Vec<8, T>>(_mm256_loadu_epi32(vp));
  } else if constexpr (sizeof(T) == 2) {
    const void *vp = p;
    return std::bit_cast<Vec<8, T>>(_mm_loadu_epi16(vp));
  } else if constexpr (std::same_as<T, double>) {
    const void *vp = p;
    return std::bit_cast<Vec<8, double>>(_mm512_loadu_pd(vp));
  } else if constexpr (sizeof(T) == 8) {
    const void *vp = p;
    return std::bit_cast<Vec<8, T>>(_mm512_loadu_epi64(vp));
#else
  } else if constexpr (sizeof(T) == 4) {
    const __m256i *pi = reinterpret_cast<const __m256i *>(p);
    return std::bit_cast<Vec<8, T>>(_mm256_loadu_si256(pi));
  } else if constexpr (sizeof(T) == 2) {
    const __m128i *pi = reinterpret_cast<const __m128i *>(p);
    return std::bit_cast<Vec<8, T>>(_mm_loadu_si128(pi));
#endif
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<8>, Vec<8, T> x) {
  if constexpr (std::same_as<T, float>) {
    __m256 xf = std::bit_cast<__m256>(x);
    _mm256_storeu_ps(p, xf);
#ifdef __AVX512F__
  } else if constexpr (sizeof(T) == 4) {
    void *vp = p;
    __m256i xi = std::bit_cast<__m256i>(x);
    _mm256_storeu_epi32(vp, xi);
  } else if constexpr (sizeof(T) == 2) {
    void *vp = p;
    __m128i xi = std::bit_cast<__m128i>(x);
    _mm_storeu_epi16(vp, xi);
  } else if constexpr (std::same_as<T, double>) {
    void *vp = p;
    __m512d xd = std::bit_cast<__m512d>(x);
    _mm512_storeu_pd(vp, xd);
  } else if constexpr (sizeof(T) == 8) {
    void *vp = p;
    __m512i xi = std::bit_cast<__m512i>(x);
    _mm512_storeu_epi64(vp, xi);
#else
  } else if constexpr (sizeof(T) == 4) {
    __m256i xi = std::bit_cast<__m256i>(x);
    _mm256_storeu_si256(reinterpret_cast<__m256i *>(p), xi);
  } else if constexpr (sizeof(T) == 2) {
    __m128i xi = std::bit_cast<__m128i>(x);
    _mm_storeu_si128(reinterpret_cast<__m128i *>(p), xi);
#endif
  } else static_assert(false);
}
#ifdef __AVX2__
// Non-masked gather is same with AVX512VL and AVX2
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<4>, Vec<4, std::int32_t> indv)
  -> Vec<4, T> {
  auto x = std::bit_cast<__m128i>(indv);
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<4, double>>(_mm256_i32gather_pd(p, x, 8));
  else if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<4, float>>(_mm_i32gather_ps(p, x, 4));
  else if constexpr (sizeof(T) == 8) {
    const long long int *pi = reinterpret_cast<const long long int *>(p);
    return std::bit_cast<Vec<4, T>>(_mm256_i32gather_epi64(pi, x, 8));
  } else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<4, T>>(_mm_i32gather_epi32(p, x, 4));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<4>, Vec<4, std::int64_t> indv)
  -> Vec<4, T> {
  auto x = std::bit_cast<__m256i>(indv);
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<4, double>>(_mm256_i64gather_pd(p, x, 8));
  else if constexpr (sizeof(T) == 8) {
    const long long int *pi = reinterpret_cast<const long long int *>(p);
    return std::bit_cast<Vec<4, T>>(_mm256_i64gather_epi64(pi, x, 8));
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<4>, std::int32_t stride)
  -> Vec<4, T> {
  return gather(p, mask::None<4>{}, range<4>() * stride);
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<2>, Vec<2, std::int64_t> indv)
  -> Vec<2, T> {
  auto x = std::bit_cast<__m128i>(indv);
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<2, double>>(_mm_i64gather_pd(p, x, 8));
  else if constexpr (sizeof(T) == 8) {
    const long long int *pi = reinterpret_cast<const long long int *>(p);
    return std::bit_cast<Vec<2, T>>(_mm_i64gather_epi64(pi, x, 8));
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<2>, std::int32_t stride)
  -> Vec<2, T> {
  return gather(p, mask::None<2>{}, range<2>() * stride);
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<8>, Vec<8, std::int32_t> indv)
  -> Vec<8, T> {
  auto inds = std::bit_cast<__m256i>(indv);
  if constexpr (std::same_as<T, float>) {
    return std::bit_cast<Vec<8, T>>(_mm256_i32gather_ps(p, inds, 4));
  } else if constexpr (sizeof(T) == 4) {
    return std::bit_cast<Vec<8, T>>(_mm256_i32gather_epi32(p, inds, 4));
#ifdef __AVX512F__
  } else if constexpr (std::same_as<T, double>) {
    return std::bit_cast<Vec<8, T>>(_mm512_i32gather_pd(inds, p, 8));
  } else if constexpr (sizeof(T) == 8) {
    const long long int *pi = reinterpret_cast<const long long int *>(p);
    return std::bit_cast<Vec<8, T>>(_mm512_i32gather_epi64(inds, pi, 8));
#endif
  } else static_assert(false);
}
#ifdef __AVX512F__
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<8>, Vec<8, std::int64_t> indv)
  -> Vec<8, T> {
  auto inds = std::bit_cast<__m512i>(indv);
  if constexpr (std::same_as<T, double>) {
    return std::bit_cast<Vec<8, T>>(_mm512_i64gather_pd(inds, p, 8));
  } else if constexpr (sizeof(T) == 8) {
    const long long int *pi = reinterpret_cast<const long long int *>(p);
    return std::bit_cast<Vec<8, T>>(_mm512_i64gather_epi64(inds, pi, 8));
  } else static_assert(false);
}
#endif // AVX512F
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<8>, std::int32_t stride)
  -> Vec<8, T> {
  return gather(p, mask::None<8>{}, range<8>() * stride);
}
#endif // AVX2
#endif // AVX

// Here, we handle masked loads/stores
#ifdef __AVX512VL__
template <typename T>
TRIVIAL inline auto load(const T *pt, mask::Bit<4> i) -> Vec<4, T> {
  const void *p = pt;
  if constexpr (std::same_as<T, double>) {
    return std::bit_cast<Vec<4, double>>(
      _mm256_maskz_loadu_pd(std::uint8_t(i.mask_), p));
  } else if constexpr (sizeof(T) == 8) {
    return std::bit_cast<Vec<4, T>>(
      _mm256_maskz_loadu_epi64(std::uint8_t(i.mask_), p));
  } else if constexpr (std::same_as<T, float>) {
    return std::bit_cast<Vec<4, float>>(
      _mm_maskz_loadu_ps(std::uint8_t(i.mask_), p));
  } else if constexpr (sizeof(T) == 4) {
    return std::bit_cast<Vec<4, T>>(
      _mm_maskz_loadu_epi32(std::uint8_t(i.mask_), p));
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *pt, mask::Bit<4> i, Vec<4, T> x) {
  void *p = pt;
  if constexpr (std::same_as<T, double>) {
    __m256d xd = std::bit_cast<__m256d>(x);
    _mm256_mask_storeu_pd(p, std::uint8_t(i.mask_), xd);
  } else if constexpr (sizeof(T) == 8) {
    __m256i xi = std::bit_cast<__m256i>(x);
    _mm256_mask_storeu_epi64(p, std::uint8_t(i.mask_), xi);
  } else if constexpr (std::same_as<T, float>) {
    __m128 xf = std::bit_cast<__m128>(x);
    _mm_mask_storeu_ps(p, std::uint8_t(i.mask_), xf);
  } else if constexpr (sizeof(T) == 4) {
    __m128i xi = std::bit_cast<__m128i>(x);
    _mm_mask_storeu_epi32(p, std::uint8_t(i.mask_), xi);
  } else static_assert(false);
}

template <typename T>
TRIVIAL inline auto load(const T *p, mask::Bit<2> i) -> Vec<2, T> {
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<2, double>>(
      _mm_maskz_loadu_pd(std::uint8_t(i.mask_), p));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<2, T>>(
      _mm_maskz_loadu_epi64(std::uint8_t(i.mask_), p));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Bit<2> i, Vec<2, T> x) {
  if constexpr (std::same_as<T, double>)
    _mm_mask_storeu_pd(p, std::uint8_t(i.mask_), std::bit_cast<__m128d>(x));
  else if constexpr (sizeof(T) == 8)
    _mm_mask_storeu_epi64(p, std::uint8_t(i.mask_), std::bit_cast<__m128i>(x));
  else static_assert(false);
}
// gather/scatter
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Bit<4> i,
                           Vec<4, std::int32_t> indv) -> Vec<4, T> {
  auto inds = std::bit_cast<__m128i>(indv);
  auto src{mmzero<4, T>()};
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<4, double>>(
      _mm256_mmask_i32gather_pd(src, std::uint8_t(i.mask_), inds, p, 8));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<4, T>>(
      _mm256_mmask_i32gather_epi64(src, std::uint8_t(i.mask_), inds, p, 8));
  else if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<4, float>>(
      _mm_mmask_i32gather_ps(src, std::uint8_t(i.mask_), inds, p, 4));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<4, T>>(
      _mm_mmask_i32gather_epi32(src, std::uint8_t(i.mask_), inds, p, 4));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Bit<4> i,
                           Vec<4, std::int64_t> indv) -> Vec<4, T> {
  auto inds = std::bit_cast<__m256i>(indv);
  auto src{mmzero<4, T>()};
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<4, double>>(
      _mm256_mmask_i64gather_pd(src, std::uint8_t(i.mask_), inds, p, 8));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<4, T>>(
      _mm256_mmask_i64gather_epi64(src, std::uint8_t(i.mask_), inds, p, 8));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Bit<4> i, std::int32_t stride)
  -> Vec<4, T> {
  return gather(p, i, range<4>() * stride);
}

template <typename T>
TRIVIAL inline void scatter(T *p, mask::None<4>, Vec<4, T> x,
                            Vec<4, std::int32_t> indv) {
  auto inds = std::bit_cast<__m128i>(indv);
  if constexpr (std::same_as<T, double>)
    _mm256_i32scatter_pd(p, inds, std::bit_cast<__m256d>(x), 8);
  else if constexpr (sizeof(T) == 8)
    _mm256_i32scatter_epi64(p, inds, std::bit_cast<__m256i>(x), 8);
  else if constexpr (std::same_as<T, float>)
    _mm_i32scatter_ps(p, inds, std::bit_cast<__m128>(x), 4);
  else if constexpr (sizeof(T) == 4)
    _mm_i32scatter_epi32(p, inds, std::bit_cast<__m128i>(x), 4);
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<4>, Vec<4, T> x,
                          std::int32_t stride) {
  scatter(p, mask::None<4>{}, x, range<4>() * stride);
}
template <typename T>
TRIVIAL inline void scatter(T *p, mask::Bit<4> i, Vec<4, T> x,
                            Vec<4, std::int32_t> indv) {
  auto inds = std::bit_cast<__m128i>(indv);
  if constexpr (std::same_as<T, double>)
    _mm256_mask_i32scatter_pd(p, std::uint8_t(i.mask_), inds,
                              std::bit_cast<__m256d>(x), 8);
  else if constexpr (sizeof(T) == 8)
    _mm256_mask_i32scatter_epi64(p, std::uint8_t(i.mask_), inds,
                                 std::bit_cast<__m256i>(x), 8);
  else if constexpr (std::same_as<T, double>)
    _mm_mask_i32scatter_ps(p, std::uint8_t(i.mask_), inds,
                           std::bit_cast<__m128>(x), 4);
  else if constexpr (sizeof(T) == 4)
    _mm_mask_i32scatter_epi32(p, std::uint8_t(i.mask_), inds,
                              std::bit_cast<__m128i>(x), 4);
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Bit<4> i, Vec<4, T> x,
                          std::int32_t stride) {
  scatter(p, i, x, range<4>() * stride);
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Bit<2> i,
                           Vec<2, std::int64_t> indv) -> Vec<2, T> {
  auto inds = std::bit_cast<__m128i>(indv);
  auto src{mmzero<2, T>()};
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<2, double>>(
      _mm_mmask_i64gather_pd(src, std::uint8_t(i.mask_), inds, p, 8));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<2, T>>(
      _mm_mmask_i64gather_epi64(src, std::uint8_t(i.mask_), inds, p, 8));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Bit<2> i, std::int32_t stride)
  -> Vec<2, T> {
  return gather(p, i, range<2>() * stride);
}
template <typename T>
TRIVIAL inline void scatter(T *p, mask::None<2>, Vec<2, T> x,
                            Vec<2, std::int64_t> indv) {
  auto inds = std::bit_cast<__m128i>(indv);
  if constexpr (std::same_as<T, double>)
    _mm_i64scatter_pd(p, inds, std::bit_cast<__m128d>(x), 8);
  else if constexpr (sizeof(T) == 8)
    _mm_i64scatter_epi64(p, inds, std::bit_cast<__m128i>(x), 8);
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<2>, Vec<2, T> x,
                          std::int32_t stride) {
  scatter(p, mask::None<2>{}, x, range<2>() * stride);
}
template <typename T>
TRIVIAL inline void scatter(T *p, mask::Bit<2> i, Vec<2, T> x,
                            Vec<2, std::int64_t> indv) {
  auto inds = std::bit_cast<__m128i>(indv);
  if constexpr (std::same_as<T, double>)
    _mm_mask_i64scatter_pd(p, std::uint8_t(i.mask_), inds,
                           std::bit_cast<__m128d>(x), 8);
  else if constexpr (sizeof(T) == 8)
    _mm_mask_i64scatter_epi64(p, std::uint8_t(i.mask_), inds,
                              std::bit_cast<__m128i>(x), 8);
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Bit<2> i, Vec<2, T> x,
                          std::int32_t stride) {
  scatter(p, i, x, range<2>() * stride);
}

template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto fmadd(Vec<W, T> a, Vec<W, T> b, Vec<W, T> c,
                          mask::Bit<W> m) {
  if constexpr (std::same_as<T, double>) {
    if constexpr (W == 8) {
      return std::bit_cast<Vec<W, T>>(_mm512_mask3_fmadd_pd(
        std::bit_cast<__m512d>(a), std::bit_cast<__m512d>(b),
        std::bit_cast<__m512d>(c), std::uint8_t(m.mask_)));
    } else if constexpr (W == 4) {
      return std::bit_cast<Vec<W, T>>(_mm256_mask3_fmadd_pd(
        std::bit_cast<__m256d>(a), std::bit_cast<__m256d>(b),
        std::bit_cast<__m256d>(c), std::uint8_t(m.mask_)));
    } else {
      static_assert(W == 2);
      return std::bit_cast<Vec<W, T>>(
        _mm_mask3_fmadd_pd(std::bit_cast<__m128d>(a), std::bit_cast<__m128d>(b),
                           std::bit_cast<__m128d>(c), std::uint8_t(m.mask_)));
    }
  } else {
    static_assert(std::same_as<T, float>);
    if constexpr (W == 16) {
      return std::bit_cast<Vec<W, T>>(_mm512_mask3_fmadd_ps(
        std::bit_cast<__m512>(a), std::bit_cast<__m512>(b),
        std::bit_cast<__m512>(c), std::uint16_t(m.mask_)));
    } else if constexpr (W == 8) {
      return std::bit_cast<Vec<W, T>>(_mm256_mask3_fmadd_ps(
        std::bit_cast<__m256>(a), std::bit_cast<__m256>(b),
        std::bit_cast<__m256>(c), std::uint8_t(m.mask_)));
    } else {
      static_assert(W == 4);
      return std::bit_cast<Vec<W, T>>(
        _mm_mask3_fmadd_ps(std::bit_cast<__m128>(a), std::bit_cast<__m128>(b),
                           std::bit_cast<__m128>(c), std::uint8_t(m.mask_)));
    }
  }
}

template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto fnmadd(Vec<W, T> a, Vec<W, T> b, Vec<W, T> c,
                           mask::Bit<W> m) {
  if constexpr (std::same_as<T, double>) {
    if constexpr (W == 8) {
      return std::bit_cast<Vec<W, T>>(_mm512_mask3_fnmadd_pd(
        std::bit_cast<__m512d>(a), std::bit_cast<__m512d>(b),
        std::bit_cast<__m512d>(c), std::uint8_t(m.mask_)));
    } else if constexpr (W == 4) {
      return std::bit_cast<Vec<W, T>>(_mm256_mask3_fnmadd_pd(
        std::bit_cast<__m256d>(a), std::bit_cast<__m256d>(b),
        std::bit_cast<__m256d>(c), std::uint8_t(m.mask_)));
    } else {
      static_assert(W == 2);
      return std::bit_cast<Vec<W, T>>(_mm_mask3_fnmadd_pd(
        std::bit_cast<__m128d>(a), std::bit_cast<__m128d>(b),
        std::bit_cast<__m128d>(c), std::uint8_t(m.mask_)));
    }
  } else {
    static_assert(std::same_as<T, float>);
    if constexpr (W == 16) {
      return std::bit_cast<Vec<W, T>>(_mm512_mask3_fnmadd_ps(
        std::bit_cast<__m512>(a), std::bit_cast<__m512>(b),
        std::bit_cast<__m512>(c), std::uint16_t(m.mask_)));
    } else if constexpr (W == 8) {
      return std::bit_cast<Vec<W, T>>(_mm256_mask3_fnmadd_ps(
        std::bit_cast<__m256>(a), std::bit_cast<__m256>(b),
        std::bit_cast<__m256>(c), std::uint8_t(m.mask_)));
    } else {
      static_assert(W == 4);
      return std::bit_cast<Vec<W, T>>(
        _mm_mask3_fnmadd_ps(std::bit_cast<__m128>(a), std::bit_cast<__m128>(b),
                            std::bit_cast<__m128>(c), std::uint8_t(m.mask_)));
    }
  }
}
template <typename T>
TRIVIAL constexpr auto select(mask::Bit<4> m, Vec<4, T> x, Vec<4, T> y)
  -> Vec<4, T> {
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<4, T>>(
      _mm256_mask_mov_pd(std::bit_cast<__m256d>(y), std::uint8_t(m.mask_),
                         std::bit_cast<__m256d>(x)));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<4, T>>(
      _mm256_mask_mov_epi64(std::bit_cast<__m256i>(y), std::uint8_t(m.mask_),
                            std::bit_cast<__m256i>(x)));
  else if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<4, T>>(_mm_mask_mov_ps(std::bit_cast<__m128>(y),
                                                    std::uint8_t(m.mask_),
                                                    std::bit_cast<__m128>(x)));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<4, T>>(
      _mm_mask_mov_epi32(std::bit_cast<__m128i>(y), std::uint8_t(m.mask_),
                         std::bit_cast<__m128i>(x)));
  else static_assert(false);
}
template <typename T>
TRIVIAL constexpr auto select(mask::Bit<2> m, Vec<2, T> x, Vec<2, T> y)
  -> Vec<2, T> {
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<2, T>>(_mm_mask_mov_pd(std::bit_cast<__m128d>(y),
                                                    std::uint8_t(m.mask_),
                                                    std::bit_cast<__m128d>(x)));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<2, T>>(
      _mm_mask_mov_epi64(std::bit_cast<__m128i>(y), std::uint8_t(m.mask_),
                         std::bit_cast<__m128i>(x)));
  else static_assert(false);
}

#else // No AVX512VL
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto fmadd(Vec<W, T> a, Vec<W, T> b, Vec<W, T> c,
                          mask::Mask<W> m) {
  if constexpr ((W * sizeof(T)) != 64) return m.m ? (a * b + c) : c;
  else if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<W, T>>(_mm512_mask3_fmadd_pd(
      std::bit_cast<__m512d>(a), std::bit_cast<__m512d>(b),
      std::bit_cast<__m512d>(c), std::uint8_t(m.mask_)));
  else if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<W, T>>(
      _mm512_mask3_fmadd_ps(std::bit_cast<__m512>(a), std::bit_cast<__m512>(b),
                            std::bit_cast<__m512>(c), std::uint16_t(m.mask_)));
  else static_assert(false);
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto fnmadd(Vec<W, T> a, Vec<W, T> b, Vec<W, T> c,
                           mask::Mask<W> m) {
  if constexpr ((W * sizeof(T)) != 64) return m.m ? (c - a * b) : c;
  else if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<W, T>>(_mm512_mask3_fnmadd_pd(
      std::bit_cast<__m512d>(a), std::bit_cast<__m512d>(b),
      std::bit_cast<__m512d>(c), std::uint8_t(m.mask_)));
  else if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<W, T>>(
      _mm512_mask3_fnmadd_ps(std::bit_cast<__m512>(a), std::bit_cast<__m512>(b),
                             std::bit_cast<__m512>(c), std::uint16_t(m.mask_)));
  else static_assert(false);
}

// We need [gather, scatter, load, store] * [unmasked, masked]

// 128 bit fallback scatters
template <typename T>
TRIVIAL inline void store(T *p, mask::None<2>, Vec<2, T> x,
                          std::int32_t stride) {
  p[0] = x[0];
  p[stride] = x[1];
}
template <typename T>
TRIVIAL inline void scatter(T *p, mask::None<2>, Vec<2, T> x,
                            Vec<2, std::int64_t> i) {
  p[i[0]] = x[0];
  p[i[1]] = x[1];
}

template <typename T>
TRIVIAL inline void store(T *p, mask::Vector<2, sizeof(T)> i, Vec<2, T> x,
                          std::int32_t stride) {
  if (i.m[0] != 0) p[0] = x[0];
  if (i.m[1] != 0) p[stride] = x[1];
}
template <typename T>
TRIVIAL inline void scatter(T *p, mask::Vector<2, sizeof(T)> i, Vec<2, T> x,
                            Vec<2, std::int64_t> indv) {
  if (i.m[0] != 0) p[indv[0]] = x[0];
  if (i.m[1] != 0) p[indv[1]] = x[1];
}

#ifdef __AVX2__
// masked gathers
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<4, sizeof(T)> m,
                           Vec<4, std::int32_t> indv) -> Vec<4, T> {
  auto x = std::bit_cast<__m128i>(indv);
  static constexpr auto z = mmzero<4, T>();
  if constexpr (std::same_as<T, double>) {
    return std::bit_cast<Vec<4, double>>(
      _mm256_mask_i32gather_pd(z, p, x, m, 8));
  } else if constexpr (sizeof(T) == 8) {
    const long long int *l = reinterpret_cast<const long long int *>(p);
    return std::bit_cast<Vec<4, T>>(_mm256_mask_i32gather_epi64(z, l, x, m, 8));
  } else if constexpr (std::same_as<T, float>) {
    return std::bit_cast<Vec<4, float>>(_mm_mask_i32gather_ps(z, p, x, m, 4));
  } else if constexpr (sizeof(T) == 4) {
    return std::bit_cast<Vec<4, T>>(_mm_mask_i32gather_epi32(z, p, x, m, 4));
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<4, sizeof(T)> m,
                           Vec<4, std::int64_t> indv) -> Vec<4, T> {
  auto x = std::bit_cast<__m256i>(indv);
  static constexpr auto z = mmzero<4, T>();
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<4, double>>(
      _mm256_mask_i64gather_pd(z, p, x, m, 8));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<4, T>>(_mm256_mask_i64gather_epi64(z, p, x, m, 8));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<4, sizeof(T)> m,
                         std::int32_t stride) -> Vec<4, T> {
  return gather(p, m, range<4>() * stride);
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<2, sizeof(T)> m,
                           Vec<2, std::int64_t> indv) -> Vec<2, T> {
  auto x = std::bit_cast<__m128i>(indv);
  __m128i mask = __m128i(m);
  static constexpr auto z = mmzero<2, T>();
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<2, double>>(
      _mm_mask_i64gather_pd(z, p, x, mask, 8));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<2, T>>(_mm_mask_i64gather_epi64(z, p, x, mask, 8));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<2, sizeof(T)> m,
                         std::int32_t stride) -> Vec<2, T> {
  return gather(p, m, range<2>() * stride);
}

#else // no AVX2
// fallback 128-bit gather
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<2>, std::int32_t stride)
  -> Vec<2, T> {
  return Vec<2, T>{p[0], p[stride]};
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<2>, Vec<2, std::int64_t> i)
  -> Vec<2, T> {
  return Vec<2, T>{p[i[0]], p[i[1]]};
}

template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<2, sizeof(T)> i,
                         std::int32_t stride) -> Vec<2, T> {
  return Vec<2, T>{(i.m[0] != 0) ? p[0] : T{}, (i.m[1] != 0) ? p[stride] : T{}};
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<2, sizeof(T)> i,
                           Vec<2, std::int64_t> indv) -> Vec<2, T> {
  return Vec<2, T>{(i.m[0] != 0) ? p[indv[0]] : T{},
                   (i.m[1] != 0) ? p[indv[1]] : T{}};
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<2, sizeof(T)> i,
                           Vec<2, std::int32_t> indv) -> Vec<2, T> {
  return Vec<2, T>{(i.m[0] != 0) ? p[indv[0]] : T{},
                   (i.m[1] != 0) ? p[indv[1]] : T{}};
}

template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<4>, std::int32_t stride)
  -> Vec<4, T> {
  return Vec<4, T>{p[0], p[stride], p[2 * stride], p[3 * stride]};
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<4>, Vec<4, std::int32_t> i)
  -> Vec<4, T> {
  return Vec<4, T>{p[i[0]], p[i[1]], p[i[2]], p[i[3]]};
}

template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<4, sizeof(T)> i,
                         std::int32_t stride) -> Vec<4, T> {
  return Vec<4, T>{(i.m[0] != 0) ? p[0] : T{}, (i.m[1] != 0) ? p[stride] : T{},
                   (i.m[2] != 0) ? p[2 * stride] : T{},
                   (i.m[3] != 0) ? p[3 * stride] : T{}};
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<4, sizeof(T)> i,
                           Vec<4, int> indv) -> Vec<4, T> {
  return Vec<4, T>{
    (i.m[0] != 0) ? p[indv[0]] : T{}, (i.m[1] != 0) ? p[indv[1]] : T{},
    (i.m[2] != 0) ? p[indv[2]] : T{}, (i.m[3] != 0) ? p[indv[3]] : T{}};
}

#ifdef __AVX__ // no AVX2, but AVX
// fallback 256-bit gather
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<4>, std::int32_t stride)
  -> Vec<4, T> {
  return Vec<4, T>{p[0], p[stride], p[2 * stride], p[3 * stride]};
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<4>, Vec<4, std::int32_t> i)
  -> Vec<4, T> {
  return Vec<4, T>{p[i[0]], p[i[1]], p[i[2]], p[i[3]]};
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::None<4>, Vec<4, std::int64_t> i)
  -> Vec<4, T> {
  return Vec<4, T>{p[i[0]], p[i[1]], p[i[2]], p[i[3]]};
}

template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<4, sizeof(T)> i,
                         std::int32_t stride) -> Vec<4, T> {
  return Vec<4, T>{
    (i.m[0] != 0) ? p[0] : T{},
    (i.m[1] != 0) ? p[stride] : T{},
    (i.m[2] != 0) ? p[2 * stride] : T{},
    (i.m[3] != 0) ? p[3 * stride] : T{},
  };
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<4, sizeof(T)> i,
                           Vec<4, std::int32_t> indv) -> Vec<4, T> {
  return Vec<4, T>{
    (i.m[0] != 0) ? p[indv[0]] : T{},
    (i.m[1] != 0) ? p[indv[1]] : T{},
    (i.m[2] != 0) ? p[indv[2]] : T{},
    (i.m[3] != 0) ? p[indv[3]] : T{},
  };
}
template <typename T>
TRIVIAL inline auto gather(const T *p, mask::Vector<4, sizeof(T)> i,
                           Vec<4, std::int64_t> indv) -> Vec<4, T> {
  return Vec<4, T>{
    (i.m[0] != 0) ? p[indv[0]] : T{},
    (i.m[1] != 0) ? p[indv[1]] : T{},
    (i.m[2] != 0) ? p[indv[2]] : T{},
    (i.m[3] != 0) ? p[indv[3]] : T{},
  };
}

#endif // AVX
#endif // no AVX2
#ifdef __AVX__
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<4, sizeof(T)> i)
  -> Vec<4, T> {
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<4, double>>(_mm256_maskload_pd(p, i));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<4, T>>(
      _mm256_maskload_epi64((const long long *)p, i));
  else if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<4, float>>(_mm_maskload_ps(p, i));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<4, T>>(_mm_maskload_epi32((const int *)p, i));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<8, sizeof(T)> i)
  -> Vec<8, T> {
  if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<8, float>>(_mm256_maskload_ps(p, i));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<8, T>>(_mm256_maskload_epi32((const int *)p, i));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Vector<4, sizeof(T)> i, Vec<4, T> x) {
  if constexpr (std::same_as<T, double>)
    _mm256_maskstore_pd(p, i, std::bit_cast<__m256d>(x));
  else if constexpr (sizeof(T) == 8)
    _mm256_maskstore_epi64((long long *)p, i, std::bit_cast<__m256i>(x));
  else if constexpr (std::same_as<T, float>)
    _mm_maskstore_ps(p, i, std::bit_cast<__m128>(x));
  else if constexpr (sizeof(T) == 4)
    _mm_maskstore_epi32((int *)p, i, std::bit_cast<__m128i>(x));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Vector<8, sizeof(T)> i, Vec<8, T> x) {
  if constexpr (std::same_as<T, float>)
    _mm256_maskstore_ps(p, i, std::bit_cast<__m256>(x));
  else if constexpr (sizeof(T) == 4)
    _mm256_maskstore_epi32((int *)p, i, std::bit_cast<__m256i>(x));
  else static_assert(false);
}

template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<2, sizeof(T)> i)
  -> Vec<2, T> {
  if constexpr (std::same_as<T, double>)
    return std::bit_cast<Vec<2, double>>(_mm_maskload_pd(p, i));
  else if constexpr (sizeof(T) == 8)
    return std::bit_cast<Vec<2, T>>(
      _mm_maskload_epi64((const long long *)p, i));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Vector<2, sizeof(T)> i, Vec<2, T> x) {
  if constexpr (std::same_as<T, double>)
    _mm_maskstore_pd(p, i, std::bit_cast<__m128d>(x));
  else if constexpr (sizeof(T) == 8)
    _mm_maskstore_epi64((long long *)p, i, std::bit_cast<__m128i>(x));
  else static_assert(false);
}

// we need 256 bit fallback scatters
template <typename T>
TRIVIAL inline void store(T *p, mask::None<4>, Vec<4, T> x,
                          std::int32_t stride) {
  p[0] = x[0];
  p[stride] = x[1];
  p[2 * stride] = x[2];
  p[3 * stride] = x[3];
}
template <typename T>
TRIVIAL inline void scatter(T *p, mask::None<4>, Vec<4, T> x,
                            Vec<4, std::int32_t> i) {
  p[i[0]] = x[0];
  p[i[1]] = x[1];
  p[i[2]] = x[2];
  p[i[3]] = x[3];
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Vector<4, sizeof(T)> i, Vec<4, T> x,
                          std::int32_t stride) {
  if (i.m[0] != 0) p[0] = x[0];
  if (i.m[1] != 0) p[stride] = x[1];
  if (i.m[2] != 0) p[2 * stride] = x[2];
  if (i.m[3] != 0) p[3 * stride] = x[3];
}
template <typename T>
TRIVIAL inline void scatter(T *p, mask::Vector<4, sizeof(T)> i, Vec<4, T> x,
                            Vec<4, std::int32_t> indv) {
  if (i.m[0] != 0) p[indv[0]] = x[0];
  if (i.m[1] != 0) p[indv[1]] = x[1];
  if (i.m[2] != 0) p[indv[2]] = x[2];
  if (i.m[3] != 0) p[indv[3]] = x[3];
}
#else // No AVX
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<2, sizeof(T)> i)
  -> Vec<2, T> {
  return Vec<2, T>{(i.m[0] != 0) ? p[0] : T{}, (i.m[1] != 0) ? p[1] : T{}};
}
template <typename T>
TRIVIAL inline auto load(const T *p, mask::Vector<4, sizeof(T)> i)
  -> Vec<4, T> {
  return Vec<4, T>{(i.m[0] != 0) ? p[0] : T{}, (i.m[1] != 0) ? p[1] : T{},
                   (i.m[2] != 0) ? p[2] : T{}, (i.m[3] != 0) ? p[3] : T{}};
}

template <typename T>
TRIVIAL inline void store(T *p, mask::Vector<2, sizeof(T)> i, Vec<2, T> x) {
  if (i.m[0] != 0) p[0] = x[0];
  if (i.m[1] != 0) p[1] = x[1];
}
template <typename T>
TRIVIAL inline void store(T *p, mask::Vector<4, sizeof(T)> i, Vec<4, T> x) {
  if (i.m[0] != 0) p[0] = x[0];
  if (i.m[1] != 0) p[1] = x[1];
  if (i.m[2] != 0) p[2] = x[2];
  if (i.m[3] != 0) p[3] = x[3];
}

#endif // No AVX
#endif // No AVX512VL
#ifdef __AVX__
template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<4>) -> Vec<4, T> {
  if constexpr (std::same_as<T, double>) {
    return std::bit_cast<Vec<4, double>>(_mm256_loadu_pd(p));
  } else if constexpr (sizeof(T) == 8) {
#ifdef __AVX512VL__
    const void *vp = p;
    return std::bit_cast<Vec<4, T>>(_mm256_loadu_epi64(vp));
#else
    const __m256i *pi = reinterpret_cast<const __m256i *>(p);
    return std::bit_cast<Vec<4, T>>(_mm256_loadu_si256(pi));
#endif
  } else if constexpr (std::same_as<T, float>) {
    return std::bit_cast<Vec<4, float>>(_mm_loadu_ps(p));
  } else if constexpr (sizeof(T) == 4) {
#ifdef __AVX512VL__
    const void *vp = p;
    return std::bit_cast<Vec<4, T>>(_mm_loadu_epi32(vp));
#else
    const __m128i *pi = reinterpret_cast<const __m128i *>(p);
    return std::bit_cast<Vec<4, T>>(_mm_loadu_si128(pi));
#endif
  } else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<4>, Vec<4, T> x) {
  if constexpr (std::same_as<T, double>) {
    __m256d xd = std::bit_cast<__m256d>(x);
    _mm256_storeu_pd(p, xd);
  } else if constexpr (sizeof(T) == 8) {
    __m256i xi = std::bit_cast<__m256i>(x);
#ifdef __AVX512VL__
    void *vp = p;
    _mm256_storeu_epi64(vp, xi);
#else
    __m256i *pi = reinterpret_cast<__m256i *>(p);
    _mm256_storeu_si256(pi, xi);
#endif
  } else if constexpr (std::same_as<T, float>) {
    __m128 xf = std::bit_cast<__m128>(x);
    _mm_storeu_ps(p, xf);
  } else if constexpr (sizeof(T) == 4) {
    __m128i xi = std::bit_cast<__m128i>(x);
#ifdef __AVX512VL__
    void *vp = p;
    _mm_storeu_epi32(vp, xi);
#else
    __m128i *pi = reinterpret_cast<__m128i *>(p);
    _mm_storeu_si128(pi, xi);
#endif
  } else static_assert(false);
}

// // non-power-of-2 memory ops
// template <std::ptrdiff_t N, typename M>
// constexpr auto fixupnonpow2(index::Vector<N, M> i) {
//   static_assert(std::popcount(std::size_t(N)) > 1,
//                 "Shouldn't be calling this if not needed.");
//   static constexpr std::ptrdiff_t W = std::bit_ceil(std::size_t(N));
//   auto m = i.mask_ & mask(index::VectorMask<W>{N});
//   return index::Vector<W, decltype(m)>{i.i, m};
// }

// template <typename T, std::ptrdiff_t N, typename M>
// TRIVIAL inline auto
// load(const T *p, index::Vector<N, M> i) {
//   return load(p, fixupnonpow2(i));
// }
// template <typename T, std::ptrdiff_t N, typename M>
// TRIVIAL inline auto
// load(const T *p, index::Vector<N, M> i, std::int32_t stride) {
//   return load(p, fixupnonpow2(i), stride);
// }
// template <typename T, std::ptrdiff_t N, typename M, std::ptrdiff_t W>
// TRIVIAL inline void
// store(T *p, index::Vector<N, M> i, Vec<W, T> x) {
//   store(p, fixupnonpow2(i), x);
// }
// template <typename T, std::ptrdiff_t N, typename M, std::ptrdiff_t W>
// TRIVIAL inline void
// store(T *p, index::Vector<N, M> i, Vec<W, T> x, std::int32_t stride) {
//   store(p, fixupnonpow2(i), stride);
// }
#else // NO AVX:

template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<4>) -> Vec<4, T> {
  if constexpr (std::same_as<T, float>)
    return std::bit_cast<Vec<4, float>>(_mm_loadu_ps(p));
  else if constexpr (sizeof(T) == 4)
    return std::bit_cast<Vec<4, T>>(_mm_loadu_si128((const __m128i *)p));
  else static_assert(false);
}
template <typename T>
TRIVIAL inline void store(T *p, mask::None<4>, Vec<4, T> x) {
  if constexpr (std::same_as<T, float>)
    _mm_storeu_pd(p, std::bit_cast<__m128d>(x));
  else if constexpr (sizeof(T) == 4) {
    __m128i *pi = reinterpret_cast<__m128i *>(p);
    __m128i xi = std::bit_cast<__m128i>(x);
    _mm_storeu_si128(pi, xi);
  } else static_assert(false);
}

#endif // AVX

template <typename T>
TRIVIAL inline auto load(const T *p, mask::None<2>) -> Vec<2, T> {
  if constexpr (std::same_as<T, double>) {
    double const *dp = p;
    return std::bit_cast<Vec<2, double>>(_mm_loadu_pd(dp));
    // return std::bit_cast<Vec<2, double>>(_mm_loadu_pd(p));
  } else if constexpr (sizeof(T) == 8)
#ifdef __AVX512VL__
    return std::bit_cast<Vec<2, T>>(_mm_loadu_epi64(p));
#else
    return std::bit_cast<Vec<2, T>>(_mm_loadu_si128((const __m128i *)p));
#endif
  else return Vec<2, T>{p[0], p[1]};
  // else static_assert(false);
}

template <typename T>
TRIVIAL inline void store(T *p, mask::None<2>, Vec<2, T> x) {
  if constexpr (std::same_as<T, double>) {
    double *dp = p;
    __m128d xpd = std::bit_cast<__m128d>(x);
    _mm_storeu_pd(dp, xpd);
  } else if constexpr (sizeof(T) == 8) {
    __m128i xi = std::bit_cast<__m128i>(x);
#ifdef __AVX512VL__
    void *vp = p;
    _mm_storeu_epi64(vp, xi);
#else
    __m128i *pi = reinterpret_cast<__m128i *>(p);
    _mm_storeu_si128(pi, xi);
#endif
  } else {
    p[0] = x[0];
    p[1] = x[1];
  }
  // else static_assert(false);
}

#ifdef __AVX512F__
template auto load<std::int64_t>(const std::int64_t *, mask::None<2>)
  -> Vec<2, std::int64_t>;
template auto load<std::int64_t>(const std::int64_t *, mask::Bit<2>)
  -> Vec<2, std::int64_t>;
template void store<std::int64_t>(std::int64_t *, mask::None<2>,
                                  Vec<2, std::int64_t>);
template void store<std::int64_t>(std::int64_t *, mask::Bit<2>,
                                  Vec<2, std::int64_t>);
template auto load<std::int64_t>(const std::int64_t *, mask::None<4>)
  -> Vec<4, std::int64_t>;
template auto load<std::int64_t>(const std::int64_t *, mask::Bit<4>)
  -> Vec<4, std::int64_t>;
template void store<std::int64_t>(std::int64_t *, mask::None<4>,
                                  Vec<4, std::int64_t>);
template void store<std::int64_t>(std::int64_t *, mask::Bit<4>,
                                  Vec<4, std::int64_t>);
template auto load<std::int64_t>(const std::int64_t *, mask::None<8>)
  -> Vec<8, std::int64_t>;
template auto load<std::int64_t>(const std::int64_t *, mask::Bit<8>)
  -> Vec<8, std::int64_t>;
template void store<std::int64_t>(std::int64_t *, mask::None<8>,
                                  Vec<8, std::int64_t>);
template void store<std::int64_t>(std::int64_t *, mask::Bit<8>,
                                  Vec<8, std::int64_t>);

template auto load<std::int64_t>(const std::int64_t *, mask::None<2>,
                                 std::int32_t) -> Vec<2, std::int64_t>;
template auto load<std::int64_t>(const std::int64_t *, mask::Bit<2>,
                                 std::int32_t) -> Vec<2, std::int64_t>;
template void store<std::int64_t>(std::int64_t *, mask::None<2>,
                                  Vec<2, std::int64_t>, std::int32_t);
template void store<std::int64_t>(std::int64_t *, mask::Bit<2>,
                                  Vec<2, std::int64_t>, std::int32_t);
template auto load<std::int64_t>(const std::int64_t *, mask::None<4>,
                                 std::int32_t) -> Vec<4, std::int64_t>;
template auto load<std::int64_t>(const std::int64_t *, mask::Bit<4>,
                                 std::int32_t) -> Vec<4, std::int64_t>;
template void store<std::int64_t>(std::int64_t *, mask::None<4>,
                                  Vec<4, std::int64_t>, std::int32_t);
template void store<std::int64_t>(std::int64_t *, mask::Bit<4>,
                                  Vec<4, std::int64_t>, std::int32_t);
template auto load<std::int64_t>(const std::int64_t *, mask::None<8>,
                                 std::int32_t) -> Vec<8, std::int64_t>;
template auto load<std::int64_t>(const std::int64_t *, mask::Bit<8>,
                                 std::int32_t) -> Vec<8, std::int64_t>;
template void store<std::int64_t>(std::int64_t *, mask::None<8>,
                                  Vec<8, std::int64_t>, std::int32_t);
template void store<std::int64_t>(std::int64_t *, mask::Bit<8>,
                                  Vec<8, std::int64_t>, std::int32_t);
#endif

#else // not __x86_64__
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto load(const T *p, mask::None<W>) -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) ret[w] = p[w];
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline void store(T *p, mask::None<W>, Vec<W, T> x) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) p[w] = x[w];
}

template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto load(const T *p, mask::Vector<W, 4> i) -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) ret[w] = (i.m[w] != 0) ? p[w] : T{};
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto load(const T *p, mask::Vector<W, 8> i) -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) ret[w] = (i.m[w] != 0) ? p[w] : T{};
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline void store(T *p, mask::Vector<W, 4> i, Vec<W, T> x) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    if (i.m[w] != 0) p[w] = x[w];
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline void store(T *p, mask::Vector<W, 8> i, Vec<W, T> x) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    if (i.m[w] != 0) p[w] = x[w];
}

template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto load(const T *p, mask::None<W>, std::int32_t stride)
  -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) ret[w] = p[w * stride];
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto gather(const T *p, mask::None<W>, Vec<W, std::int32_t> indv)
  -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) ret[w] = p[indv[w]];
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto gather(const T *p, mask::None<W>, Vec<W, std::int64_t> indv)
  -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) ret[w] = p[indv[w]];
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline void store(T *p, mask::None<W>, Vec<W, T> x,
                          std::int32_t stride) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) p[w * stride] = x[w];
}
template <typename T, std::ptrdiff_t W, std::integral I>
TRIVIAL inline void scatter(T *p, mask::None<W>, Vec<W, T> x, Vec<W, I> indv) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w) p[indv[w]] = x[w];
}

template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto load(const T *p, mask::Vector<W, 4> i, std::int32_t stride)
  -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    ret[w] = (i.m[w] != 0) ? p[w * stride] : T{};
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto load(const T *p, mask::Vector<W, 8> i, std::int32_t stride)
  -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    ret[w] = (i.m[w] != 0) ? p[w * stride] : T{};
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto gather(const T *p, mask::Vector<W, sizeof(T)> i,
                           Vec<W, std::int32_t> indv) -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    ret[w] = (i.m[w] != 0) ? p[indv[w]] : T{};
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto gather(const T *p, mask::Vector<W, sizeof(T)> i,
                           Vec<W, std::int64_t> indv) -> Vec<W, T> {
  Vec<W, T> ret;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    ret[w] = (i.m[w] != 0) ? p[indv[w]] : T{};
  return ret;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline void store(T *p, mask::Vector<W, 4> i, Vec<W, T> x,
                          std::int32_t stride) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    if (i.m[w] != 0) p[w * stride] = x[w];
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline void store(T *p, mask::Vector<W, 8> i, Vec<W, T> x,
                          std::int32_t stride) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    if (i.m[w] != 0) p[w * stride] = x[w];
}
template <typename T, std::ptrdiff_t W, std::integral I>
TRIVIAL inline void scatter(T *p, mask::Vector<W, sizeof(T)> i, Vec<W, T> x,
                            Vec<W, I> indv) {
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t w = 0; w < W; ++w)
    if (i.m[w] != 0) p[indv[w]] = x[w];
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto fmadd(Vec<W, T> a, Vec<W, T> b, Vec<W, T> c,
                          mask::Vector<W, sizeof(T)> m) {
  return m.m ? (a * b + c) : c;
}
template <typename T, std::ptrdiff_t W>
TRIVIAL inline auto fnmadd(Vec<W, T> a, Vec<W, T> b, Vec<W, T> c,
                           mask::Vector<W, sizeof(T)> m) {
  return m.m ? (c - a * b) : c;
}

#endif
#ifndef __AVX512F__
template <typename T, std::ptrdiff_t W>
TRIVIAL constexpr auto select(mask::Vector<W, sizeof(T)> m, Vec<W, T> x,
                              Vec<W, T> y) -> Vec<W, T> {
  return m.m ? x : y;
}
#endif
#ifdef __AVX512CD__

// count left zeros
template <std::ptrdiff_t W, std::integral T>
TRIVIAL inline constexpr auto clz(Vec<W, T> v) {
  static_assert((sizeof(T) == 4) || (sizeof(T) == 8));
  if constexpr (W == 16) {
    static_assert(sizeof(T) == 4);
    __m512i vi = std::bit_cast<__m512i>(v);
    return std::bit_cast<Vec<W, T>>(_mm512_lzcnt_epi32(vi));
  } else if constexpr (W == 8) {
    if constexpr (sizeof(T) == 8) {
      __m512i vi = std::bit_cast<__m512i>(v);
      return std::bit_cast<Vec<W, T>>(_mm512_lzcnt_epi64(vi));
    } else {
      __m256i vi = std::bit_cast<__m256i>(v);
      return std::bit_cast<Vec<W, T>>(_mm256_lzcnt_epi32(vi));
    }
  } else if constexpr (W == 4) {
    if constexpr (sizeof(T) == 8) {
      __m256i vi = std::bit_cast<__m256i>(v);
      return std::bit_cast<Vec<W, T>>(_mm256_lzcnt_epi64(vi));
    } else {
      __m128i vi = std::bit_cast<__m128i>(v);
      return std::bit_cast<Vec<W, T>>(_mm_lzcnt_epi32(vi));
    }
  } else {
    static_assert(sizeof(T) == 8);
    __m128i vi = std::bit_cast<__m128i>(v);
    return std::bit_cast<Vec<W, T>>(_mm_lzcnt_epi64(vi));
  }
}
// count right zeros
template <std::ptrdiff_t W, std::integral T>
TRIVIAL inline constexpr auto crz(Vec<W, T> v) {
  return T(8 * sizeof(T)) - clz<W, T>((~v) & (v - T(1)));
}

#else

template <std::ptrdiff_t W, std::integral T>
TRIVIAL constexpr auto clz(Vec<W, T> v) {
  Vec<W, T> ret;
  for (std::ptrdiff_t w = 0; w < W; ++w)
    ret[w] = T(std::countl_zero(std::make_unsigned_t<T>(v[w])));
  return ret;
}
template <std::ptrdiff_t W, std::integral T>
TRIVIAL constexpr auto crz(Vec<W, T> v) {
  Vec<W, T> ret;
  for (std::ptrdiff_t w = 0; w < W; ++w)
    ret[w] = T(std::countr_zero(std::make_unsigned_t<T>(v[w])));
  return ret;
}

#endif

template <typename T>
inline constexpr std::ptrdiff_t Width =
  SIMDSupported<T> ? VECTORWIDTH / sizeof(T) : 1;
template <std::ptrdiff_t N, typename T>
constexpr std::ptrdiff_t VecLen =
  (N < Width<T>) ? std::ptrdiff_t(std::bit_ceil(std::size_t(N)))
                 : std::max(Width<T>, std::ptrdiff_t(1));

// returns { vector_size, num_vectors, remainder }
template <std::ptrdiff_t L, typename T>
consteval auto VectorDivRem() -> std::array<std::ptrdiff_t, 3> {
  constexpr std::ptrdiff_t W = Width<T>;
  if constexpr (L <= W) {
    constexpr auto V = std::ptrdiff_t(std::bit_ceil(std::size_t(L)));
    return {V, L / V, L % V};
  } else return {W, L / W, L % W};
};
template <typename T, std::ptrdiff_t R, std::ptrdiff_t C>
TRIVIAL constexpr auto VecWidth() {
  if constexpr (C > 1) return VectorDivRem<C, T>()[0];
  else if constexpr (C == 1)
    if constexpr (R >= 1) return VectorDivRem<R, T>()[0];
    else return Width<T>;
  else return Width<T>;
}

template <typename T, typename I> consteval auto getWidth() -> std::ptrdiff_t {
  if constexpr (std::same_as<I, std::ptrdiff_t>) return simd::Width<T>;
  else return simd::VecLen<std::ptrdiff_t(I{}), T>;
}

namespace reduce {
template <std::ptrdiff_t W, typename T, typename Op>
TRIVIAL constexpr auto reduce_op(simd::Vec<W, T> v) -> T {
  if constexpr (W == 1) {
    return v;
  } else if constexpr (W == 2) {
    T lo = v[0], hi = v[1];
    return Op{}(lo, hi);
  } else if constexpr (W == 4) {
    Vec<2, T> lo = __builtin_shufflevector(v, v, 0, 1),
              hi = __builtin_shufflevector(v, v, 2, 3);
    return reduce_op<2, T, Op>(Op{}(lo, hi));
  } else if constexpr (W == 8) {
    Vec<4, T> lo = __builtin_shufflevector(v, v, 0, 1, 2, 3),
              hi = __builtin_shufflevector(v, v, 4, 5, 6, 7);
    return reduce_op<4, T, Op>(Op{}(lo, hi));
  } else if constexpr (W == 16) {
    Vec<8, T> lo = __builtin_shufflevector(v, v, 0, 1, 2, 3, 4, 5, 6, 7),
              hi = __builtin_shufflevector(v, v, 8, 9, 10, 11, 12, 13, 14, 15);
    return reduce_op<8, T, Op>(Op{}(lo, hi));
  } else {
    static_assert(false, "Unsupported vector width for reduction");
  }
}
template <std::ptrdiff_t W, typename T>
TRIVIAL constexpr auto sum(simd::Vec<W, T> v) -> T {
  return reduce_op<W, T, std::plus<>>(v);
}
template <std::ptrdiff_t W, typename T>
TRIVIAL constexpr auto prod(simd::Vec<W, T> v) -> T {
  return reduce_op<W, T, std::multiplies<>>(v);
}
} // namespace reduce
} // namespace simd
