module;
#include "LoopMacros.hxx"
#include "Macros.hxx"
export module SIMD;

export import :Intrin;
export import :Mask;
import std;
export namespace simd {

namespace index {
template <std::ptrdiff_t R, std::ptrdiff_t C = 1, std::ptrdiff_t W = 1,
          typename M = mask::None<W>, bool Transposed = false,
          std::ptrdiff_t X = -1>
struct UnrollDims {
  static_assert(W != 1 || std::same_as<M, mask::None<1>>,
                "Only mask vector dims");
  static_assert(W != 1 || !Transposed,
                "Canonicalize scalar with Tranpose=false");
  [[no_unique_address]] M mask_;
  [[no_unique_address]] math::RowStride<X> rs_;
};

template <typename T> inline constexpr bool issimd = false;

template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t W, typename M,
          bool Transposed, std::ptrdiff_t X>
inline constexpr bool issimd<UnrollDims<R, C, W, M, Transposed, X>> = true;

} // namespace index
// template <typename T, std::ptrdiff_t W, typename S>
// TRIVIAL constexpr auto vcvt(Vec<W, S> v) {
//   if constexpr (std::same_as<T, S>) return v;
//   else if constexpr (W == 1) return T(v);
//   else return __builtin_convertvector(v, Vec<W, T>);
// }
// Vector goes across cols
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, typename T>
struct Unroll {
  static constexpr std::ptrdiff_t W =
    std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
  using VT = Vec<W, T>;
  static_assert(R * C > 0);
  VT data_[R * C];
  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) -> VT & {
    return data_[i];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r, std::ptrdiff_t c)
    -> VT & {
    return data_[r * C + c];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t i) const -> VT {
    return data_[i];
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t r, std::ptrdiff_t c) const
    -> VT {
    return data_[r * C + c];
  }
  template <typename U>
  TRIVIAL constexpr operator Unroll<R, C, N, U>() const
    requires(!std::same_as<T, U>) {
    Unroll<R, C, N, U> x;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i)
      if constexpr (W == 1) x.data_[i] = U(data_[i]);
      else x.data_[i] = __builtin_convertvector(data_[i], Vec<W, U>);
    return x;
  }
  TRIVIAL constexpr auto operator-() {
    Unroll a;
    for (std::ptrdiff_t i = 0; i < R * C; ++i) a.data_[i] = -data_[i];
    return a;
  }
  TRIVIAL constexpr auto operator+=(const Unroll &a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] += a.data_[i];
    return *this;
  }
  TRIVIAL constexpr auto operator-=(const Unroll &a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] -= a.data_[i];
    return *this;
  }
  TRIVIAL constexpr auto operator*=(const Unroll &a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] *= a.data_[i];
    return *this;
  }
  TRIVIAL constexpr auto operator/=(const Unroll &a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] /= a.data_[i];
    return *this;
  }
  TRIVIAL constexpr auto operator+=(VT a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] += a;
    return *this;
  }
  TRIVIAL constexpr auto operator-=(VT a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] -= a;
    return *this;
  }
  TRIVIAL constexpr auto operator*=(VT a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] *= a;
    return *this;
  }
  TRIVIAL constexpr auto operator/=(VT a) -> Unroll & {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) data_[i] /= a;
    return *this;
  }
  TRIVIAL constexpr auto operator+=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    return (*this) += vbroadcast<W, T>(a);
  }
  TRIVIAL constexpr auto operator-=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    return (*this) -= vbroadcast<W, T>(a);
  }
  TRIVIAL constexpr auto operator*=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    return (*this) *= vbroadcast<W, T>(a);
  }
  TRIVIAL constexpr auto operator/=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    return (*this) /= vbroadcast<W, T>(a);
  }

private:
  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator+(Unroll a, Unroll<R1, C1, W1, T1> b) {
    return applyop(a, b, std::plus<>{});
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator-(Unroll a, Unroll<R1, C1, W1, T1> b) {
    return applyop(a, b, std::minus<>{});
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator*(Unroll a,
                                          const Unroll<R1, C1, W1, T1> &b) {
    return applyop(a, b, std::multiplies<>{});
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator/(Unroll a,
                                          const Unroll<R1, C1, W1, T1> &b) {
    return applyop(a, b, std::divides<>{});
  }

  TRIVIAL friend constexpr auto operator+(Unroll a, VT b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a.data_[i] + b;
    return c;
  }
  TRIVIAL friend constexpr auto operator-(Unroll a, VT b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a.data_[i] - b;
    return c;
  }
  TRIVIAL friend constexpr auto operator*(Unroll a, VT b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a.data_[i] * b;
    return c;
  }
  TRIVIAL friend constexpr auto operator/(Unroll a, VT b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a.data_[i] / b;
    return c;
  }
  TRIVIAL friend constexpr auto operator+(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a + vbroadcast<W, T>(b);
  }
  TRIVIAL friend constexpr auto operator-(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a - vbroadcast<W, T>(b);
  }
  TRIVIAL friend constexpr auto operator*(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a * vbroadcast<W, T>(b);
  }
  TRIVIAL friend constexpr auto operator/(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a / vbroadcast<W, T>(b);
  }

  TRIVIAL friend constexpr auto operator+(VT a, Unroll b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a + b.data_[i];
    return c;
  }
  TRIVIAL friend constexpr auto operator-(VT a, Unroll b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a - b.data_[i];
    return c;
  }
  TRIVIAL friend constexpr auto operator*(VT a, Unroll b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a * b.data_[i];
    return c;
  }
  TRIVIAL friend constexpr auto operator/(VT a, Unroll b) -> Unroll {
    Unroll<R, C, W, T> c;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < R * C; ++i) c.data_[i] = a / b.data_[i];
    return c;
  }
  TRIVIAL friend constexpr auto operator+(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) + a;
  }
  TRIVIAL friend constexpr auto operator-(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) - a;
  }
  TRIVIAL friend constexpr auto operator*(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) * a;
  }
  TRIVIAL friend constexpr auto operator/(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) / a;
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1, typename Op>
  TRIVIAL friend constexpr auto applyop(Unroll a, Unroll<R1, C1, W1, T1> b,
                                        Op op) {
    // Possibilities:
    // 1. All match
    // 2. We had separate unrolls across rows and columns, and some arrays
    // were indexed by one or two of them.
    // In the latter case, we could have arrays indexed by rows, cols, or both.
    if constexpr (!std::same_as<T, T1>) {
      using PT = std::common_type_t<T, T1>;
      return applyop(Unroll<R, C, W, PT>(a), Unroll<R1, C1, W1, PT>(b), op);
    } else if constexpr (W == W1) {
      // both were indexed by cols, and `C2`s should also match
      // or neither were, and they should still match.
      static_assert(C == C1);
      if constexpr (R == R1) {
        // Both have the same index across rows
        Unroll<R, C, W, T> c;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t i = 0; i < R * C; ++i)
          c.data_[i] = op(a.data_[i], b.data_[i]);
        return c;
      } else if constexpr (R == 1) { // R1 > 0
        // `a` was indexed across cols only
        Unroll<R1, C, W, T> z;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t r = 0; r < R1; ++r) {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t c = 0; c < C; ++c)
            z[r, c] = op(a.data_[c], b[r, c]);
        }
        return z;
      } else {
        static_assert(R1 == 1); // R > 0
        // `b` was indexed across cols only
        Unroll<R, C, W, T> z;
        if constexpr (C == 1) {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t r = 0; r < R; ++r)
            z.data_[r] = op(a.data_[r], b.vec_);
        } else {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t r = 0; r < R; ++r) {
            POLYMATHFULLUNROLL
            for (std::ptrdiff_t c = 0; c < C; ++c)
              z[r, c] = op(a[r, c], b.data_[c]);
          }
        }
        return z;
      }
    } else if constexpr (W == 1) {
      static_assert(R == 1 || C == 1);
      static constexpr std::ptrdiff_t R2 = R == 1 ? C : R;
      // `a` was indexed by row only
      Unroll<R2, C1, W1, T> z;
      static_assert(R1 == R2 || R1 == 1);
      static_assert(R2 != 1);
      if constexpr (C1 == 1) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t r = 0; r < R2; ++r)
          if constexpr (R2 == R1) z.data_[r] = op(a.data_[r], b.vec_[r]);
          else z.data_[r] = op(a.data_[r], b.vec_);
      } else {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t r = 0; r < R2; ++r) {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t c = 0; c < C1; ++c)
            if constexpr (R2 == R1) z[r, c] = op(a.data_[r], b[r, c]);
            else z[r, c] = op(a.data_[r], b.data_[c]);
        }
      }
      return z;
    } else {
      static_assert(W1 == 1);
      static_assert(R1 == 1 || C1 == 1);
      constexpr std::ptrdiff_t R2 = R1 == 1 ? C1 : R1;
      // `b` was indexed by row only
      Unroll<R2, C, W, T> z;
      static_assert(R == R2 || R == 1);
      if constexpr (R2 == 1) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          z.data_[c] = op(a.data_[c], b.vec_);
      } else if constexpr (C == 1) {
        static_assert(R != 1 && R == R2);
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t r = 0; r < R2; ++r)
          z.data_[r] = op(a.data_[r], b.data_[r]);
      } else {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t r = 0; r < R2; ++r) {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t c = 0; c < C; ++c)
            if constexpr (R == R2) z[r, c] = op(a[r, c], b.data_[r]);
            else z[r, c] = op(a.data_[c], b.data_[r]);
        }
      }
      return z;
    }
  }
};
template <std::ptrdiff_t N, typename T> struct Unroll<1, 1, N, T> {
  static constexpr std::ptrdiff_t W =
    std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
  using VT = Vec<W, T>;
  VT vec_;
  TRIVIAL constexpr auto operator[](std::ptrdiff_t) -> VT & { return vec_; }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t, std::ptrdiff_t) -> VT & {
    return vec_;
  }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t) const -> VT { return vec_; }
  TRIVIAL constexpr auto operator[](std::ptrdiff_t, std::ptrdiff_t) const
    -> VT {
    return vec_;
  }
  TRIVIAL constexpr operator VT() const { return vec_; }
  template <typename U>
  TRIVIAL constexpr operator Unroll<1, 1, N, U>() const
    requires(!std::same_as<T, U>) {
    if constexpr (W == 1) return {U(vec_)};
    else return {__builtin_convertvector(vec_, Vec<W, U>)};
  }
  TRIVIAL constexpr auto operator-() { return Unroll{-vec_}; }
  TRIVIAL constexpr auto operator+=(const Unroll &a) -> Unroll & {
    vec_ += a.vec_;
    return *this;
  }
  TRIVIAL constexpr auto operator-=(const Unroll &a) -> Unroll & {
    vec_ -= a.vec_;
    return *this;
  }
  TRIVIAL constexpr auto operator*=(const Unroll &a) -> Unroll & {
    vec_ *= a.vec_;
    return *this;
  }
  TRIVIAL constexpr auto operator/=(const Unroll &a) -> Unroll & {
    vec_ /= a.vec_;
    return *this;
  }
  TRIVIAL constexpr auto operator+=(VT a) -> Unroll & {
    vec_ += a;
    return *this;
  }
  TRIVIAL constexpr auto operator-=(VT a) -> Unroll & {
    vec_ -= a;
    return *this;
  }
  TRIVIAL constexpr auto operator*=(VT a) -> Unroll & {
    vec_ *= a;
    return *this;
  }
  TRIVIAL constexpr auto operator/=(VT a) -> Unroll & {
    vec_ /= a;
    return *this;
  }
  TRIVIAL constexpr auto operator+=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    vec_ += vbroadcast<W, T>(a);
    return *this;
  }
  TRIVIAL constexpr auto operator-=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    vec_ -= vbroadcast<W, T>(a);
    return *this;
  }
  TRIVIAL constexpr auto operator*=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    vec_ *= vbroadcast<W, T>(a);
    return *this;
  }
  TRIVIAL constexpr auto operator/=(std::convertible_to<T> auto a)
    -> Unroll & requires(W != 1) {
    vec_ /= vbroadcast<W, T>(a);
    return *this;
  }

private:
  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator+(Unroll a, Unroll<R1, C1, W1, T1> b) {
    return applyop(a, b, std::plus<>{});
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator-(Unroll a, Unroll<R1, C1, W1, T1> b) {
    return applyop(a, b, std::minus<>{});
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator*(Unroll a,
                                          const Unroll<R1, C1, W1, T1> &b) {
    return applyop(a, b, std::multiplies<>{});
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1>
  TRIVIAL friend constexpr auto operator/(Unroll a,
                                          const Unroll<R1, C1, W1, T1> &b) {
    return applyop(a, b, std::divides<>{});
  }

  TRIVIAL friend constexpr auto operator<(Unroll a, Unroll b) {
    return cmp::lt<N, T>(a.vec_, b.vec_);
  }
  TRIVIAL friend constexpr auto operator>(Unroll a, Unroll b) {
    return cmp::gt<N, T>(a.vec_, b.vec_);
  }
  TRIVIAL friend constexpr auto operator<=(Unroll a, Unroll b) {
    return cmp::le<N, T>(a.vec_, b.vec_);
  }
  TRIVIAL friend constexpr auto operator>=(Unroll a, Unroll b) {
    return cmp::ge<N, T>(a.vec_, b.vec_);
  }
  TRIVIAL friend constexpr auto operator==(Unroll a, Unroll b) {
    return cmp::eq<N, T>(a.vec_, b.vec_);
  }
  TRIVIAL friend constexpr auto operator!=(Unroll a, Unroll b) {
    return cmp::ne<N, T>(a.vec_, b.vec_);
  }
  TRIVIAL friend constexpr auto operator<(Unroll a, VT b) {
    return cmp::lt<N, T>(a.vec_, b);
  }
  TRIVIAL friend constexpr auto operator>(Unroll a, VT b) {
    return cmp::gt<N, T>(a.vec_, b);
  }
  TRIVIAL friend constexpr auto operator<=(Unroll a, VT b) {
    return cmp::le<N, T>(a.vec_, b);
  }
  TRIVIAL friend constexpr auto operator>=(Unroll a, VT b) {
    return cmp::ge<N, T>(a.vec_, b);
  }
  TRIVIAL friend constexpr auto operator==(Unroll a, VT b) {
    return cmp::eq<N, T>(a.vec_, b);
  }
  TRIVIAL friend constexpr auto operator!=(Unroll a, VT b) {
    return cmp::ne<N, T>(a.vec_, b);
  }
  TRIVIAL friend constexpr auto operator<(VT a, Unroll b) {
    return cmp::lt<N, T>(a, b.vec_);
  }
  TRIVIAL friend constexpr auto operator>(VT a, Unroll b) {
    return cmp::gt<N, T>(a, b.vec_);
  }
  TRIVIAL friend constexpr auto operator<=(VT a, Unroll b) {
    return cmp::le<N, T>(a, b.vec_);
  }
  TRIVIAL friend constexpr auto operator>=(VT a, Unroll b) {
    return cmp::ge<N, T>(a, b.vec_);
  }
  TRIVIAL friend constexpr auto operator==(VT a, Unroll b) {
    return cmp::eq<N, T>(a, b.vec_);
  }
  TRIVIAL friend constexpr auto operator!=(VT a, Unroll b) {
    return cmp::ne<N, T>(a, b.vec_);
  }

  TRIVIAL friend constexpr auto operator+(Unroll a, VT b) -> Unroll {
    return {a.vec_ + b};
  }
  TRIVIAL friend constexpr auto operator-(Unroll a, VT b) -> Unroll {
    return {a.vec_ - b};
  }
  TRIVIAL friend constexpr auto operator*(Unroll a, VT b) -> Unroll {
    return {a.vec_ * b};
  }
  TRIVIAL friend constexpr auto operator/(Unroll a, VT b) -> Unroll {
    return {a.vec_ / b};
  }
  TRIVIAL friend constexpr auto operator+(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a + vbroadcast<W, T>(b);
  }
  TRIVIAL friend constexpr auto operator-(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a - vbroadcast<W, T>(b);
  }
  TRIVIAL friend constexpr auto operator*(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a * vbroadcast<W, T>(b);
  }
  TRIVIAL friend constexpr auto operator/(Unroll a,
                                          std::convertible_to<T> auto b)
    -> Unroll requires(W != 1) {
    return a / vbroadcast<W, T>(b);
  }

  TRIVIAL friend constexpr auto operator+(VT a, Unroll b) -> Unroll {
    return {a + b.vec_};
  }
  TRIVIAL friend constexpr auto operator-(VT a, Unroll b) -> Unroll {
    return {a - b.vec_};
  }
  TRIVIAL friend constexpr auto operator*(VT a, Unroll b) -> Unroll {
    return {a * b.vec_};
  }
  TRIVIAL friend constexpr auto operator/(VT a, Unroll b) -> Unroll {
    return {a / b.vec_};
  }
  TRIVIAL friend constexpr auto operator+(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) + a;
  }
  TRIVIAL friend constexpr auto operator-(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) - a;
  }
  TRIVIAL friend constexpr auto operator*(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) * a;
  }
  TRIVIAL friend constexpr auto operator/(T b, Unroll a) -> Unroll
    requires(W != 1) {
    return vbroadcast<W, T>(b) / a;
  }

  template <std::ptrdiff_t R1, std::ptrdiff_t C1, std::ptrdiff_t W1,
            typename T1, typename Op>
  TRIVIAL friend constexpr auto applyop(Unroll a, Unroll<R1, C1, W1, T1> b,
                                        Op op) {
    // Possibilities:
    // 1. All match
    // 2. We had separate unrolls across rows and columns, and some arrays
    // were indexed by one or two of them.
    // In the latter case, we could have arrays indexed by rows, cols, or both.
    if constexpr (!std::same_as<T, T1>) {
      using PT = std::common_type_t<T, T1>;
      return applyop(Unroll<1, 1, W, PT>(a), Unroll<R1, C1, W1, PT>(b), op);
    } else if constexpr (W == W1) {
      // both were indexed by cols, and `C`s should also match
      // or neither were, and they should still match.
      static_assert(C1 == 1);
      if constexpr (R1 != 1) {
        // `a` was indexed across cols only
        Unroll<R1, 1, W, T> z;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t r = 0; r < R1; ++r)
          z.data_[r] = op(a.vec_, b.data_[r]);
        return z;
      } else return Unroll<1, 1, W, T>{op(a.vec_, b.vec_)};
    } else if constexpr (W == 1) {
      // `a` was indexed by row only
      static_assert(R1 == 1);
      if constexpr (C1 != 1) {
        Unroll<1, C1, W1, T> z;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C1; ++c)
          z.data_[c] = op(a.vec_, b.data_[c]);
        return z;
      } else return Unroll<1, 1, W1, T>{op(a.vec_, b.vec_)};
    } else {
      static_assert(W1 == 1);
      static_assert(R1 == 1 || C1 == 1);
      constexpr std::ptrdiff_t R = R1 == 1 ? C1 : R1;
      // `b` was indexed by row only
      if constexpr (R != 1) {
        Unroll<R, 1, W, T> z;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t r = 0; r < R; ++r)
          z.data_[r] = op(a.vec_, b.data_[r]);
        return z;
      } else return Unroll{op(a.vec_, b.vec_)};
    }
  }
};

template <std::ptrdiff_t C, std::ptrdiff_t W, typename T>
TRIVIAL constexpr auto transpose(Unroll<1, C, W, T> u)
  -> Unroll<W * C, 1, 1, T> {
  Unroll<W * C, 1, 1, T> z;
  if constexpr (W == 1) {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < C; ++i) z[i] = u[i];
  } else {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < C; ++i) {
      Vec<W, T> v{u[i]};
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t w = 0; w < W; ++w) z[w + W * i] = v[w];
    }
  }
  return z;
}

// 4 x 4C -> 4C x 4
template <std::ptrdiff_t R2, std::ptrdiff_t C, typename T>
TRIVIAL constexpr auto transpose(Unroll<R2, C, 2, T> u)
  -> Unroll<2 * C, R2 / VecLen<R2, T>, VecLen<R2, T>, T> requires(R2 % 2 == 0) {
  static constexpr std::ptrdiff_t V = VecLen<R2, T>;
  static constexpr std::ptrdiff_t R = R2 / V;
  Unroll<2 * C, R, V, T> z;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t zc = 0; zc < R; ++zc) {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t zr = 0; zr < C; ++zr) {
      if constexpr (R2 % 8 == 0) {
        std::ptrdiff_t r8 = 8 * zc;
        Vec<2, T> a{u[r8, zr]}, b{u[r8 + 1, zr]}, c{u[r8 + 2, zr]},
          d{u[r8 + 3, zr]}, e{u[r8 + 4, zr]}, f{u[r8 + 5, zr]},
          g{u[r8 + 6, zr]}, h{u[r8 + 7, zr]};
        // inputs   a b c d e  f  g  h
        // returns: 0 2 4 6 8 10 12 14
        //          1 3 5 7 9 11 13 15
        Vec<4, T> i{__builtin_shufflevector(a, b, 0, 1, 2, 3)},
          j{__builtin_shufflevector(c, d, 0, 1, 2, 3)},
          k{__builtin_shufflevector(e, f, 0, 1, 2, 3)},
          l{__builtin_shufflevector(g, h, 0, 1, 2, 3)};
        Vec<8, T> m{__builtin_shufflevector(i, j, 0, 1, 2, 3, 4, 5, 6, 7)},
          n{__builtin_shufflevector(k, l, 0, 1, 2, 3, 4, 5, 6, 7)};
        z[2 * zr, zc] =
          __builtin_shufflevector(m, n, 0, 2, 4, 6, 8, 10, 12, 14);
        z[2 * zr + 1, zc] =
          __builtin_shufflevector(m, n, 1, 3, 5, 7, 9, 11, 13, 15);

      } else if constexpr (R2 % 4 == 0) {
        std::ptrdiff_t r4 = 4 * zc;
        Vec<2, T> a{u[r4, zr]}, b{u[r4 + 1, zr]}, c{u[r4 + 2, zr]},
          d{u[r4 + 3, zr]};
        // inputs:  a b c d
        // returns: 0 2 4 6
        //          1 3 5 7
        Vec<4, T> e{__builtin_shufflevector(a, b, 0, 1, 2, 3)},
          f{__builtin_shufflevector(c, d, 0, 1, 2, 3)};
        z[2 * zr, zc] = __builtin_shufflevector(e, f, 0, 2, 4, 6);
        z[2 * zr + 1, zc] = __builtin_shufflevector(e, f, 1, 3, 5, 7);

      } else {
        std::ptrdiff_t r2 = 2 * zc;
        Vec<2, T> a{u[r2, zr]}, b{u[r2 + 1, zr]};
        z[2 * zr, zc] = __builtin_shufflevector(a, b, 0, 2);
        z[2 * zr + 1, zc] = __builtin_shufflevector(a, b, 1, 3);
      }
    }
  }
  return z;
}
template <std::ptrdiff_t R2, std::ptrdiff_t C, typename T>
TRIVIAL constexpr auto transpose(Unroll<R2, C, 4, T> u)
  -> Unroll<4 * C, R2 / VecLen<R2, T>, VecLen<R2, T>, T> requires(R2 % 2 == 0) {
  static constexpr std::ptrdiff_t V = VecLen<R2, T>;
  static constexpr std::ptrdiff_t R = R2 / V;
  Unroll<4 * C, R, V, T> z;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t zc = 0; zc < R; ++zc) {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t zr = 0; zr < C; ++zr) {
      if constexpr (R2 % 8 == 0) {
        std::ptrdiff_t c8 = 8 * zc;
        Vec<4, T> a{u[c8, zr]}, b{u[c8 + 1, zr]}, c{u[c8 + 2, zr]},
          d{u[c8 + 3, zr]}, e{u[c8 + 4, zr]}, f{u[c8 + 5, zr]},
          g{u[c8 + 6, zr]}, h{u[c8 + 7, zr]};
        // inputs   a b  c  d  e  f  g  h
        // returns: 0 4  8 12 16 20 24 28
        //          1 5  9 13 17 21 25 29
        //          2 6 10 14 18 22 26 30
        //          3 7 11 15 19 23 27 31
        Vec<8, T> i{__builtin_shufflevector(a, b, 0, 1, 2, 3, 4, 5, 6, 7)},
          j{__builtin_shufflevector(c, d, 0, 1, 2, 3, 4, 5, 6, 7)},
          k{__builtin_shufflevector(e, f, 0, 1, 2, 3, 4, 5, 6, 7)},
          l{__builtin_shufflevector(g, h, 0, 1, 2, 3, 4, 5, 6, 7)},
          m{__builtin_shufflevector(i, j, 0, 1, 4, 5, 8, 9, 12, 13)},
          n{__builtin_shufflevector(i, j, 2, 3, 6, 7, 10, 11, 14, 15)},
          o{__builtin_shufflevector(k, l, 0, 1, 4, 5, 8, 9, 12, 13)},
          p{__builtin_shufflevector(k, l, 2, 3, 6, 7, 10, 11, 14, 15)};
        z[4 * zr, zc] =
          __builtin_shufflevector(m, o, 0, 2, 4, 6, 8, 10, 12, 14);
        z[4 * zr + 1, zc] =
          __builtin_shufflevector(m, o, 1, 3, 5, 7, 9, 11, 13, 15);
        z[4 * zr + 2, zc] =
          __builtin_shufflevector(n, p, 0, 2, 4, 6, 8, 10, 12, 14);
        z[4 * zr + 3, zc] =
          __builtin_shufflevector(n, p, 1, 3, 5, 7, 9, 11, 13, 15);
      } else if constexpr (R2 % 4 == 0) {
        std::ptrdiff_t r4 = 4 * zc;
        Vec<4, T> a{u[r4, zr]}, b{u[r4 + 1, zr]}, c{u[r4 + 2, zr]},
          d{u[r4 + 3, zr]}, e{__builtin_shufflevector(a, b, 0, 1, 4, 5)},
          f{__builtin_shufflevector(a, b, 2, 3, 6, 7)},
          g{__builtin_shufflevector(c, d, 0, 1, 4, 5)},
          h{__builtin_shufflevector(c, d, 2, 3, 6, 7)};
        z[4 * zr, zc] = __builtin_shufflevector(e, g, 0, 2, 4, 6);
        z[4 * zr + 1, zc] = __builtin_shufflevector(e, g, 1, 3, 5, 7);
        z[4 * zr + 2, zc] = __builtin_shufflevector(f, h, 0, 2, 4, 6);
        z[4 * zr + 3, zc] = __builtin_shufflevector(f, h, 1, 3, 5, 7);
      } else {
        Vec<4, T> a{u[2 * zc, zr]}, b{u[2 * zc + 1, zr]},
          e{__builtin_shufflevector(a, b, 0, 4, 2, 6)},
          f{__builtin_shufflevector(a, b, 1, 5, 3, 7)};
        z[4 * zr, zc] = __builtin_shufflevector(e, e, 0, 1);
        z[4 * zr + 1, zc] = __builtin_shufflevector(f, f, 0, 1);
        z[4 * zr + 2, zc] = __builtin_shufflevector(e, e, 2, 3);
        z[4 * zr + 3, zc] = __builtin_shufflevector(f, f, 2, 3);
      }
    }
  }

  return z;
}
template <std::ptrdiff_t R2, std::ptrdiff_t C, typename T>
TRIVIAL constexpr auto transpose_droplast(Unroll<R2, C, 4, T> u)
  -> Unroll<3 * C, R2 / VecLen<R2, T>, VecLen<R2, T>, T> requires(R2 % 2 == 0) {
  static constexpr std::ptrdiff_t V = VecLen<R2, T>;
  static constexpr std::ptrdiff_t R = R2 / V;
  Unroll<3 * C, R, V, T> z;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t zc = 0; zc < R; ++zc) {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t zr = 0; zr < C; ++zr) {
      if constexpr (R2 % 8 == 0) {
        std::ptrdiff_t c8 = 8 * zc;
        Vec<4, T> a{u[c8, zr]}, b{u[c8 + 1, zr]}, c{u[c8 + 2, zr]},
          d{u[c8 + 3, zr]}, e{u[c8 + 4, zr]}, f{u[c8 + 5, zr]},
          g{u[c8 + 6, zr]}, h{u[c8 + 7, zr]};
        // inputs   a b  c  d  e  f  g  h
        // returns: 0 4  8 12 16 20 24 28
        //          1 5  9 13 17 21 25 29
        //          2 6 10 14 18 22 26 30
        //          3 7 11 15 19 23 27 31
        Vec<8, T> i{__builtin_shufflevector(a, b, 0, 1, 2, 3, 4, 5, 6, 7)},
          j{__builtin_shufflevector(c, d, 0, 1, 2, 3, 4, 5, 6, 7)},
          k{__builtin_shufflevector(e, f, 0, 1, 2, 3, 4, 5, 6, 7)},
          l{__builtin_shufflevector(g, h, 0, 1, 2, 3, 4, 5, 6, 7)},
          m{__builtin_shufflevector(i, j, 0, 1, 4, 5, 8, 9, 12, 13)},
          n{__builtin_shufflevector(i, j, 2, 3, 6, 7, 10, 11, 14, 15)},
          o{__builtin_shufflevector(k, l, 0, 1, 4, 5, 8, 9, 12, 13)},
          p{__builtin_shufflevector(k, l, 2, 3, 6, 7, 10, 11, 14, 15)};
        z[3 * zr, zc] =
          __builtin_shufflevector(m, o, 0, 2, 4, 6, 8, 10, 12, 14);
        z[3 * zr + 1, zc] =
          __builtin_shufflevector(m, o, 1, 3, 5, 7, 9, 11, 13, 15);
        z[3 * zr + 2, zc] =
          __builtin_shufflevector(n, p, 0, 2, 4, 6, 8, 10, 12, 14);
      } else if constexpr (R2 % 4 == 0) {
        std::ptrdiff_t r4 = 4 * zc;
        Vec<4, T> a{u[r4, zr]}, b{u[r4 + 1, zr]}, c{u[r4 + 2, zr]},
          d{u[r4 + 3, zr]}, e{__builtin_shufflevector(a, b, 0, 1, 4, 5)},
          f{__builtin_shufflevector(a, b, 2, 3, 6, 7)},
          g{__builtin_shufflevector(c, d, 0, 1, 4, 5)},
          h{__builtin_shufflevector(c, d, 2, 3, 6, 7)};
        z[3 * zr, zc] = __builtin_shufflevector(e, g, 0, 2, 4, 6);
        z[3 * zr + 1, zc] = __builtin_shufflevector(e, g, 1, 3, 5, 7);
        z[3 * zr + 2, zc] = __builtin_shufflevector(f, h, 0, 2, 4, 6);
      } else {
        Vec<4, T> a{u[2 * zc, zr]}, b{u[2 * zc + 1, zr]},
          e{__builtin_shufflevector(a, b, 0, 4, 2, 6)},
          f{__builtin_shufflevector(a, b, 1, 5, 3, 7)};
        z[3 * zr, zc] = __builtin_shufflevector(e, e, 0, 1);
        z[3 * zr + 1, zc] = __builtin_shufflevector(f, f, 0, 1);
        z[3 * zr + 2, zc] = __builtin_shufflevector(e, e, 2, 3);
      }
    }
  }

  return z;
}
template <std::ptrdiff_t R8, std::ptrdiff_t C, typename T>
TRIVIAL constexpr auto transpose(Unroll<R8, C, 8, T> u)
  -> Unroll<8 * C, R8 / 8, 8, T> requires(R8 % 8 == 0) {
  static constexpr std::ptrdiff_t R = R8 / 8;
  Unroll<8 * C, R, 8, T> z;
  POLYMATHFULLUNROLL
  for (std::ptrdiff_t r = 0; r < R; ++r) {
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t i = 0; i < C; ++i) {
      std::ptrdiff_t r8 = 8 * r, i8 = 8 * i;
      Vec<8, T> a{u[r8, i]}, b{u[r8 + 1, i]}, c{u[r8 + 2, i]}, d{u[r8 + 3, i]},
        e{u[r8 + 4, i]}, f{u[r8 + 5, i]}, g{u[r8 + 6, i]}, h{u[r8 + 7, i]},
        j{__builtin_shufflevector(a, b, 0, 8, 2, 10, 4, 12, 6, 14)},
        k{__builtin_shufflevector(a, b, 1, 9, 3, 11, 5, 13, 7, 15)},
        l{__builtin_shufflevector(c, d, 0, 8, 2, 10, 4, 12, 6, 14)},
        m{__builtin_shufflevector(c, d, 1, 9, 3, 11, 5, 13, 7, 15)},
        n{__builtin_shufflevector(e, f, 0, 8, 2, 10, 4, 12, 6, 14)},
        o{__builtin_shufflevector(e, f, 1, 9, 3, 11, 5, 13, 7, 15)},
        p{__builtin_shufflevector(g, h, 0, 8, 2, 10, 4, 12, 6, 14)},
        q{__builtin_shufflevector(g, h, 1, 9, 3, 11, 5, 13, 7, 15)};
      a = __builtin_shufflevector(j, l, 0, 1, 8, 9, 4, 5, 12, 13);
      b = __builtin_shufflevector(j, l, 2, 3, 10, 11, 6, 7, 14, 15);
      c = __builtin_shufflevector(k, m, 0, 1, 8, 9, 4, 5, 12, 13);
      d = __builtin_shufflevector(k, m, 2, 3, 10, 11, 6, 7, 14, 15);
      e = __builtin_shufflevector(n, p, 0, 1, 8, 9, 4, 5, 12, 13);
      f = __builtin_shufflevector(n, p, 2, 3, 10, 11, 6, 7, 14, 15);
      g = __builtin_shufflevector(o, q, 0, 1, 8, 9, 4, 5, 12, 13);
      h = __builtin_shufflevector(o, q, 2, 3, 10, 11, 6, 7, 14, 15);
      z[i8, r] = __builtin_shufflevector(a, e, 0, 1, 2, 3, 8, 9, 10, 11);
      z[i8 + 1, r] = __builtin_shufflevector(a, e, 4, 5, 6, 7, 12, 13, 14, 15);
      z[i8 + 2, r] = __builtin_shufflevector(b, f, 0, 1, 2, 3, 8, 9, 10, 11);
      z[i8 + 3, r] = __builtin_shufflevector(b, f, 4, 5, 6, 7, 12, 13, 14, 15);
      z[i8 + 4, r] = __builtin_shufflevector(c, g, 0, 1, 2, 3, 8, 9, 10, 11);
      z[i8 + 5, r] = __builtin_shufflevector(c, g, 4, 5, 6, 7, 12, 13, 14, 15);
      z[i8 + 6, r] = __builtin_shufflevector(d, h, 0, 1, 2, 3, 8, 9, 10, 11);
      z[i8 + 7, r] = __builtin_shufflevector(d, h, 4, 5, 6, 7, 12, 13, 14, 15);
    }
  }
  return z;
}

template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, typename T,
          std::ptrdiff_t X, std::size_t NM, typename MT = mask::None<N>>
TRIVIAL constexpr auto loadunroll(const T *ptr, math::RowStride<X> rowStride,
                                  std::array<MT, NM> masks)
  -> Unroll<R, C, N, T> requires(NM == 0 || NM == 1 || NM == C) {
  if constexpr (R * C == 1) {
    MT msk = masks[0];
    Vec<N, T> x = load<T>(ptr, msk);
    return {x};
  } else {
    constexpr auto W = std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
    auto rs = std::ptrdiff_t(rowStride);
    Unroll<R, C, N, T> ret;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r, ptr += rs) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          ret[r, c] = load(ptr + c * W, mask::None<W>{});
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          ret[r, c] = load(ptr + c * W, masks[c]);
      } else {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          ret[r, c] = load(ptr + c * W, mask::None<W>{});
        ret[r, C - 1] = load(ptr + (C - 1) * W, masks[0]);
      }
    }
    return ret;
  }
}
template <std::ptrdiff_t RC, std::ptrdiff_t RW, std::ptrdiff_t C,
          std::ptrdiff_t N, typename T, std::ptrdiff_t X, std::size_t NMR,
          std::size_t NMC, typename MTR, typename MTC>
TRIVIAL constexpr auto loadunrollmm(const T *ptr, math::RowStride<X> rowStride,
                                    std::array<MTR, NMR> row_masks,
                                    std::array<MTC, NMC> col_masks)
  -> Unroll<RC * RW, C, N, T>
  requires((NMC == 0 || NMC == 1 || NMC == C) &&
           ((NMR == 0) || (NMR == 1) || (NMR == RC))) {
  static constexpr std::ptrdiff_t R = RC * RW;
  if constexpr ((NMR == 0) || std::same_as<mask::None<RW>, MTR>) {
    return loadunroll<R, C, N>(ptr, rowStride, col_masks);
  } else if constexpr (R * C == 1) {
    Vec<N, T> x =
      row_masks[0].lastUnmasked() ? load<T>(ptr, col_masks[0]) : Vec<N, T>{};
    return {x};
  } else {
    constexpr auto W = std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
    // On NMR: if NMR > 1, then it equals R / O, where O is the transposes's W
    auto rs = std::ptrdiff_t(rowStride);
    Unroll<R, C, N, T> ret{};
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t rc = 0; rc < RC; ++rc, ptr += rs) {
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t rw = 0; rw < RW; ++rw, ptr += rs) {
        // here, we check whether we ought to continue or break
        if constexpr (NMR == RC) {
          // we mask
          if (rw >= row_masks[rc].lastUnmasked()) break;
        } else {
          if ((rc + 1 == RC) && rw >= row_masks[0].lastUnmasked()) break;
        }
        std::ptrdiff_t r = rw + RW * rc;
        if constexpr (NMC == 0) {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t c = 0; c < C; ++c)
            ret[r, c] = load(ptr + c * W, mask::None<W>{});
        } else if constexpr (NMC == C) {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t c = 0; c < C; ++c)
            ret[r, c] = load(ptr + c * W, col_masks[c]);
        } else {
          POLYMATHFULLUNROLL
          for (std::ptrdiff_t c = 0; c < C - 1; ++c)
            ret[r, c] = load(ptr + c * W, mask::None<W>{});
          ret[r, C - 1] = load(ptr + (C - 1) * W, col_masks[0]);
        }
      }
    }
    return ret;
  }
}
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, typename T,
          std::ptrdiff_t X, std::size_t NM, typename MT = mask::None<N>>
TRIVIAL constexpr auto loadstrideunroll(const T *ptr,
                                        math::RowStride<X> rowStride,
                                        std::array<MT, NM> masks)
  -> Unroll<R, C, N, T> requires(NM == 0 || NM == 1 || NM == C) {
  auto s = std::int32_t(std::ptrdiff_t(rowStride));
  if constexpr (R * C == 1) return {load(ptr, masks[0], s)};
  else if constexpr (((R > 1) && ((R % N == 0) || (N % R == 0) ||
                                  ((R == 3) && (N > R))))) {
    static constexpr std::ptrdiff_t RL = C * N;
    static constexpr bool unmasked = NM == 0 || std::same_as<MT, mask::None<N>>;
    if constexpr (R != 3) {
      static constexpr std::ptrdiff_t CL = R > N ? R / N : 1;
      static constexpr std::ptrdiff_t WL = R > N ? N : R;
      if constexpr (unmasked) {
        return transpose(loadunroll<RL, CL, WL>(
          ptr, rowStride, std::array<mask::None<WL>, 0>{}));

      } else {
        return transpose(loadunrollmm<C, N, CL, WL>(
          ptr, rowStride, masks, std::array<mask::None<WL>, 0>{}));
      }
    } else if constexpr (unmasked) {
      // NOTE: NM == 1 == C, so we only need to pass a 1-element mask
      return transpose_droplast(loadunroll<RL, 1, 4>(
        ptr, rowStride, std::array{mask::create<4>(0, 3)}));

    } else {
      // NOTE: NM == 1 == C, so we only need to pass a 1-element mask
      return transpose_droplast(loadunrollmm<C, N, 1, 4>(
        ptr, rowStride, masks, std::array{mask::create<4>(0, 3)}));
    }
  } else {
    constexpr auto W = std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
    Unroll<R, C, N, T> ret;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r, ++ptr) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          ret[r, c] = load(ptr + c * W * s, mask::None<W>{}, s);
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          ret[r, c] = load(ptr + c * W * s, masks[c], s);
      } else {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          ret[r, c] = load(ptr + c * W * s, mask::None<W>{}, s);
        ret[r, C - 1] = load(ptr + (C - 1) * W * s, masks[0], s);
      }
    }
    return ret;
  }
}

// Represents a reference for a SIMD load, in particular so that we can store.
// Needs to support masking
template <std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t N, typename T,
          std::ptrdiff_t X, std::ptrdiff_t NM, typename MT = mask::None<N>,
          bool Transposed = false>
struct UnrollRef {
  static constexpr std::ptrdiff_t W =
    std::ptrdiff_t(std::bit_ceil(std::size_t(N)));
  static_assert(N == W || C == 1,
                "If N != the next power of `2`, then `C` should be `1`");
  static_assert(
    NM == 0 || NM == 1 || NM == C,
    "Should have no masks, one mask for last `C`, or one mask per `C`");
  using UT = Unroll<R, C, N, T>;
  T *ptr_;
  [[no_unique_address]] math::RowStride<X> row_stride_;
  [[no_unique_address]] std::array<MT, NM> masks_;
  TRIVIAL constexpr operator UT() {
    if constexpr (!Transposed)
      return loadunroll<R, C, N, T, X, NM, MT>(ptr_, row_stride_, masks_);
    else
      return loadstrideunroll<R, C, N, T, X, NM, MT>(ptr_, row_stride_, masks_);
  }
  TRIVIAL constexpr auto operator=(UT x) -> UnrollRef & requires(!Transposed) {
    auto rs = std::ptrdiff_t(row_stride_);
    T *p = ptr_;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r, p += rs) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W, mask::None<W>{}, x[r, c]);
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c) {
          auto msk = masks_[c];
          store<T>(p + c * W, msk, x[r, c]);
          // store<T>(p + c * W, masks[c], x[r, c]);
        }
      } else { // NM == 1
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          store<T>(p + c * W, mask::None<W>{}, x[r, c]);
        store<T>(p + (C - 1) * W, masks_[0], x[r, C - 1]);
      }
    }
    return *this;
  }
  TRIVIAL constexpr auto operator=(Unroll<1, C, N, T> x)
    -> UnrollRef & requires((!Transposed) && (R != 1)) {
    auto rs = std::ptrdiff_t(row_stride_);
    T *p = ptr_;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r, p += rs) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W, mask::None<W>{}, x[0, c]);
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c) {
          auto msk = masks_[c];
          store<T>(p + c * W, msk, x[0, c]);
        }
      } else { // NM == 1
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          store<T>(p + c * W, mask::None<W>{}, x[0, c]);
        store<T>(p + (C - 1) * W, masks_[0], x[0, C - 1]);
      }
    }
    return *this;
  }
  TRIVIAL constexpr auto operator=(Unroll<R, C, 1, T> x)
    -> UnrollRef & requires(!Transposed && (N != 1)) {
    auto rs = std::ptrdiff_t(row_stride_);
    T *p = ptr_;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r, p += rs) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W, mask::None<W>{}, vbroadcast<W>(x[r, c]));
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W, masks_[c], vbroadcast<W>(x[r, c]));
      } else { // NM == 1
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          store<T>(p + c * W, mask::None<W>{}, x[r, c]);
        store<T>(p + (C - 1) * W, masks_[0], vbroadcast<W>(x[r, C - 1]));
      }
    }
    return *this;
  }

  TRIVIAL constexpr auto operator=(Vec<W, T> v)
    -> UnrollRef & requires(!Transposed) {
    auto rs = std::ptrdiff_t(row_stride_);
    T *p = ptr_;
    POLYMATHFULLUNROLL
    for (std::ptrdiff_t r = 0; r < R; ++r, p += rs) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W, mask::None<W>{}, v);
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W, masks_[c], v);
      } else { // NM == 1
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          store<T>(p + c * W, mask::None<W>{}, v);
        store<T>(p + (C - 1) * W, masks_[0], v);
      }
    }
    return *this;
  }
  TRIVIAL constexpr auto operator=(Unroll<R, C, N, T> x)
    -> UnrollRef & requires(Transposed) {
    auto s = std::int32_t(std::ptrdiff_t(row_stride_));
    T *p = ptr_;
    for (std::ptrdiff_t r = 0; r < R; ++r, ++p) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W * s, mask::None<W>{}, x[0, c], s);
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W * s, masks_[c], x[0, c], s);
      } else {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          store<T>(p + c * W * s, mask::None<W>{}, x[0, c], s);
        store<T>(p + (C - 1) * W * s, masks_[0], x[0, C - 1], s);
      }
    }
    return *this;
  }
  TRIVIAL constexpr auto operator=(Vec<W, T> v)
    -> UnrollRef & requires(Transposed) {
    auto s = std::int32_t(std::ptrdiff_t(row_stride_));
    T *p = ptr_;
    for (std::ptrdiff_t r = 0; r < R; ++r, ++p) {
      if constexpr (NM == 0) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W * s, mask::None<W>{}, v, s);
      } else if constexpr (NM == C) {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C; ++c)
          store<T>(p + c * W * s, masks_[c], v, s);
      } else {
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t c = 0; c < C - 1; ++c)
          store<T>(p + c * W * s, mask::None<W>{}, v, s);
        store<T>(p + (C - 1) * W * s, masks_[0], v, s);
      }
    }
    return *this;
  }
  TRIVIAL constexpr auto operator=(std::convertible_to<T> auto x)
    -> UnrollRef & {
    *this = Vec<W, T>{} + T(x);
    return *this;
  }
  TRIVIAL constexpr auto operator+=(const auto &x) -> UnrollRef & {
    return (*this) = Unroll<R, C, N, T>(*this) + x;
  }
  TRIVIAL constexpr auto operator-=(const auto &x) -> UnrollRef & {
    return (*this) = Unroll<R, C, N, T>(*this) - x;
  }
  TRIVIAL constexpr auto operator*=(const auto &x) -> UnrollRef & {
    return (*this) = Unroll<R, C, N, T>(*this) * x;
  }
  TRIVIAL constexpr auto operator/=(const auto &x) -> UnrollRef & {
    return (*this) = Unroll<R, C, N, T>(*this) / x;
  }
};
template <typename T, std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t W,
          typename M, bool Transposed, std::ptrdiff_t X>
TRIVIAL constexpr auto ref(const T *p,
                           index::UnrollDims<R, C, W, M, Transposed, X> i)
  -> Unroll<R, C, W, T> {
  if constexpr (Transposed)
    return loadstrideunroll<R, C, W>(p, i.rs_, std::array<M, 1>{i.mask_});
  else return loadunroll<R, C, W>(p, i.rs_, std::array<M, 1>{i.mask_});
}
template <typename T, std::ptrdiff_t R, std::ptrdiff_t C, std::ptrdiff_t W,
          typename M, bool Transposed, std::ptrdiff_t X>
TRIVIAL constexpr auto ref(T *p, index::UnrollDims<R, C, W, M, Transposed, X> i)
  -> UnrollRef<R, C, W, T, X, 1, M, Transposed> {
  return {p, i.rs_, std::array<M, 1>{i.mask_}};
}

namespace index {
// Unroll rows by a factor of `R` and cols by `C`, vectorizing with width `W`
template <std::ptrdiff_t U, std::ptrdiff_t W = 1, typename M = mask::None<W>>
struct Unroll {
  std::ptrdiff_t index_;
  [[no_unique_address]] M mask_{};
  TRIVIAL explicit constexpr operator std::ptrdiff_t() const { return index_; }
  TRIVIAL explicit constexpr operator bool() const { return bool(mask_); }

  template <std::integral I>
  TRIVIAL constexpr operator ::simd::Unroll<1, U, W, I>() const {
    if constexpr (U != 1) {
      ::simd::Unroll<1, U, W, I> ret;
      Vec<W, I> r{::simd::range<W, I>()},
        ind = vbroadcast<W>(static_cast<I>(index_));
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < U; ++u) ret.data_[u] = r + ind + (W * u);
      return ret;
    } else return {::simd::range<W, I>() + index_};
  }
#ifdef __AVX512F__
  template <std::ptrdiff_t S>
  TRIVIAL constexpr auto sub() requires(std::same_as<M, mask::Bit<W>>) {
    static_assert((S <= W) && (U == 1));
    Unroll<1, S, mask::Bit<S>> u{index_, mask_.template sub<S>()};
    index_ += S;
    return u;
  }
#endif

private:
  TRIVIAL friend constexpr auto operator+(Unroll a, std::ptrdiff_t b)
    -> Unroll {
    return {b + a.index_, a.mask_};
  }
  TRIVIAL friend constexpr auto operator==(Unroll x, std::ptrdiff_t y) {
    if constexpr (W == 1) {
      if constexpr (U > 1) {
        ::simd::Unroll<U, 1, 1, std::int64_t> ret;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < U; ++u)
          ret.data[u] = (x.index_ + u) == y;
        return ret;
      } else return ::simd::Unroll<1, 1, W, std::int64_t>{x.index_ == y};
    } else if constexpr (U > 1) {
      ::simd::Unroll<1, U, W, std::int64_t> ret;
      Vec<W, std::int64_t> v = vbroadcast<W, std::int64_t>(y - x.index_);
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < U; ++u)
        ret.data[u] = range<W, std::int64_t>() == (v - u * W);
      return ret;
    } else
      return ::simd::Unroll<1, 1, W, std::int64_t>{
        range<W, std::int64_t>() == vbroadcast<W, std::int64_t>(y - x.index_)};
  }
  TRIVIAL friend constexpr auto operator!=(Unroll x, std::ptrdiff_t y) {
    if constexpr (W == 1) {
      if constexpr (U > 1) {
        ::simd::Unroll<U, 1, 1, std::int64_t> ret;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < U; ++u)
          ret.data[u] = (x.index_ + u) != y;
        return ret;
      } else return ::simd::Unroll<1, 1, W, std::int64_t>{x.index_ != y};
    } else if constexpr (U > 1) {
      ::simd::Unroll<1, U, W, std::int64_t> ret;
      Vec<W, std::int64_t> v = vbroadcast<W, std::int64_t>(y - x.index_);
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < U; ++u)
        ret.data[u] = range<W, std::int64_t>() != (v - u * W);
      return ret;
    } else
      return ::simd::Unroll<1, 1, W, std::int64_t>{
        range<W, std::int64_t>() != vbroadcast<W, std::int64_t>(y - x.index_)};
  }

  TRIVIAL friend constexpr auto operator<(Unroll x, std::ptrdiff_t y) {
    if constexpr (W == 1) {
      if constexpr (U > 1) {
        ::simd::Unroll<U, 1, 1, std::int64_t> ret;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < U; ++u) ret.data[u] = (x.index_ + u) < y;
        return ret;
      } else return ::simd::Unroll<1, 1, W, std::int64_t>{x.index_ < y};
    } else if constexpr (U > 1) {
      ::simd::Unroll<1, U, W, std::int64_t> ret;
      Vec<W, std::int64_t> v = vbroadcast<W, std::int64_t>(y - x.index_);
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < U; ++u)
        ret.data[u] = range<W, std::int64_t>() < (v - u * W);
      return ret;
    } else
      return ::simd::Unroll<1, 1, W, std::int64_t>{
        range<W, std::int64_t>() < vbroadcast<W, std::int64_t>(y - x.index_)};
  }

  TRIVIAL friend constexpr auto operator>(Unroll x, std::ptrdiff_t y) {
    if constexpr (W == 1) {
      if constexpr (U > 1) {
        ::simd::Unroll<U, 1, 1, std::int64_t> ret;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < U; ++u) ret.data[u] = (x.index_ + u) > y;
        return ret;
      } else return ::simd::Unroll<1, 1, W, std::int64_t>{x.index_ > y};
    } else if constexpr (U > 1) {
      ::simd::Unroll<1, U, W, std::int64_t> ret;
      Vec<W, std::int64_t> v = vbroadcast<W, std::int64_t>(y - x.index_);
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < U; ++u)
        ret.data[u] = range<W, std::int64_t>() > (v - u * W);
      return ret;
    } else
      return ::simd::Unroll<1, 1, W, std::int64_t>{
        range<W, std::int64_t>() > vbroadcast<W, std::int64_t>(y - x.index_)};
  }

  TRIVIAL friend constexpr auto operator<=(Unroll x, std::ptrdiff_t y) {
    if constexpr (W == 1) {
      if constexpr (U > 1) {
        ::simd::Unroll<U, 1, 1, std::int64_t> ret;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < U; ++u)
          ret.data[u] = (x.index_ + u) <= y;
        return ret;
      } else return ::simd::Unroll<1, 1, W, std::int64_t>{x.index_ <= y};
    } else if constexpr (U > 1) {
      ::simd::Unroll<1, U, W, std::int64_t> ret;
      Vec<W, std::int64_t> v = vbroadcast<W, std::int64_t>(y - x.index_);
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < U; ++u)
        ret.data[u] = range<W, std::int64_t>() <= (v - u * W);
      return ret;
    } else
      return ::simd::Unroll<1, 1, W, std::int64_t>{
        range<W, std::int64_t>() <= vbroadcast<W, std::int64_t>(y - x.index_)};
  }

  TRIVIAL friend constexpr auto operator>=(Unroll x, std::ptrdiff_t y) {
    if constexpr (W == 1) {
      if constexpr (U > 1) {
        ::simd::Unroll<U, 1, 1, std::int64_t> ret;
        POLYMATHFULLUNROLL
        for (std::ptrdiff_t u = 0; u < U; ++u)
          ret.data[u] = (x.index_ + u) >= y;
        return ret;
      } else return ::simd::Unroll<1, 1, W, std::int64_t>{x.index_ >= y};
    } else if constexpr (U > 1) {
      ::simd::Unroll<1, U, W, std::int64_t> ret;
      Vec<W, std::int64_t> v = vbroadcast<W, std::int64_t>(y - x.index_);
      POLYMATHFULLUNROLL
      for (std::ptrdiff_t u = 0; u < U; ++u)
        ret.data[u] = range<W, std::int64_t>() >= (v - u * W);
      return ret;
    } else
      return ::simd::Unroll<1, 1, W, std::int64_t>{
        range<W, std::int64_t>() >= vbroadcast<W, std::int64_t>(y - x.index_)};
  }
};
template <std::ptrdiff_t U, std::ptrdiff_t W>
TRIVIAL constexpr auto unrollmask(std::ptrdiff_t L, std::ptrdiff_t i) {
  // mask applies to last iter
  // We can't check that the last iter is non-empty, because that
  // could be the loop exit condition
  auto m{mask::create<W>(i + (U - 1) * W, L)};
  return Unroll<U, W, decltype(m)>{i, m};
};
#ifdef __AVX512VL__
template <std::ptrdiff_t W>
TRIVIAL constexpr auto tailmask(std::ptrdiff_t i, std::ptrdiff_t m)
  -> Unroll<1, W, mask::Bit<W>> {
  return {i, mask::createSmallPositive<W>(m)};
}
#else
template <std::ptrdiff_t W>
TRIVIAL constexpr auto tailmask(std::ptrdiff_t i, std::ptrdiff_t m) {
  auto mask{mask::create<W>(i, i + m)};
  return Unroll<1, W, decltype(mask)>{i, mask};
}
#endif
template <std::ptrdiff_t U, std::ptrdiff_t W, typename M>
inline constexpr bool issimd<Unroll<U, W, M>> = true;
} // namespace index
} // namespace simd
